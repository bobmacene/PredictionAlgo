/* Writing crunched file prototype.js */
/*  Prototype JavaScript framework, version 1.6.0.3
 *  (c) 2005-2008 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/

var Prototype = {
  Version: '1.6.0.3',

  Browser: {
    IE:     !!(window.attachEvent &&
      navigator.userAgent.indexOf('Opera') === -1),
    Opera:  navigator.userAgent.indexOf('Opera') > -1,
    WebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
    Gecko:  navigator.userAgent.indexOf('Gecko') > -1 &&
      navigator.userAgent.indexOf('KHTML') === -1,
    MobileSafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/)
  },

  BrowserFeatures: {
    XPath: !!document.evaluate,
    SelectorsAPI: !!document.querySelector,
    ElementExtensions: !!window.HTMLElement,
    SpecificElementExtensions:
      document.createElement('div')['__proto__'] &&
      document.createElement('div')['__proto__'] !==
        document.createElement('form')['__proto__']
  },

  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,

  emptyFunction: function() { },
  K: function(x) { return x }
};

if (Prototype.Browser.MobileSafari)
  Prototype.BrowserFeatures.SpecificElementExtensions = false;


/* Based on Alex Arnell's inheritance implementation. */
var Class = {
  create: function() {
    var parent = null, properties = $A(arguments);
    if (Object.isFunction(properties[0]))
      parent = properties.shift();

    function klass() {
      this.initialize.apply(this, arguments);
    }

    Object.extend(klass, Class.Methods);
    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      var subclass = function() { };
      subclass.prototype = parent.prototype;
      klass.prototype = new subclass;
      parent.subclasses.push(klass);
    }

    for (var i = 0; i < properties.length; i++)
      klass.addMethods(properties[i]);

    if (!klass.prototype.initialize)
      klass.prototype.initialize = Prototype.emptyFunction;

    klass.prototype.constructor = klass;

    return klass;
  }
};

Class.Methods = {
  addMethods: function(source) {
    var ancestor   = this.superclass && this.superclass.prototype;
    var properties = Object.keys(source);

    if (!Object.keys({ toString: true }).length)
      properties.push("toString", "valueOf");

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && Object.isFunction(value) &&
          value.argumentNames().first() == "$super") {
        var method = value;
        value = (function(m) {
          return function() { return ancestor[m].apply(this, arguments) };
        })(property).wrap(method);

        value.valueOf = method.valueOf.bind(method);
        value.toString = method.toString.bind(method);
      }
      this.prototype[property] = value;
    }

    return this;
  }
};

var Abstract = { };

Object.extend = function(destination, source) {
  for (var property in source)
    destination[property] = source[property];
  return destination;
};

Object.extend(Object, {
  inspect: function(object) {
    try {
      if (Object.isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  },

  toJSON: function(object) {
    var type = typeof object;
    switch (type) {
      case 'undefined':
      case 'function':
      case 'unknown': return;
      case 'boolean': return object.toString();
    }

    if (object === null) return 'null';
    if (object.toJSON) return object.toJSON();
    if (Object.isElement(object)) return;

    var results = [];
    for (var property in object) {
      var value = Object.toJSON(object[property]);
      if (!Object.isUndefined(value))
        results.push(property.toJSON() + ': ' + value);
    }

    return '{' + results.join(', ') + '}';
  },

  toQueryString: function(object) {
    return $H(object).toQueryString();
  },

  toHTML: function(object) {
    return object && object.toHTML ? object.toHTML() : String.interpret(object);
  },

  keys: function(object) {
    var keys = [];
    for (var property in object)
      keys.push(property);
    return keys;
  },

  values: function(object) {
    var values = [];
    for (var property in object)
      values.push(object[property]);
    return values;
  },

  clone: function(object) {
    return Object.extend({ }, object);
  },

  isElement: function(object) {
    return !!(object && object.nodeType == 1);
  },

  isArray: function(object) {
    return object != null && typeof object == "object" &&
      'splice' in object && 'join' in object;
  },

  isHash: function(object) {
    return object instanceof Hash;
  },

  isFunction: function(object) {
    return typeof object == "function";
  },

  isString: function(object) {
    return typeof object == "string";
  },

  isNumber: function(object) {
    return typeof object == "number";
  },

  isUndefined: function(object) {
    return typeof object == "undefined";
  }
});

Object.extend(Function.prototype, {
  argumentNames: function() {
    var names = this.toString().match(/^[\s\(]*function[^(]*\(([^\)]*)\)/)[1]
      .replace(/\s+/g, '').split(',');
    return names.length == 1 && !names[0] ? [] : names;
  },

  bind: function() {
    if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
    var __method = this, args = $A(arguments), object = args.shift();
    return function() {
      return __method.apply(object, args.concat($A(arguments)));
    }
  },

  bindAsEventListener: function() {
    var __method = this, args = $A(arguments), object = args.shift();
    return function(event) {
      return __method.apply(object, [event || window.event].concat(args));
    }
  },

  curry: function() {
    if (!arguments.length) return this;
    var __method = this, args = $A(arguments);
    return function() {
      return __method.apply(this, args.concat($A(arguments)));
    }
  },

  delay: function() {
    var __method = this, args = $A(arguments), timeout = args.shift() * 1000;
    return window.setTimeout(function() {
      return __method.apply(__method, args);
    }, timeout);
  },

  defer: function() {
    var args = [0.01].concat($A(arguments));
    return this.delay.apply(this, args);
  },

  wrap: function(wrapper) {
    var __method = this;
    return function() {
      return wrapper.apply(this, [__method.bind(this)].concat($A(arguments)));
    }
  },

  methodize: function() {
    if (this._methodized) return this._methodized;
    var __method = this;
    return this._methodized = function() {
      return __method.apply(null, [this].concat($A(arguments)));
    };
  }
});

Date.prototype.toJSON = function() {
  return '"' + this.getUTCFullYear() + '-' +
    (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
    this.getUTCDate().toPaddedString(2) + 'T' +
    this.getUTCHours().toPaddedString(2) + ':' +
    this.getUTCMinutes().toPaddedString(2) + ':' +
    this.getUTCSeconds().toPaddedString(2) + 'Z"';
};

var Try = {
  these: function() {
    var returnValue;

    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) { }
    }

    return returnValue;
  }
};

RegExp.prototype.match = RegExp.prototype.test;

RegExp.escape = function(str) {
  return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};

/*--------------------------------------------------------------------------*/

var PeriodicalExecuter = Class.create({
  initialize: function(callback, frequency) {
    this.callback = callback;
    this.frequency = frequency;
    this.currentlyExecuting = false;

    this.registerCallback();
  },

  registerCallback: function() {
    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
  },

  execute: function() {
    this.callback(this);
  },

  stop: function() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  },

  onTimerEvent: function() {
    if (!this.currentlyExecuting) {
      try {
        this.currentlyExecuting = true;
        this.execute();
      } finally {
        this.currentlyExecuting = false;
      }
    }
  }
});
Object.extend(String, {
  interpret: function(value) {
    return value == null ? '' : String(value);
  },
  specialChar: {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  }
});

Object.extend(String.prototype, {
  gsub: function(pattern, replacement) {
    var result = '', source = this, match;
    replacement = arguments.callee.prepareReplacement(replacement);

    while (source.length > 0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += String.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  },

  sub: function(pattern, replacement, count) {
    replacement = this.gsub.prepareReplacement(replacement);
    count = Object.isUndefined(count) ? 1 : count;

    return this.gsub(pattern, function(match) {
      if (--count < 0) return match[0];
      return replacement(match);
    });
  },

  scan: function(pattern, iterator) {
    this.gsub(pattern, iterator);
    return String(this);
  },

  truncate: function(length, truncation) {
    length = length || 30;
    truncation = Object.isUndefined(truncation) ? '...' : truncation;
    return this.length > length ?
      this.slice(0, length - truncation.length) + truncation : String(this);
  },

  strip: function() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '');
  },

  stripTags: function() {
    return this.replace(/<\/?[^>]+>/gi, '');
  },

  stripScripts: function() {
    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
  },

  extractScripts: function() {
    var matchAll = new RegExp(Prototype.ScriptFragment, 'img');
    var matchOne = new RegExp(Prototype.ScriptFragment, 'im');
    return (this.match(matchAll) || []).map(function(scriptTag) {
      return (scriptTag.match(matchOne) || ['', ''])[1];
    });
  },

  evalScripts: function() {
    return this.extractScripts().map(function(script) { return eval(script) });
  },

  escapeHTML: function() {
    var self = arguments.callee;
    self.text.data = this;
    return self.div.innerHTML;
  },

  unescapeHTML: function() {
    var div = new Element('div');
    div.innerHTML = this.stripTags();
    return div.childNodes[0] ? (div.childNodes.length > 1 ?
      $A(div.childNodes).inject('', function(memo, node) { return memo+node.nodeValue }) :
      div.childNodes[0].nodeValue) : '';
  },

  toQueryParams: function(separator) {
    var match = this.strip().match(/([^?#]*)(#.*)?$/);
    if (!match) return { };

    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
      if ((pair = pair.split('='))[0]) {
        var key = decodeURIComponent(pair.shift());
        var value = pair.length > 1 ? pair.join('=') : pair[0];
        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
      return hash;
    });
  },

  toArray: function() {
    return this.split('');
  },

  succ: function() {
    return this.slice(0, this.length - 1) +
      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
  },

  times: function(count) {
    return count < 1 ? '' : new Array(count + 1).join(this);
  },

  camelize: function() {
    var parts = this.split('-'), len = parts.length;
    if (len == 1) return parts[0];

    var camelized = this.charAt(0) == '-'
      ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
      : parts[0];

    for (var i = 1; i < len; i++)
      camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);

    return camelized;
  },

  capitalize: function() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  },

  underscore: function() {
    return this.gsub(/::/, '/').gsub(/([A-Z]+)([A-Z][a-z])/,'#{1}_#{2}').gsub(/([a-z\d])([A-Z])/,'#{1}_#{2}').gsub(/-/,'_').toLowerCase();
  },

  dasherize: function() {
    return this.gsub(/_/,'-');
  },

  inspect: function(useDoubleQuotes) {
    var escapedString = this.gsub(/[\x00-\x1f\\]/, function(match) {
      var character = String.specialChar[match[0]];
      return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
    });
    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
  },

  toJSON: function() {
    return this.inspect(true);
  },

  unfilterJSON: function(filter) {
    return this.sub(filter || Prototype.JSONFilter, '#{1}');
  },

  isJSON: function() {
    var str = this;
    if (str.blank()) return false;
    str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
    return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
  },

  evalJSON: function(sanitize) {
    var json = this.unfilterJSON();
    try {
      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
    } catch (e) { }
    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
  },

  include: function(pattern) {
    return this.indexOf(pattern) > -1;
  },

  startsWith: function(pattern) {
    return this.indexOf(pattern) === 0;
  },

  endsWith: function(pattern) {
    var d = this.length - pattern.length;
    return d >= 0 && this.lastIndexOf(pattern) === d;
  },

  empty: function() {
    return this == '';
  },

  blank: function() {
    return /^\s*$/.test(this);
  },

  interpolate: function(object, pattern) {
    return new Template(this, pattern).evaluate(object);
  }
});

if (Prototype.Browser.WebKit || Prototype.Browser.IE) Object.extend(String.prototype, {
  escapeHTML: function() {
    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  },
  unescapeHTML: function() {
    return this.stripTags().replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>');
  }
});

String.prototype.gsub.prepareReplacement = function(replacement) {
  if (Object.isFunction(replacement)) return replacement;
  var template = new Template(replacement);
  return function(match) { return template.evaluate(match) };
};

String.prototype.parseQuery = String.prototype.toQueryParams;

Object.extend(String.prototype.escapeHTML, {
  div:  document.createElement('div'),
  text: document.createTextNode('')
});

String.prototype.escapeHTML.div.appendChild(String.prototype.escapeHTML.text);

var Template = Class.create({
  initialize: function(template, pattern) {
    this.template = template.toString();
    this.pattern = pattern || Template.Pattern;
  },

  evaluate: function(object) {
    if (Object.isFunction(object.toTemplateReplacements))
      object = object.toTemplateReplacements();

    return this.template.gsub(this.pattern, function(match) {
      if (object == null) return '';

      var before = match[1] || '';
      if (before == '\\') return match[2];

      var ctx = object, expr = match[3];
      var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
      match = pattern.exec(expr);
      if (match == null) return before;

      while (match != null) {
        var comp = match[1].startsWith('[') ? match[2].gsub('\\\\]', ']') : match[1];
        ctx = ctx[comp];
        if (null == ctx || '' == match[3]) break;
        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
        match = pattern.exec(expr);
      }

      return before + String.interpret(ctx);
    });
  }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;

var $break = { };

var Enumerable = {
  each: function(iterator, context) {
    var index = 0;
    try {
      this._each(function(value) {
        iterator.call(context, value, index++);
      });
    } catch (e) {
      if (e != $break) throw e;
    }
    return this;
  },

  eachSlice: function(number, iterator, context) {
    var index = -number, slices = [], array = this.toArray();
    if (number < 1) return array;
    while ((index += number) < array.length)
      slices.push(array.slice(index, index+number));
    return slices.collect(iterator, context);
  },

  all: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = true;
    this.each(function(value, index) {
      result = result && !!iterator.call(context, value, index);
      if (!result) throw $break;
    });
    return result;
  },

  any: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = false;
    this.each(function(value, index) {
      if (result = !!iterator.call(context, value, index))
        throw $break;
    });
    return result;
  },

  collect: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];
    this.each(function(value, index) {
      results.push(iterator.call(context, value, index));
    });
    return results;
  },

  detect: function(iterator, context) {
    var result;
    this.each(function(value, index) {
      if (iterator.call(context, value, index)) {
        result = value;
        throw $break;
      }
    });
    return result;
  },

  findAll: function(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  },

  grep: function(filter, iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];

    if (Object.isString(filter))
      filter = new RegExp(filter);

    this.each(function(value, index) {
      if (filter.match(value))
        results.push(iterator.call(context, value, index));
    });
    return results;
  },

  include: function(object) {
    if (Object.isFunction(this.indexOf))
      if (this.indexOf(object) != -1) return true;

    var found = false;
    this.each(function(value) {
      if (value == object) {
        found = true;
        throw $break;
      }
    });
    return found;
  },

  inGroupsOf: function(number, fillWith) {
    fillWith = Object.isUndefined(fillWith) ? null : fillWith;
    return this.eachSlice(number, function(slice) {
      while(slice.length < number) slice.push(fillWith);
      return slice;
    });
  },

  inject: function(memo, iterator, context) {
    this.each(function(value, index) {
      memo = iterator.call(context, memo, value, index);
    });
    return memo;
  },

  invoke: function(method) {
    var args = $A(arguments).slice(1);
    return this.map(function(value) {
      return value[method].apply(value, args);
    });
  },

  max: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value >= result)
        result = value;
    });
    return result;
  },

  min: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value < result)
        result = value;
    });
    return result;
  },

  partition: function(iterator, context) {
    iterator = iterator || Prototype.K;
    var trues = [], falses = [];
    this.each(function(value, index) {
      (iterator.call(context, value, index) ?
        trues : falses).push(value);
    });
    return [trues, falses];
  },

  pluck: function(property) {
    var results = [];
    this.each(function(value) {
      results.push(value[property]);
    });
    return results;
  },

  reject: function(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (!iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  },

  sortBy: function(iterator, context) {
    return this.map(function(value, index) {
      return {
        value: value,
        criteria: iterator.call(context, value, index)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }).pluck('value');
  },

  toArray: function() {
    return this.map();
  },

  zip: function() {
    var iterator = Prototype.K, args = $A(arguments);
    if (Object.isFunction(args.last()))
      iterator = args.pop();

    var collections = [this].concat(args).map($A);
    return this.map(function(value, index) {
      return iterator(collections.pluck(index));
    });
  },

  size: function() {
    return this.toArray().length;
  },

  inspect: function() {
    return '#<Enumerable:' + this.toArray().inspect() + '>';
  }
};

Object.extend(Enumerable, {
  map:     Enumerable.collect,
  find:    Enumerable.detect,
  select:  Enumerable.findAll,
  filter:  Enumerable.findAll,
  member:  Enumerable.include,
  entries: Enumerable.toArray,
  every:   Enumerable.all,
  some:    Enumerable.any
});
function $A(iterable) {
  if (!iterable) return [];
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length || 0, results = new Array(length);
  while (length--) results[length] = iterable[length];
  return results;
}

if (Prototype.Browser.WebKit) {
  $A = function(iterable) {
    if (!iterable) return [];
    // In Safari, only use the `toArray` method if it's not a NodeList.
    // A NodeList is a function, has an function `item` property, and a numeric
    // `length` property. Adapted from Google Doctype.
    if (!(typeof iterable === 'function' && typeof iterable.length ===
        'number' && typeof iterable.item === 'function') && iterable.toArray)
      return iterable.toArray();
    var length = iterable.length || 0, results = new Array(length);
    while (length--) results[length] = iterable[length];
    return results;
  };
}

Array.from = $A;

Object.extend(Array.prototype, Enumerable);

if (!Array.prototype._reverse) Array.prototype._reverse = Array.prototype.reverse;

Object.extend(Array.prototype, {
  _each: function(iterator) {
    for (var i = 0, length = this.length; i < length; i++)
      iterator(this[i]);
  },

  clear: function() {
    this.length = 0;
    return this;
  },

  first: function() {
    return this[0];
  },

  last: function() {
    return this[this.length - 1];
  },

  compact: function() {
    return this.select(function(value) {
      return value != null;
    });
  },

  flatten: function() {
    return this.inject([], function(array, value) {
      return array.concat(Object.isArray(value) ?
        value.flatten() : [value]);
    });
  },

  without: function() {
    var values = $A(arguments);
    return this.select(function(value) {
      return !values.include(value);
    });
  },

  reverse: function(inline) {
    return (inline !== false ? this : this.toArray())._reverse();
  },

  reduce: function() {
    return this.length > 1 ? this : this[0];
  },

  uniq: function(sorted) {
    return this.inject([], function(array, value, index) {
      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
        array.push(value);
      return array;
    });
  },

  intersect: function(array) {
    return this.uniq().findAll(function(item) {
      return array.detect(function(value) { return item === value });
    });
  },

  clone: function() {
    return [].concat(this);
  },

  size: function() {
    return this.length;
  },

  inspect: function() {
    return '[' + this.map(Object.inspect).join(', ') + ']';
  },

  toJSON: function() {
    var results = [];
    this.each(function(object) {
      var value = Object.toJSON(object);
      if (!Object.isUndefined(value)) results.push(value);
    });
    return '[' + results.join(', ') + ']';
  }
});

// use native browser JS 1.6 implementation if available
if (Object.isFunction(Array.prototype.forEach))
  Array.prototype._each = Array.prototype.forEach;

if (!Array.prototype.indexOf) Array.prototype.indexOf = function(item, i) {
  i || (i = 0);
  var length = this.length;
  if (i < 0) i = length + i;
  for (; i < length; i++)
    if (this[i] === item) return i;
  return -1;
};

if (!Array.prototype.lastIndexOf) Array.prototype.lastIndexOf = function(item, i) {
  i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
  var n = this.slice(0, i).reverse().indexOf(item);
  return (n < 0) ? n : i - n - 1;
};

Array.prototype.toArray = Array.prototype.clone;

function $w(string) {
  if (!Object.isString(string)) return [];
  string = string.strip();
  return string ? string.split(/\s+/) : [];
}

if (Prototype.Browser.Opera){
  Array.prototype.concat = function() {
    var array = [];
    for (var i = 0, length = this.length; i < length; i++) array.push(this[i]);
    for (var i = 0, length = arguments.length; i < length; i++) {
      if (Object.isArray(arguments[i])) {
        for (var j = 0, arrayLength = arguments[i].length; j < arrayLength; j++)
          array.push(arguments[i][j]);
      } else {
        array.push(arguments[i]);
      }
    }
    return array;
  };
}
Object.extend(Number.prototype, {
  toColorPart: function() {
    return this.toPaddedString(2, 16);
  },

  succ: function() {
    return this + 1;
  },

  times: function(iterator, context) {
    $R(0, this, true).each(iterator, context);
    return this;
  },

  toPaddedString: function(length, radix) {
    var string = this.toString(radix || 10);
    return '0'.times(length - string.length) + string;
  },

  toJSON: function() {
    return isFinite(this) ? this.toString() : 'null';
  }
});

$w('abs round ceil floor').each(function(method){
  Number.prototype[method] = Math[method].methodize();
});
function $H(object) {
  return new Hash(object);
};

var Hash = Class.create(Enumerable, (function() {

  function toQueryPair(key, value) {
    if (Object.isUndefined(value)) return key;
    return key + '=' + encodeURIComponent(String.interpret(value));
  }

  return {
    initialize: function(object) {
      this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
    },

    _each: function(iterator) {
      for (var key in this._object) {
        var value = this._object[key], pair = [key, value];
        pair.key = key;
        pair.value = value;
        iterator(pair);
      }
    },

    set: function(key, value) {
      return this._object[key] = value;
    },

    get: function(key) {
      // simulating poorly supported hasOwnProperty
      if (this._object[key] !== Object.prototype[key])
        return this._object[key];
    },

    unset: function(key) {
      var value = this._object[key];
      delete this._object[key];
      return value;
    },

    toObject: function() {
      return Object.clone(this._object);
    },

    keys: function() {
      return this.pluck('key');
    },

    values: function() {
      return this.pluck('value');
    },

    index: function(value) {
      var match = this.detect(function(pair) {
        return pair.value === value;
      });
      return match && match.key;
    },

    merge: function(object) {
      return this.clone().update(object);
    },

    update: function(object) {
      return new Hash(object).inject(this, function(result, pair) {
        result.set(pair.key, pair.value);
        return result;
      });
    },

    toQueryString: function() {
      return this.inject([], function(results, pair) {
        var key = encodeURIComponent(pair.key), values = pair.value;

        if (values && typeof values == 'object') {
          if (Object.isArray(values))
            return results.concat(values.map(toQueryPair.curry(key)));
        } else results.push(toQueryPair(key, values));
        return results;
      }).join('&');
    },

    inspect: function() {
      return '#<Hash:{' + this.map(function(pair) {
        return pair.map(Object.inspect).join(': ');
      }).join(', ') + '}>';
    },

    toJSON: function() {
      return Object.toJSON(this.toObject());
    },

    clone: function() {
      return new Hash(this);
    }
  }
})());

Hash.prototype.toTemplateReplacements = Hash.prototype.toObject;
Hash.from = $H;
var ObjectRange = Class.create(Enumerable, {
  initialize: function(start, end, exclusive) {
    this.start = start;
    this.end = end;
    this.exclusive = exclusive;
  },

  _each: function(iterator) {
    var value = this.start;
    while (this.include(value)) {
      iterator(value);
      value = value.succ();
    }
  },

  include: function(value) {
    if (value < this.start)
      return false;
    if (this.exclusive)
      return value < this.end;
    return value <= this.end;
  }
});

var $R = function(start, end, exclusive) {
  return new ObjectRange(start, end, exclusive);
};

var Ajax = {
  getTransport: function() {
    return Try.these(
      function() {return new XMLHttpRequest()},
      function() {return new ActiveXObject('Msxml2.XMLHTTP')},
      function() {return new ActiveXObject('Microsoft.XMLHTTP')}
    ) || false;
  },

  activeRequestCount: 0
};

Ajax.Responders = {
  responders: [],

  _each: function(iterator) {
    this.responders._each(iterator);
  },

  register: function(responder) {
    if (!this.include(responder))
      this.responders.push(responder);
  },

  unregister: function(responder) {
    this.responders = this.responders.without(responder);
  },

  dispatch: function(callback, request, transport, json) {
    this.each(function(responder) {
      if (Object.isFunction(responder[callback])) {
        try {
          responder[callback].apply(responder, [request, transport, json]);
        } catch (e) { }
      }
    });
  }
};

Object.extend(Ajax.Responders, Enumerable);

Ajax.Responders.register({
  onCreate:   function() { Ajax.activeRequestCount++ },
  onComplete: function() { Ajax.activeRequestCount-- }
});

Ajax.Base = Class.create({
  initialize: function(options) {
    this.options = {
      method:       'post',
      asynchronous: true,
      contentType:  'application/x-www-form-urlencoded',
      encoding:     'UTF-8',
      parameters:   '',
      evalJSON:     true,
      evalJS:       true
    };
    Object.extend(this.options, options || { });

    this.options.method = this.options.method.toLowerCase();

    if (Object.isString(this.options.parameters))
      this.options.parameters = this.options.parameters.toQueryParams();
    else if (Object.isHash(this.options.parameters))
      this.options.parameters = this.options.parameters.toObject();
  }
});

Ajax.Request = Class.create(Ajax.Base, {
  _complete: false,

  initialize: function($super, url, options) {
    $super(options);
    this.transport = Ajax.getTransport();
    this.request(url);
  },

  request: function(url) {
    this.url = url;
    this.method = this.options.method;
    var params = Object.clone(this.options.parameters);

    if (!['get', 'post'].include(this.method)) {
      // simulate other verbs over post
      params['_method'] = this.method;
      this.method = 'post';
    }

    this.parameters = params;

    if (params = Object.toQueryString(params)) {
      // when GET, append parameters to URL
      if (this.method == 'get')
        this.url += (this.url.include('?') ? '&' : '?') + params;
      else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
        params += '&_=';
    }

    try {
      var response = new Ajax.Response(this);
      if (this.options.onCreate) this.options.onCreate(response);
      Ajax.Responders.dispatch('onCreate', this, response);

      this.transport.open(this.method.toUpperCase(), this.url,
        this.options.asynchronous);

      if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);

      this.transport.onreadystatechange = this.onStateChange.bind(this);
      this.setRequestHeaders();

      this.body = this.method == 'post' ? (this.options.postBody || params) : null;
      this.transport.send(this.body);

      /* Force Firefox to handle ready state 4 for synchronous requests */
      if (!this.options.asynchronous && this.transport.overrideMimeType)
        this.onStateChange();

    }
    catch (e) {
      this.dispatchException(e);
    }
  },

  onStateChange: function() {
    var readyState = this.transport.readyState;
    if (readyState > 1 && !((readyState == 4) && this._complete))
      this.respondToReadyState(this.transport.readyState);
  },

  setRequestHeaders: function() {
    var headers = {
      'X-Requested-With': 'XMLHttpRequest',
      'X-Prototype-Version': Prototype.Version,
      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
    };

    if (this.method == 'post') {
      headers['Content-type'] = this.options.contentType +
        (this.options.encoding ? '; charset=' + this.options.encoding : '');

      /* Force "Connection: close" for older Mozilla browsers to work
       * around a bug where XMLHttpRequest sends an incorrect
       * Content-length header. See Mozilla Bugzilla #246651.
       */
      if (this.transport.overrideMimeType &&
          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
            headers['Connection'] = 'close';
    }

    // user-defined headers
    if (typeof this.options.requestHeaders == 'object') {
      var extras = this.options.requestHeaders;

      if (Object.isFunction(extras.push))
        for (var i = 0, length = extras.length; i < length; i += 2)
          headers[extras[i]] = extras[i+1];
      else
        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
    }

    for (var name in headers)
      this.transport.setRequestHeader(name, headers[name]);
  },

  success: function() {
    var status = this.getStatus();
    return !status || (status >= 200 && status < 300);
  },

  getStatus: function() {
    try {
      return this.transport.status || 0;
    } catch (e) { return 0 }
  },

  respondToReadyState: function(readyState) {
    var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);

    if (state == 'Complete') {
      try {
        this._complete = true;
        (this.options['on' + response.status]
         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
         || Prototype.emptyFunction)(response, response.headerJSON);
      } catch (e) {
        this.dispatchException(e);
      }

      var contentType = response.getHeader('Content-type');
      if (this.options.evalJS == 'force'
          || (this.options.evalJS && this.isSameOrigin() && contentType
          && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
        this.evalResponse();
    }

    try {
      (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
      Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
    } catch (e) {
      this.dispatchException(e);
    }

    if (state == 'Complete') {
      // avoid memory leak in MSIE: clean up
      this.transport.onreadystatechange = Prototype.emptyFunction;
    }
  },

  isSameOrigin: function() {
    var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
    return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
      protocol: location.protocol,
      domain: document.domain,
      port: location.port ? ':' + location.port : ''
    }));
  },

  getHeader: function(name) {
    try {
      return this.transport.getResponseHeader(name) || null;
    } catch (e) { return null }
  },

  evalResponse: function() {
    try {
      return eval((this.transport.responseText || '').unfilterJSON());
    } catch (e) {
      this.dispatchException(e);
    }
  },

  dispatchException: function(exception) {
    (this.options.onException || Prototype.emptyFunction)(this, exception);
    Ajax.Responders.dispatch('onException', this, exception);
  }
});

Ajax.Request.Events =
  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];

Ajax.Response = Class.create({
  initialize: function(request){
    this.request = request;
    var transport  = this.transport  = request.transport,
        readyState = this.readyState = transport.readyState;

    if((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
      this.status       = this.getStatus();
      this.statusText   = this.getStatusText();
      this.responseText = String.interpret(transport.responseText);
      this.headerJSON   = this._getHeaderJSON();
    }

    if(readyState == 4) {
      var xml = transport.responseXML;
      this.responseXML  = Object.isUndefined(xml) ? null : xml;
      this.responseJSON = this._getResponseJSON();
    }
  },

  status:      0,
  statusText: '',

  getStatus: Ajax.Request.prototype.getStatus,

  getStatusText: function() {
    try {
      return this.transport.statusText || '';
    } catch (e) { return '' }
  },

  getHeader: Ajax.Request.prototype.getHeader,

  getAllHeaders: function() {
    try {
      return this.getAllResponseHeaders();
    } catch (e) { return null }
  },

  getResponseHeader: function(name) {
    return this.transport.getResponseHeader(name);
  },

  getAllResponseHeaders: function() {
    return this.transport.getAllResponseHeaders();
  },

  _getHeaderJSON: function() {
    var json = this.getHeader('X-JSON');
    if (!json) return null;
    json = decodeURIComponent(escape(json));
    try {
      return json.evalJSON(this.request.options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  },

  _getResponseJSON: function() {
    var options = this.request.options;
    if (!options.evalJSON || (options.evalJSON != 'force' &&
      !(this.getHeader('Content-type') || '').include('application/json')) ||
        this.responseText.blank())
          return null;
    try {
      return this.responseText.evalJSON(options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  }
});

Ajax.Updater = Class.create(Ajax.Request, {
  initialize: function($super, container, url, options) {
    this.container = {
      success: (container.success || container),
      failure: (container.failure || (container.success ? null : container))
    };

    options = Object.clone(options);
    var onComplete = options.onComplete;
    options.onComplete = (function(response, json) {
      this.updateContent(response.responseText);
      if (Object.isFunction(onComplete)) onComplete(response, json);
    }).bind(this);

    $super(url, options);
  },

  updateContent: function(responseText) {
    var receiver = this.container[this.success() ? 'success' : 'failure'],
        options = this.options;

    if (!options.evalScripts) responseText = responseText.stripScripts();

    if (receiver = $(receiver)) {
      if (options.insertion) {
        if (Object.isString(options.insertion)) {
          var insertion = { }; insertion[options.insertion] = responseText;
          receiver.insert(insertion);
        }
        else options.insertion(receiver, responseText);
      }
      else receiver.update(responseText);
    }
  }
});

Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
  initialize: function($super, container, url, options) {
    $super(options);
    this.onComplete = this.options.onComplete;

    this.frequency = (this.options.frequency || 2);
    this.decay = (this.options.decay || 1);

    this.updater = { };
    this.container = container;
    this.url = url;

    this.start();
  },

  start: function() {
    this.options.onComplete = this.updateComplete.bind(this);
    this.onTimerEvent();
  },

  stop: function() {
    this.updater.options.onComplete = undefined;
    clearTimeout(this.timer);
    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
  },

  updateComplete: function(response) {
    if (this.options.decay) {
      this.decay = (response.responseText == this.lastText ?
        this.decay * this.options.decay : 1);

      this.lastText = response.responseText;
    }
    this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
  },

  onTimerEvent: function() {
    this.updater = new Ajax.Updater(this.container, this.url, this.options);
  }
});
function $(element) {
  if (arguments.length > 1) {
    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
      elements.push($(arguments[i]));
    return elements;
  }
  if (Object.isString(element))
    element = document.getElementById(element);
  return Element.extend(element);
}

if (Prototype.BrowserFeatures.XPath) {
  document._getElementsByXPath = function(expression, parentElement) {
    var results = [];
    var query = document.evaluate(expression, $(parentElement) || document,
      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = 0, length = query.snapshotLength; i < length; i++)
      results.push(Element.extend(query.snapshotItem(i)));
    return results;
  };
}

/*--------------------------------------------------------------------------*/

if (!window.Node) var Node = { };

if (!Node.ELEMENT_NODE) {
  // DOM level 2 ECMAScript Language Binding
  Object.extend(Node, {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  });
}

(function() {
  var element = this.Element;
  this.Element = function(tagName, attributes) {
    attributes = attributes || { };
    tagName = tagName.toLowerCase();
    var cache = Element.cache;
    if (Prototype.Browser.IE && attributes.name) {
      tagName = '<' + tagName + ' name="' + attributes.name + '">';
      delete attributes.name;
      return Element.writeAttribute(document.createElement(tagName), attributes);
    }
    if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));
    return Element.writeAttribute(cache[tagName].cloneNode(false), attributes);
  };
  Object.extend(this.Element, element || { });
  if (element) this.Element.prototype = element.prototype;
}).call(window);

Element.cache = { };

Element.Methods = {
  visible: function(element) {
    return $(element).style.display != 'none';
  },

  toggle: function(element) {
    element = $(element);
    Element[Element.visible(element) ? 'hide' : 'show'](element);
    return element;
  },

  hide: function(element) {
    element = $(element);
    element.style.display = 'none';
    return element;
  },

  show: function(element) {
    element = $(element);
    element.style.display = '';
    return element;
  },

  remove: function(element) {
    element = $(element);
    element.parentNode.removeChild(element);
    return element;
  },

  update: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) return element.update().insert(content);
    content = Object.toHTML(content);
    element.innerHTML = content.stripScripts();
    content.evalScripts.bind(content).defer();
    return element;
  },

  replace: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    else if (!Object.isElement(content)) {
      content = Object.toHTML(content);
      var range = element.ownerDocument.createRange();
      range.selectNode(element);
      content.evalScripts.bind(content).defer();
      content = range.createContextualFragment(content.stripScripts());
    }
    element.parentNode.replaceChild(content, element);
    return element;
  },

  insert: function(element, insertions) {
    element = $(element);

    if (Object.isString(insertions) || Object.isNumber(insertions) ||
        Object.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = {bottom:insertions};

    var content, insert, tagName, childNodes;

    for (var position in insertions) {
      content  = insertions[position];
      position = position.toLowerCase();
      insert = Element._insertionTranslations[position];

      if (content && content.toElement) content = content.toElement();
      if (Object.isElement(content)) {
        insert(element, content);
        continue;
      }

      content = Object.toHTML(content);

      tagName = ((position == 'before' || position == 'after')
        ? element.parentNode : element).tagName.toUpperCase();

      childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());

      if (position == 'top' || position == 'after') childNodes.reverse();
      childNodes.each(insert.curry(element));

      content.evalScripts.bind(content).defer();
    }

    return element;
  },

  wrap: function(element, wrapper, attributes) {
    element = $(element);
    if (Object.isElement(wrapper))
      $(wrapper).writeAttribute(attributes || { });
    else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
    else wrapper = new Element('div', wrapper);
    if (element.parentNode)
      element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(element);
    return wrapper;
  },

  inspect: function(element) {
    element = $(element);
    var result = '<' + element.tagName.toLowerCase();
    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
      var property = pair.first(), attribute = pair.last();
      var value = (element[property] || '').toString();
      if (value) result += ' ' + attribute + '=' + value.inspect(true);
    });
    return result + '>';
  },

  recursivelyCollect: function(element, property) {
    element = $(element);
    var elements = [];
    while (element = element[property])
      if (element.nodeType == 1)
        elements.push(Element.extend(element));
    return elements;
  },

  ancestors: function(element) {
    return $(element).recursivelyCollect('parentNode');
  },

  descendants: function(element) {
    return $(element).select("*");
  },

  firstDescendant: function(element) {
    element = $(element).firstChild;
    while (element && element.nodeType != 1) element = element.nextSibling;
    return $(element);
  },

  immediateDescendants: function(element) {
    if (!(element = $(element).firstChild)) return [];
    while (element && element.nodeType != 1) element = element.nextSibling;
    if (element) return [element].concat($(element).nextSiblings());
    return [];
  },

  previousSiblings: function(element) {
    return $(element).recursivelyCollect('previousSibling');
  },

  nextSiblings: function(element) {
    return $(element).recursivelyCollect('nextSibling');
  },

  siblings: function(element) {
    element = $(element);
    return element.previousSiblings().reverse().concat(element.nextSiblings());
  },

  match: function(element, selector) {
    if (Object.isString(selector))
      selector = new Selector(selector);
    return selector.match($(element));
  },

  up: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(element.parentNode);
    var ancestors = element.ancestors();
    return Object.isNumber(expression) ? ancestors[expression] :
      Selector.findElement(ancestors, expression, index);
  },

  down: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return element.firstDescendant();
    return Object.isNumber(expression) ? element.descendants()[expression] :
      Element.select(element, expression)[index || 0];
  },

  previous: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(Selector.handlers.previousElementSibling(element));
    var previousSiblings = element.previousSiblings();
    return Object.isNumber(expression) ? previousSiblings[expression] :
      Selector.findElement(previousSiblings, expression, index);
  },

  next: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(Selector.handlers.nextElementSibling(element));
    var nextSiblings = element.nextSiblings();
    return Object.isNumber(expression) ? nextSiblings[expression] :
      Selector.findElement(nextSiblings, expression, index);
  },

  select: function() {
    var args = $A(arguments), element = $(args.shift());
    return Selector.findChildElements(element, args);
  },

  adjacent: function() {
    var args = $A(arguments), element = $(args.shift());
    return Selector.findChildElements(element.parentNode, args).without(element);
  },

  identify: function(element) {
    element = $(element);
    var id = element.readAttribute('id'), self = arguments.callee;
    if (id) return id;
    do { id = 'anonymous_element_' + self.counter++ } while ($(id));
    element.writeAttribute('id', id);
    return id;
  },

  readAttribute: function(element, name) {
    element = $(element);
    if (Prototype.Browser.IE) {
      var t = Element._attributeTranslations.read;
      if (t.values[name]) return t.values[name](element, name);
      if (t.names[name]) name = t.names[name];
      if (name.include(':')) {
        return (!element.attributes || !element.attributes[name]) ? null :
         element.attributes[name].value;
      }
    }
    return element.getAttribute(name);
  },

  writeAttribute: function(element, name, value) {
    element = $(element);
    var attributes = { }, t = Element._attributeTranslations.write;

    if (typeof name == 'object') attributes = name;
    else attributes[name] = Object.isUndefined(value) ? true : value;

    for (var attr in attributes) {
      name = t.names[attr] || attr;
      value = attributes[attr];
      if (t.values[attr]) name = t.values[attr](element, value);
      if (value === false || value === null)
        element.removeAttribute(name);
      else if (value === true)
        element.setAttribute(name, name);
      else element.setAttribute(name, value);
    }
    return element;
  },

  getHeight: function(element) {
    return $(element).getDimensions().height;
  },

  getWidth: function(element) {
    return $(element).getDimensions().width;
  },

  classNames: function(element) {
    return new Element.ClassNames(element);
  },

  hasClassName: function(element, className) {
    if (!(element = $(element))) return;
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className ||
      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  },

  addClassName: function(element, className) {
    if (!(element = $(element))) return;
    if (!element.hasClassName(className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  },

  removeClassName: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  toggleClassName: function(element, className) {
    if (!(element = $(element))) return;
    return element[element.hasClassName(className) ?
      'removeClassName' : 'addClassName'](className);
  },

  // removes whitespace-only text node children
  cleanWhitespace: function(element) {
    element = $(element);
    var node = element.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
        element.removeChild(node);
      node = nextNode;
    }
    return element;
  },

  empty: function(element) {
    return $(element).innerHTML.blank();
  },

  descendantOf: function(element, ancestor) {
    element = $(element), ancestor = $(ancestor);

    if (element.compareDocumentPosition)
      return (element.compareDocumentPosition(ancestor) & 8) === 8;

    if (ancestor.contains)
      return ancestor.contains(element) && ancestor !== element;

    while (element = element.parentNode)
      if (element == ancestor) return true;

    return false;
  },

  scrollTo: function(element) {
    element = $(element);
    var pos = element.cumulativeOffset();
    window.scrollTo(pos[0], pos[1]);
    return element;
  },

  getStyle: function(element, style) {
    element = $(element);
    style = style == 'float' ? 'cssFloat' : style.camelize();
    var value = element.style[style];
    if (!value || value == 'auto') {
      var css = document.defaultView.getComputedStyle(element, null);
      value = css ? css[style] : null;
    }
    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
    return value == 'auto' ? null : value;
  },

  getOpacity: function(element) {
    return $(element).getStyle('opacity');
  },

  setStyle: function(element, styles) {
    element = $(element);
    var elementStyle = element.style, match;
    if (Object.isString(styles)) {
      element.style.cssText += ';' + styles;
      return styles.include('opacity') ?
        element.setOpacity(styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
    }
    for (var property in styles)
      if (property == 'opacity') element.setOpacity(styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    return element;
  },

  setOpacity: function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;
    return element;
  },

  getDimensions: function(element) {
    element = $(element);
    var display = element.getStyle('display');
    if (display != 'none' && display != null) // Safari bug
      return {width: element.offsetWidth, height: element.offsetHeight};

    // All *Width and *Height properties give 0 on elements with display none,
    // so enable the element temporarily
    var els = element.style;
    var originalVisibility = els.visibility;
    var originalPosition = els.position;
    var originalDisplay = els.display;
    els.visibility = 'hidden';
    els.position = 'absolute';
    els.display = 'block';
    var originalWidth = element.clientWidth;
    var originalHeight = element.clientHeight;
    els.display = originalDisplay;
    els.position = originalPosition;
    els.visibility = originalVisibility;
    return {width: originalWidth, height: originalHeight};
  },

  makePositioned: function(element) {
    element = $(element);
    var pos = Element.getStyle(element, 'position');
    if (pos == 'static' || !pos) {
      element._madePositioned = true;
      element.style.position = 'relative';
      // Opera returns the offset relative to the positioning context, when an
      // element is position relative but top and left have not been defined
      if (Prototype.Browser.Opera) {
        element.style.top = 0;
        element.style.left = 0;
      }
    }
    return element;
  },

  undoPositioned: function(element) {
    element = $(element);
    if (element._madePositioned) {
      element._madePositioned = undefined;
      element.style.position =
        element.style.top =
        element.style.left =
        element.style.bottom =
        element.style.right = '';
    }
    return element;
  },

  makeClipping: function(element) {
    element = $(element);
    if (element._overflow) return element;
    element._overflow = Element.getStyle(element, 'overflow') || 'auto';
    if (element._overflow !== 'hidden')
      element.style.overflow = 'hidden';
    return element;
  },

  undoClipping: function(element) {
    element = $(element);
    if (!element._overflow) return element;
    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
    element._overflow = null;
    return element;
  },

  cumulativeOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  positionedOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
      if (element) {
        if (element.tagName.toUpperCase() == 'BODY') break;
        var p = Element.getStyle(element, 'position');
        if (p !== 'static') break;
      }
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  absolutize: function(element) {
    element = $(element);
    if (element.getStyle('position') == 'absolute') return element;
    // Position.prepare(); // To be done manually by Scripty when it needs it.

    var offsets = element.positionedOffset();
    var top     = offsets[1];
    var left    = offsets[0];
    var width   = element.clientWidth;
    var height  = element.clientHeight;

    element._originalLeft   = left - parseFloat(element.style.left  || 0);
    element._originalTop    = top  - parseFloat(element.style.top || 0);
    element._originalWidth  = element.style.width;
    element._originalHeight = element.style.height;

    element.style.position = 'absolute';
    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.width  = width + 'px';
    element.style.height = height + 'px';
    return element;
  },

  relativize: function(element) {
    element = $(element);
    if (element.getStyle('position') == 'relative') return element;
    // Position.prepare(); // To be done manually by Scripty when it needs it.

    element.style.position = 'relative';
    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);

    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.height = element._originalHeight;
    element.style.width  = element._originalWidth;
    return element;
  },

  cumulativeScrollOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.scrollTop  || 0;
      valueL += element.scrollLeft || 0;
      element = element.parentNode;
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  getOffsetParent: function(element) {
    if (element.offsetParent) return $(element.offsetParent);
    if (element == document.body) return $(element);

    while ((element = element.parentNode) && element != document.body)
      if (Element.getStyle(element, 'position') != 'static')
        return $(element);

    return $(document.body);
  },

  viewportOffset: function(forElement) {
    var valueT = 0, valueL = 0;

    var element = forElement;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;

      // Safari fix
      if (element.offsetParent == document.body &&
        Element.getStyle(element, 'position') == 'absolute') break;

    } while (element = element.offsetParent);

    element = forElement;
    do {
      if (!Prototype.Browser.Opera || (element.tagName && (element.tagName.toUpperCase() == 'BODY'))) {
        valueT -= element.scrollTop  || 0;
        valueL -= element.scrollLeft || 0;
      }
    } while (element = element.parentNode);

    return Element._returnOffset(valueL, valueT);
  },

  clonePosition: function(element, source) {
    var options = Object.extend({
      setLeft:    true,
      setTop:     true,
      setWidth:   true,
      setHeight:  true,
      offsetTop:  0,
      offsetLeft: 0
    }, arguments[2] || { });

    // find page position of source
    source = $(source);
    var p = source.viewportOffset();

    // find coordinate system to use
    element = $(element);
    var delta = [0, 0];
    var parent = null;
    // delta [0,0] will do fine with position: fixed elements,
    // position:absolute needs offsetParent deltas
    if (Element.getStyle(element, 'position') == 'absolute') {
      parent = element.getOffsetParent();
      delta = parent.viewportOffset();
    }

    // correct by body offsets (fixes Safari)
    if (parent == document.body) {
      delta[0] -= document.body.offsetLeft;
      delta[1] -= document.body.offsetTop;
    }

    // set position
    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
    return element;
  }
};

Element.Methods.identify.counter = 1;

Object.extend(Element.Methods, {
  getElementsBySelector: Element.Methods.select,
  childElements: Element.Methods.immediateDescendants
});

Element._attributeTranslations = {
  write: {
    names: {
      className: 'class',
      htmlFor:   'for'
    },
    values: { }
  }
};

if (Prototype.Browser.Opera) {
  Element.Methods.getStyle = Element.Methods.getStyle.wrap(
    function(proceed, element, style) {
      switch (style) {
        case 'left': case 'top': case 'right': case 'bottom':
          if (proceed(element, 'position') === 'static') return null;
        case 'height': case 'width':
          // returns '0px' for hidden elements; we want it to return null
          if (!Element.visible(element)) return null;

          // returns the border-box dimensions rather than the content-box
          // dimensions, so we subtract padding and borders from the value
          var dim = parseInt(proceed(element, style), 10);

          if (dim !== element['offset' + style.capitalize()])
            return dim + 'px';

          var properties;
          if (style === 'height') {
            properties = ['border-top-width', 'padding-top',
             'padding-bottom', 'border-bottom-width'];
          }
          else {
            properties = ['border-left-width', 'padding-left',
             'padding-right', 'border-right-width'];
          }
          return properties.inject(dim, function(memo, property) {
            var val = proceed(element, property);
            return val === null ? memo : memo - parseInt(val, 10);
          }) + 'px';
        default: return proceed(element, style);
      }
    }
  );

  Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
    function(proceed, element, attribute) {
      if (attribute === 'title') return element.title;
      return proceed(element, attribute);
    }
  );
}

else if (Prototype.Browser.IE) {
  // IE doesn't report offsets correctly for static elements, so we change them
  // to "relative" to get the values, then change them back.
  Element.Methods.getOffsetParent = Element.Methods.getOffsetParent.wrap(
    function(proceed, element) {
      element = $(element);
      // IE throws an error if element is not in document
      try { element.offsetParent }
      catch(e) { return $(document.body) }
      var position = element.getStyle('position');
      if (position !== 'static') return proceed(element);
      element.setStyle({ position: 'relative' });
      var value = proceed(element);
      element.setStyle({ position: position });
      return value;
    }
  );

  $w('positionedOffset viewportOffset').each(function(method) {
    Element.Methods[method] = Element.Methods[method].wrap(
      function(proceed, element) {
        element = $(element);
        try { element.offsetParent }
        catch(e) { return Element._returnOffset(0,0) }
        var position = element.getStyle('position');
        if (position !== 'static') return proceed(element);
        // Trigger hasLayout on the offset parent so that IE6 reports
        // accurate offsetTop and offsetLeft values for position: fixed.
        var offsetParent = element.getOffsetParent();
        if (offsetParent && offsetParent.getStyle('position') === 'fixed')
          offsetParent.setStyle({ zoom: 1 });
        element.setStyle({ position: 'relative' });
        var value = proceed(element);
        element.setStyle({ position: position });
        return value;
      }
    );
  });

  Element.Methods.cumulativeOffset = Element.Methods.cumulativeOffset.wrap(
    function(proceed, element) {
      try { element.offsetParent }
      catch(e) { return Element._returnOffset(0,0) }
      return proceed(element);
    }
  );

  Element.Methods.getStyle = function(element, style) {
    element = $(element);
    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
    var value = element.style[style];
    if (!value && element.currentStyle) value = element.currentStyle[style];

    if (style == 'opacity') {
      if (value = (element.getStyle('filter') || '').match(/alpha\(opacity=(.*)\)/))
        if (value[1]) return parseFloat(value[1]) / 100;
      return 1.0;
    }

    if (value == 'auto') {
      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
        return element['offset' + style.capitalize()] + 'px';
      return null;
    }
    return value;
  };

  Element.Methods.setOpacity = function(element, value) {
    function stripAlpha(filter){
      return filter.replace(/alpha\([^\)]*\)/gi,'');
    }
    element = $(element);
    var currentStyle = element.currentStyle;
    if ((currentStyle && !currentStyle.hasLayout) ||
      (!currentStyle && element.style.zoom == 'normal'))
        element.style.zoom = 1;

    var filter = element.getStyle('filter'), style = element.style;
    if (value == 1 || value === '') {
      (filter = stripAlpha(filter)) ?
        style.filter = filter : style.removeAttribute('filter');
      return element;
    } else if (value < 0.00001) value = 0;
    style.filter = stripAlpha(filter) +
      'alpha(opacity=' + (value * 100) + ')';
    return element;
  };

  Element._attributeTranslations = {
    read: {
      names: {
        'class': 'className',
        'for':   'htmlFor'
      },
      values: {
        _getAttr: function(element, attribute) {
          return element.getAttribute(attribute, 2);
        },
        _getAttrNode: function(element, attribute) {
          var node = element.getAttributeNode(attribute);
          return node ? node.value : "";
        },
        _getEv: function(element, attribute) {
          attribute = element.getAttribute(attribute);
          return attribute ? attribute.toString().slice(23, -2) : null;
        },
        _flag: function(element, attribute) {
          return $(element).hasAttribute(attribute) ? attribute : null;
        },
        style: function(element) {
          return element.style.cssText.toLowerCase();
        },
        title: function(element) {
          return element.title;
        }
      }
    }
  };

  Element._attributeTranslations.write = {
    names: Object.extend({
      cellpadding: 'cellPadding',
      cellspacing: 'cellSpacing'
    }, Element._attributeTranslations.read.names),
    values: {
      checked: function(element, value) {
        element.checked = !!value;
      },

      style: function(element, value) {
        element.style.cssText = value ? value : '';
      }
    }
  };

  Element._attributeTranslations.has = {};

  $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
      'encType maxLength readOnly longDesc frameBorder').each(function(attr) {
    Element._attributeTranslations.write.names[attr.toLowerCase()] = attr;
    Element._attributeTranslations.has[attr.toLowerCase()] = attr;
  });

  (function(v) {
    Object.extend(v, {
      href:        v._getAttr,
      src:         v._getAttr,
      type:        v._getAttr,
      action:      v._getAttrNode,
      disabled:    v._flag,
      checked:     v._flag,
      readonly:    v._flag,
      multiple:    v._flag,
      onload:      v._getEv,
      onunload:    v._getEv,
      onclick:     v._getEv,
      ondblclick:  v._getEv,
      onmousedown: v._getEv,
      onmouseup:   v._getEv,
      onmouseover: v._getEv,
      onmousemove: v._getEv,
      onmouseout:  v._getEv,
      onfocus:     v._getEv,
      onblur:      v._getEv,
      onkeypress:  v._getEv,
      onkeydown:   v._getEv,
      onkeyup:     v._getEv,
      onsubmit:    v._getEv,
      onreset:     v._getEv,
      onselect:    v._getEv,
      onchange:    v._getEv
    });
  })(Element._attributeTranslations.read.values);
}

else if (Prototype.Browser.Gecko && /rv:1\.8\.0/.test(navigator.userAgent)) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1) ? 0.999999 :
      (value === '') ? '' : (value < 0.00001) ? 0 : value;
    return element;
  };
}

else if (Prototype.Browser.WebKit) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;

    if (value == 1)
      if(element.tagName.toUpperCase() == 'IMG' && element.width) {
        element.width++; element.width--;
      } else try {
        var n = document.createTextNode(' ');
        element.appendChild(n);
        element.removeChild(n);
      } catch (e) { }

    return element;
  };

  // Safari returns margins on body which is incorrect if the child is absolutely
  // positioned.  For performance reasons, redefine Element#cumulativeOffset for
  // KHTML/WebKit only.
  Element.Methods.cumulativeOffset = function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      if (element.offsetParent == document.body)
        if (Element.getStyle(element, 'position') == 'absolute') break;

      element = element.offsetParent;
    } while (element);

    return Element._returnOffset(valueL, valueT);
  };
}

if (Prototype.Browser.IE || Prototype.Browser.Opera) {
  // IE and Opera are missing .innerHTML support for TABLE-related and SELECT elements
  Element.Methods.update = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) return element.update().insert(content);

    content = Object.toHTML(content);
    var tagName = element.tagName.toUpperCase();

    if (tagName in Element._insertionTranslations.tags) {
      $A(element.childNodes).each(function(node) { element.removeChild(node) });
      Element._getContentFromAnonymousElement(tagName, content.stripScripts())
        .each(function(node) { element.appendChild(node) });
    }
    else element.innerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

if ('outerHTML' in document.createElement('div')) {
  Element.Methods.replace = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) {
      element.parentNode.replaceChild(content, element);
      return element;
    }

    content = Object.toHTML(content);
    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

    if (Element._insertionTranslations.tags[tagName]) {
      var nextSibling = element.next();
      var fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
      parent.removeChild(element);
      if (nextSibling)
        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
      else
        fragments.each(function(node) { parent.appendChild(node) });
    }
    else element.outerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

Element._returnOffset = function(l, t) {
  var result = [l, t];
  result.left = l;
  result.top = t;
  return result;
};

Element._getContentFromAnonymousElement = function(tagName, html) {
  var div = new Element('div'), t = Element._insertionTranslations.tags[tagName];
  if (t) {
    div.innerHTML = t[0] + html + t[1];
    t[2].times(function() { div = div.firstChild });
  } else div.innerHTML = html;
  return $A(div.childNodes);
};

Element._insertionTranslations = {
  before: function(element, node) {
    element.parentNode.insertBefore(node, element);
  },
  top: function(element, node) {
    element.insertBefore(node, element.firstChild);
  },
  bottom: function(element, node) {
    element.appendChild(node);
  },
  after: function(element, node) {
    element.parentNode.insertBefore(node, element.nextSibling);
  },
  tags: {
    TABLE:  ['<table>',                '</table>',                   1],
    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
    SELECT: ['<select>',               '</select>',                  1]
  }
};

(function() {
  Object.extend(this.tags, {
    THEAD: this.tags.TBODY,
    TFOOT: this.tags.TBODY,
    TH:    this.tags.TD
  });
}).call(Element._insertionTranslations);

Element.Methods.Simulated = {
  hasAttribute: function(element, attribute) {
    attribute = Element._attributeTranslations.has[attribute] || attribute;
    var node = $(element).getAttributeNode(attribute);
    return !!(node && node.specified);
  }
};

Element.Methods.ByTag = { };

Object.extend(Element, Element.Methods);

if (!Prototype.BrowserFeatures.ElementExtensions &&
    document.createElement('div')['__proto__']) {
  window.HTMLElement = { };
  window.HTMLElement.prototype = document.createElement('div')['__proto__'];
  Prototype.BrowserFeatures.ElementExtensions = true;
}

Element.extend = (function() {
  if (Prototype.BrowserFeatures.SpecificElementExtensions)
    return Prototype.K;

  var Methods = { }, ByTag = Element.Methods.ByTag;

  var extend = Object.extend(function(element) {
    if (!element || element._extendedByPrototype ||
        element.nodeType != 1 || element == window) return element;

    var methods = Object.clone(Methods),
      tagName = element.tagName.toUpperCase(), property, value;

    // extend methods for specific tags
    if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);

    for (property in methods) {
      value = methods[property];
      if (Object.isFunction(value) && !(property in element))
        element[property] = value.methodize();
    }

    element._extendedByPrototype = Prototype.emptyFunction;
    return element;

  }, {
    refresh: function() {
      // extend methods for all tags (Safari doesn't need this)
      if (!Prototype.BrowserFeatures.ElementExtensions) {
        Object.extend(Methods, Element.Methods);
        Object.extend(Methods, Element.Methods.Simulated);
      }
    }
  });

  extend.refresh();
  return extend;
})();

Element.hasAttribute = function(element, attribute) {
  if (element.hasAttribute) return element.hasAttribute(attribute);
  return Element.Methods.Simulated.hasAttribute(element, attribute);
};

Element.addMethods = function(methods) {
  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;

  if (!methods) {
    Object.extend(Form, Form.Methods);
    Object.extend(Form.Element, Form.Element.Methods);
    Object.extend(Element.Methods.ByTag, {
      "FORM":     Object.clone(Form.Methods),
      "INPUT":    Object.clone(Form.Element.Methods),
      "SELECT":   Object.clone(Form.Element.Methods),
      "TEXTAREA": Object.clone(Form.Element.Methods)
    });
  }

  if (arguments.length == 2) {
    var tagName = methods;
    methods = arguments[1];
  }

  if (!tagName) Object.extend(Element.Methods, methods || { });
  else {
    if (Object.isArray(tagName)) tagName.each(extend);
    else extend(tagName);
  }

  function extend(tagName) {
    tagName = tagName.toUpperCase();
    if (!Element.Methods.ByTag[tagName])
      Element.Methods.ByTag[tagName] = { };
    Object.extend(Element.Methods.ByTag[tagName], methods);
  }

  function copy(methods, destination, onlyIfAbsent) {
    onlyIfAbsent = onlyIfAbsent || false;
    for (var property in methods) {
      var value = methods[property];
      if (!Object.isFunction(value)) continue;
      if (!onlyIfAbsent || !(property in destination))
        destination[property] = value.methodize();
    }
  }

  function findDOMClass(tagName) {
    var klass;
    var trans = {
      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
      "FrameSet", "IFRAME": "IFrame"
    };
    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName.capitalize() + 'Element';
    if (window[klass]) return window[klass];

    window[klass] = { };
    window[klass].prototype = document.createElement(tagName)['__proto__'];
    return window[klass];
  }

  if (F.ElementExtensions) {
    copy(Element.Methods, HTMLElement.prototype);
    copy(Element.Methods.Simulated, HTMLElement.prototype, true);
  }

  if (F.SpecificElementExtensions) {
    for (var tag in Element.Methods.ByTag) {
      var klass = findDOMClass(tag);
      if (Object.isUndefined(klass)) continue;
      copy(T[tag], klass.prototype);
    }
  }

  Object.extend(Element, Element.Methods);
  delete Element.ByTag;

  if (Element.extend.refresh) Element.extend.refresh();
  Element.cache = { };
};

document.viewport = {
  getDimensions: function() {
    var dimensions = { }, B = Prototype.Browser;
    $w('width height').each(function(d) {
      var D = d.capitalize();
      if (B.WebKit && !document.evaluate) {
        // Safari <3.0 needs self.innerWidth/Height
        dimensions[d] = self['inner' + D];
      } else if (B.Opera && parseFloat(window.opera.version()) < 9.5) {
        // Opera <9.5 needs document.body.clientWidth/Height
        dimensions[d] = document.body['client' + D]
      } else {
        dimensions[d] = document.documentElement['client' + D];
      }
    });
    return dimensions;
  },

  getWidth: function() {
    return this.getDimensions().width;
  },

  getHeight: function() {
    return this.getDimensions().height;
  },

  getScrollOffsets: function() {
    return Element._returnOffset(
      window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
      window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
  }
};
/* Portions of the Selector class are derived from Jack Slocum's DomQuery,
 * part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
 * license.  Please see http://www.yui-ext.com/ for more information. */

var Selector = Class.create({
  initialize: function(expression) {
    this.expression = expression.strip();

    if (this.shouldUseSelectorsAPI()) {
      this.mode = 'selectorsAPI';
    } else if (this.shouldUseXPath()) {
      this.mode = 'xpath';
      this.compileXPathMatcher();
    } else {
      this.mode = "normal";
      this.compileMatcher();
    }

  },

  shouldUseXPath: function() {
    if (!Prototype.BrowserFeatures.XPath) return false;

    var e = this.expression;

    // Safari 3 chokes on :*-of-type and :empty
    if (Prototype.Browser.WebKit &&
     (e.include("-of-type") || e.include(":empty")))
      return false;

    // XPath can't do namespaced attributes, nor can it read
    // the "checked" property from DOM nodes
    if ((/(\[[\w-]*?:|:checked)/).test(e))
      return false;

    return true;
  },

  shouldUseSelectorsAPI: function() {
    if (!Prototype.BrowserFeatures.SelectorsAPI) return false;

    if (!Selector._div) Selector._div = new Element('div');

    // Make sure the browser treats the selector as valid. Test on an
    // isolated element to minimize cost of this check.
    try {
      Selector._div.querySelector(this.expression);
    } catch(e) {
      return false;
    }

    return true;
  },

  compileMatcher: function() {
    var e = this.expression, ps = Selector.patterns, h = Selector.handlers,
        c = Selector.criteria, le, p, m;

    if (Selector._cache[e]) {
      this.matcher = Selector._cache[e];
      return;
    }

    this.matcher = ["this.matcher = function(root) {",
                    "var r = root, h = Selector.handlers, c = false, n;"];

    while (e && le != e && (/\S/).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          this.matcher.push(Object.isFunction(c[i]) ? c[i](m) :
            new Template(c[i]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.matcher.push("return h.unique(n);\n}");
    eval(this.matcher.join('\n'));
    Selector._cache[this.expression] = this.matcher;
  },

  compileXPathMatcher: function() {
    var e = this.expression, ps = Selector.patterns,
        x = Selector.xpath, le, m;

    if (Selector._cache[e]) {
      this.xpath = Selector._cache[e]; return;
    }

    this.matcher = ['.//*'];
    while (e && le != e && (/\S/).test(e)) {
      le = e;
      for (var i in ps) {
        if (m = e.match(ps[i])) {
          this.matcher.push(Object.isFunction(x[i]) ? x[i](m) :
            new Template(x[i]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.xpath = this.matcher.join('');
    Selector._cache[this.expression] = this.xpath;
  },

  findElements: function(root) {
    root = root || document;
    var e = this.expression, results;

    switch (this.mode) {
      case 'selectorsAPI':
        // querySelectorAll queries document-wide, then filters to descendants
        // of the context element. That's not what we want.
        // Add an explicit context to the selector if necessary.
        if (root !== document) {
          var oldId = root.id, id = $(root).identify();
          e = "#" + id + " " + e;
        }

        results = $A(root.querySelectorAll(e)).map(Element.extend);
        root.id = oldId;

        return results;
      case 'xpath':
        return document._getElementsByXPath(this.xpath, root);
      default:
       return this.matcher(root);
    }
  },

  match: function(element) {
    this.tokens = [];

    var e = this.expression, ps = Selector.patterns, as = Selector.assertions;
    var le, p, m;

    while (e && le !== e && (/\S/).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          // use the Selector.assertions methods unless the selector
          // is too complex.
          if (as[i]) {
            this.tokens.push([i, Object.clone(m)]);
            e = e.replace(m[0], '');
          } else {
            // reluctantly do a document-wide search
            // and look for a match in the array
            return this.findElements(document).include(element);
          }
        }
      }
    }

    var match = true, name, matches;
    for (var i = 0, token; token = this.tokens[i]; i++) {
      name = token[0], matches = token[1];
      if (!Selector.assertions[name](element, matches)) {
        match = false; break;
      }
    }

    return match;
  },

  toString: function() {
    return this.expression;
  },

  inspect: function() {
    return "#<Selector:" + this.expression.inspect() + ">";
  }
});

Object.extend(Selector, {
  _cache: { },

  xpath: {
    descendant:   "//*",
    child:        "/*",
    adjacent:     "/following-sibling::*[1]",
    laterSibling: '/following-sibling::*',
    tagName:      function(m) {
      if (m[1] == '*') return '';
      return "[local-name()='" + m[1].toLowerCase() +
             "' or local-name()='" + m[1].toUpperCase() + "']";
    },
    className:    "[contains(concat(' ', @class, ' '), ' #{1} ')]",
    id:           "[@id='#{1}']",
    attrPresence: function(m) {
      m[1] = m[1].toLowerCase();
      return new Template("[@#{1}]").evaluate(m);
    },
    attr: function(m) {
      m[1] = m[1].toLowerCase();
      m[3] = m[5] || m[6];
      return new Template(Selector.xpath.operators[m[2]]).evaluate(m);
    },
    pseudo: function(m) {
      var h = Selector.xpath.pseudos[m[1]];
      if (!h) return '';
      if (Object.isFunction(h)) return h(m);
      return new Template(Selector.xpath.pseudos[m[1]]).evaluate(m);
    },
    operators: {
      '=':  "[@#{1}='#{3}']",
      '!=': "[@#{1}!='#{3}']",
      '^=': "[starts-with(@#{1}, '#{3}')]",
      '$=': "[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']",
      '*=': "[contains(@#{1}, '#{3}')]",
      '~=': "[contains(concat(' ', @#{1}, ' '), ' #{3} ')]",
      '|=': "[contains(concat('-', @#{1}, '-'), '-#{3}-')]"
    },
    pseudos: {
      'first-child': '[not(preceding-sibling::*)]',
      'last-child':  '[not(following-sibling::*)]',
      'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
      'empty':       "[count(*) = 0 and (count(text()) = 0)]",
      'checked':     "[@checked]",
      'disabled':    "[(@disabled) and (@type!='hidden')]",
      'enabled':     "[not(@disabled) and (@type!='hidden')]",
      'not': function(m) {
        var e = m[6], p = Selector.patterns,
            x = Selector.xpath, le, v;

        var exclusion = [];
        while (e && le != e && (/\S/).test(e)) {
          le = e;
          for (var i in p) {
            if (m = e.match(p[i])) {
              v = Object.isFunction(x[i]) ? x[i](m) : new Template(x[i]).evaluate(m);
              exclusion.push("(" + v.substring(1, v.length - 1) + ")");
              e = e.replace(m[0], '');
              break;
            }
          }
        }
        return "[not(" + exclusion.join(" and ") + ")]";
      },
      'nth-child':      function(m) {
        return Selector.xpath.pseudos.nth("(count(./preceding-sibling::*) + 1) ", m);
      },
      'nth-last-child': function(m) {
        return Selector.xpath.pseudos.nth("(count(./following-sibling::*) + 1) ", m);
      },
      'nth-of-type':    function(m) {
        return Selector.xpath.pseudos.nth("position() ", m);
      },
      'nth-last-of-type': function(m) {
        return Selector.xpath.pseudos.nth("(last() + 1 - position()) ", m);
      },
      'first-of-type':  function(m) {
        m[6] = "1"; return Selector.xpath.pseudos['nth-of-type'](m);
      },
      'last-of-type':   function(m) {
        m[6] = "1"; return Selector.xpath.pseudos['nth-last-of-type'](m);
      },
      'only-of-type':   function(m) {
        var p = Selector.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
      },
      nth: function(fragment, m) {
        var mm, formula = m[6], predicate;
        if (formula == 'even') formula = '2n+0';
        if (formula == 'odd')  formula = '2n+1';
        if (mm = formula.match(/^(\d+)$/)) // digit only
          return '[' + fragment + "= " + mm[1] + ']';
        if (mm = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
          if (mm[1] == "-") mm[1] = -1;
          var a = mm[1] ? Number(mm[1]) : 1;
          var b = mm[2] ? Number(mm[2]) : 0;
          predicate = "[((#{fragment} - #{b}) mod #{a} = 0) and " +
          "((#{fragment} - #{b}) div #{a} >= 0)]";
          return new Template(predicate).evaluate({
            fragment: fragment, a: a, b: b });
        }
      }
    }
  },

  criteria: {
    tagName:      'n = h.tagName(n, r, "#{1}", c);      c = false;',
    className:    'n = h.className(n, r, "#{1}", c);    c = false;',
    id:           'n = h.id(n, r, "#{1}", c);           c = false;',
    attrPresence: 'n = h.attrPresence(n, r, "#{1}", c); c = false;',
    attr: function(m) {
      m[3] = (m[5] || m[6]);
      return new Template('n = h.attr(n, r, "#{1}", "#{3}", "#{2}", c); c = false;').evaluate(m);
    },
    pseudo: function(m) {
      if (m[6]) m[6] = m[6].replace(/"/g, '\\"');
      return new Template('n = h.pseudo(n, "#{1}", "#{6}", r, c); c = false;').evaluate(m);
    },
    descendant:   'c = "descendant";',
    child:        'c = "child";',
    adjacent:     'c = "adjacent";',
    laterSibling: 'c = "laterSibling";'
  },

  patterns: {
    // combinators must be listed first
    // (and descendant needs to be last combinator)
    laterSibling: /^\s*~\s*/,
    child:        /^\s*>\s*/,
    adjacent:     /^\s*\+\s*/,
    descendant:   /^\s/,

    // selectors follow
    tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
    id:           /^#([\w\-\*]+)(\b|$)/,
    className:    /^\.([\w\-\*]+)(\b|$)/,
    pseudo:
/^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~>]))/,
    attrPresence: /^\[((?:[\w]+:)?[\w]+)\]/,
    attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/
  },

  // for Selector.match and Element#match
  assertions: {
    tagName: function(element, matches) {
      return matches[1].toUpperCase() == element.tagName.toUpperCase();
    },

    className: function(element, matches) {
      return Element.hasClassName(element, matches[1]);
    },

    id: function(element, matches) {
      return element.id === matches[1];
    },

    attrPresence: function(element, matches) {
      return Element.hasAttribute(element, matches[1]);
    },

    attr: function(element, matches) {
      var nodeValue = Element.readAttribute(element, matches[1]);
      return nodeValue && Selector.operators[matches[2]](nodeValue, matches[5] || matches[6]);
    }
  },

  handlers: {
    // UTILITY FUNCTIONS
    // joins two collections
    concat: function(a, b) {
      for (var i = 0, node; node = b[i]; i++)
        a.push(node);
      return a;
    },

    // marks an array of nodes for counting
    mark: function(nodes) {
      var _true = Prototype.emptyFunction;
      for (var i = 0, node; node = nodes[i]; i++)
        node._countedByPrototype = _true;
      return nodes;
    },

    unmark: function(nodes) {
      for (var i = 0, node; node = nodes[i]; i++)
        node._countedByPrototype = undefined;
      return nodes;
    },

    // mark each child node with its position (for nth calls)
    // "ofType" flag indicates whether we're indexing for nth-of-type
    // rather than nth-child
    index: function(parentNode, reverse, ofType) {
      parentNode._countedByPrototype = Prototype.emptyFunction;
      if (reverse) {
        for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {
          var node = nodes[i];
          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
        }
      } else {
        for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
      }
    },

    // filters out duplicates and extends all nodes
    unique: function(nodes) {
      if (nodes.length == 0) return nodes;
      var results = [], n;
      for (var i = 0, l = nodes.length; i < l; i++)
        if (!(n = nodes[i])._countedByPrototype) {
          n._countedByPrototype = Prototype.emptyFunction;
          results.push(Element.extend(n));
        }
      return Selector.handlers.unmark(results);
    },

    // COMBINATOR FUNCTIONS
    descendant: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, node.getElementsByTagName('*'));
      return results;
    },

    child: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        for (var j = 0, child; child = node.childNodes[j]; j++)
          if (child.nodeType == 1 && child.tagName != '!') results.push(child);
      }
      return results;
    },

    adjacent: function(nodes) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        var next = this.nextElementSibling(node);
        if (next) results.push(next);
      }
      return results;
    },

    laterSibling: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, Element.nextSiblings(node));
      return results;
    },

    nextElementSibling: function(node) {
      while (node = node.nextSibling)
        if (node.nodeType == 1) return node;
      return null;
    },

    previousElementSibling: function(node) {
      while (node = node.previousSibling)
        if (node.nodeType == 1) return node;
      return null;
    },

    // TOKEN FUNCTIONS
    tagName: function(nodes, root, tagName, combinator) {
      var uTagName = tagName.toUpperCase();
      var results = [], h = Selector.handlers;
      if (nodes) {
        if (combinator) {
          // fastlane for ordinary descendant combinators
          if (combinator == "descendant") {
            for (var i = 0, node; node = nodes[i]; i++)
              h.concat(results, node.getElementsByTagName(tagName));
            return results;
          } else nodes = this[combinator](nodes);
          if (tagName == "*") return nodes;
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.tagName.toUpperCase() === uTagName) results.push(node);
        return results;
      } else return root.getElementsByTagName(tagName);
    },

    id: function(nodes, root, id, combinator) {
      var targetNode = $(id), h = Selector.handlers;
      if (!targetNode) return [];
      if (!nodes && root == document) return [targetNode];
      if (nodes) {
        if (combinator) {
          if (combinator == 'child') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (targetNode.parentNode == node) return [targetNode];
          } else if (combinator == 'descendant') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (Element.descendantOf(targetNode, node)) return [targetNode];
          } else if (combinator == 'adjacent') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (Selector.handlers.previousElementSibling(targetNode) == node)
                return [targetNode];
          } else nodes = h[combinator](nodes);
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node == targetNode) return [targetNode];
        return [];
      }
      return (targetNode && Element.descendantOf(targetNode, root)) ? [targetNode] : [];
    },

    className: function(nodes, root, className, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      return Selector.handlers.byClassName(nodes, root, className);
    },

    byClassName: function(nodes, root, className) {
      if (!nodes) nodes = Selector.handlers.descendant([root]);
      var needle = ' ' + className + ' ';
      for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
        nodeClassName = node.className;
        if (nodeClassName.length == 0) continue;
        if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
          results.push(node);
      }
      return results;
    },

    attrPresence: function(nodes, root, attr, combinator) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      if (nodes && combinator) nodes = this[combinator](nodes);
      var results = [];
      for (var i = 0, node; node = nodes[i]; i++)
        if (Element.hasAttribute(node, attr)) results.push(node);
      return results;
    },

    attr: function(nodes, root, attr, value, operator, combinator) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      if (nodes && combinator) nodes = this[combinator](nodes);
      var handler = Selector.operators[operator], results = [];
      for (var i = 0, node; node = nodes[i]; i++) {
        var nodeValue = Element.readAttribute(node, attr);
        if (nodeValue === null) continue;
        if (handler(nodeValue, value)) results.push(node);
      }
      return results;
    },

    pseudo: function(nodes, name, value, root, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      if (!nodes) nodes = root.getElementsByTagName("*");
      return Selector.pseudos[name](nodes, value, root);
    }
  },

  pseudos: {
    'first-child': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (Selector.handlers.previousElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    'last-child': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (Selector.handlers.nextElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    'only-child': function(nodes, value, root) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!h.previousElementSibling(node) && !h.nextElementSibling(node))
          results.push(node);
      return results;
    },
    'nth-child':        function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root);
    },
    'nth-last-child':   function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, true);
    },
    'nth-of-type':      function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, false, true);
    },
    'nth-last-of-type': function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, true, true);
    },
    'first-of-type':    function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, "1", root, false, true);
    },
    'last-of-type':     function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, "1", root, true, true);
    },
    'only-of-type':     function(nodes, formula, root) {
      var p = Selector.pseudos;
      return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
    },

    // handles the an+b logic
    getIndices: function(a, b, total) {
      if (a == 0) return b > 0 ? [b] : [];
      return $R(1, total).inject([], function(memo, i) {
        if (0 == (i - b) % a && (i - b) / a >= 0) memo.push(i);
        return memo;
      });
    },

    // handles nth(-last)-child, nth(-last)-of-type, and (first|last)-of-type
    nth: function(nodes, formula, root, reverse, ofType) {
      if (nodes.length == 0) return [];
      if (formula == 'even') formula = '2n+0';
      if (formula == 'odd')  formula = '2n+1';
      var h = Selector.handlers, results = [], indexed = [], m;
      h.mark(nodes);
      for (var i = 0, node; node = nodes[i]; i++) {
        if (!node.parentNode._countedByPrototype) {
          h.index(node.parentNode, reverse, ofType);
          indexed.push(node.parentNode);
        }
      }
      if (formula.match(/^\d+$/)) { // just a number
        formula = Number(formula);
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.nodeIndex == formula) results.push(node);
      } else if (m = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
        if (m[1] == "-") m[1] = -1;
        var a = m[1] ? Number(m[1]) : 1;
        var b = m[2] ? Number(m[2]) : 0;
        var indices = Selector.pseudos.getIndices(a, b, nodes.length);
        for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
          for (var j = 0; j < l; j++)
            if (node.nodeIndex == indices[j]) results.push(node);
        }
      }
      h.unmark(nodes);
      h.unmark(indexed);
      return results;
    },

    'empty': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        // IE treats comments as element nodes
        if (node.tagName == '!' || node.firstChild) continue;
        results.push(node);
      }
      return results;
    },

    'not': function(nodes, selector, root) {
      var h = Selector.handlers, selectorType, m;
      var exclusions = new Selector(selector).findElements(root);
      h.mark(exclusions);
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node._countedByPrototype) results.push(node);
      h.unmark(exclusions);
      return results;
    },

    'enabled': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node.disabled && (!node.type || node.type !== 'hidden'))
          results.push(node);
      return results;
    },

    'disabled': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.disabled) results.push(node);
      return results;
    },

    'checked': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.checked) results.push(node);
      return results;
    }
  },

  operators: {
    '=':  function(nv, v) { return nv == v; },
    '!=': function(nv, v) { return nv != v; },
    '^=': function(nv, v) { return nv == v || nv && nv.startsWith(v); },
    '$=': function(nv, v) { return nv == v || nv && nv.endsWith(v); },
    '*=': function(nv, v) { return nv == v || nv && nv.include(v); },
    '$=': function(nv, v) { return nv.endsWith(v); },
    '*=': function(nv, v) { return nv.include(v); },
    '~=': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
    '|=': function(nv, v) { return ('-' + (nv || "").toUpperCase() +
     '-').include('-' + (v || "").toUpperCase() + '-'); }
  },

  split: function(expression) {
    var expressions = [];
    expression.scan(/(([\w#:.~>+()\s-]+|\*|\[.*?\])+)\s*(,|$)/, function(m) {
      expressions.push(m[1].strip());
    });
    return expressions;
  },

  matchElements: function(elements, expression) {
    var matches = $$(expression), h = Selector.handlers;
    h.mark(matches);
    for (var i = 0, results = [], element; element = elements[i]; i++)
      if (element._countedByPrototype) results.push(element);
    h.unmark(matches);
    return results;
  },

  findElement: function(elements, expression, index) {
    if (Object.isNumber(expression)) {
      index = expression; expression = false;
    }
    return Selector.matchElements(elements, expression || '*')[index || 0];
  },

  findChildElements: function(element, expressions) {
    expressions = Selector.split(expressions.join(','));
    var results = [], h = Selector.handlers;
    for (var i = 0, l = expressions.length, selector; i < l; i++) {
      selector = new Selector(expressions[i].strip());
      h.concat(results, selector.findElements(element));
    }
    return (l > 1) ? h.unique(results) : results;
  }
});

if (Prototype.Browser.IE) {
  Object.extend(Selector.handlers, {
    // IE returns comment nodes on getElementsByTagName("*").
    // Filter them out.
    concat: function(a, b) {
      for (var i = 0, node; node = b[i]; i++)
        if (node.tagName !== "!") a.push(node);
      return a;
    },

    // IE improperly serializes _countedByPrototype in (inner|outer)HTML.
    unmark: function(nodes) {
      for (var i = 0, node; node = nodes[i]; i++)
        node.removeAttribute('_countedByPrototype');
      return nodes;
    }
  });
}

function $$() {
  return Selector.findChildElements(document, $A(arguments));
}
var Form = {
  reset: function(form) {
    $(form).reset();
    return form;
  },

  serializeElements: function(elements, options) {
    if (typeof options != 'object') options = { hash: !!options };
    else if (Object.isUndefined(options.hash)) options.hash = true;
    var key, value, submitted = false, submit = options.submit;

    var data = elements.inject({ }, function(result, element) {
      if (!element.disabled && element.name) {
        key = element.name; value = $(element).getValue();
        if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
            submit !== false && (!submit || key == submit) && (submitted = true)))) {
          if (key in result) {
            // a key is already present; construct an array of values
            if (!Object.isArray(result[key])) result[key] = [result[key]];
            result[key].push(value);
          }
          else result[key] = value;
        }
      }
      return result;
    });

    return options.hash ? data : Object.toQueryString(data);
  }
};

Form.Methods = {
  serialize: function(form, options) {
    return Form.serializeElements(Form.getElements(form), options);
  },

  getElements: function(form) {
    return $A($(form).getElementsByTagName('*')).inject([],
      function(elements, child) {
        if (Form.Element.Serializers[child.tagName.toLowerCase()])
          elements.push(Element.extend(child));
        return elements;
      }
    );
  },

  getInputs: function(form, typeName, name) {
    form = $(form);
    var inputs = form.getElementsByTagName('input');

    if (!typeName && !name) return $A(inputs).map(Element.extend);

    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
      var input = inputs[i];
      if ((typeName && input.type != typeName) || (name && input.name != name))
        continue;
      matchingInputs.push(Element.extend(input));
    }

    return matchingInputs;
  },

  disable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('disable');
    return form;
  },

  enable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('enable');
    return form;
  },

  findFirstElement: function(form) {
    var elements = $(form).getElements().findAll(function(element) {
      return 'hidden' != element.type && !element.disabled;
    });
    var firstByIndex = elements.findAll(function(element) {
      return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
    }).sortBy(function(element) { return element.tabIndex }).first();

    return firstByIndex ? firstByIndex : elements.find(function(element) {
      return ['input', 'select', 'textarea'].include(element.tagName.toLowerCase());
    });
  },

  focusFirstElement: function(form) {
    form = $(form);
    form.findFirstElement().activate();
    return form;
  },

  request: function(form, options) {
    form = $(form), options = Object.clone(options || { });

    var params = options.parameters, action = form.readAttribute('action') || '';
    if (action.blank()) action = window.location.href;
    options.parameters = form.serialize(true);

    if (params) {
      if (Object.isString(params)) params = params.toQueryParams();
      Object.extend(options.parameters, params);
    }

    if (form.hasAttribute('method') && !options.method)
      options.method = form.method;

    return new Ajax.Request(action, options);
  }
};

/*--------------------------------------------------------------------------*/

Form.Element = {
  focus: function(element) {
    $(element).focus();
    return element;
  },

  select: function(element) {
    $(element).select();
    return element;
  }
};

Form.Element.Methods = {
  serialize: function(element) {
    element = $(element);
    if (!element.disabled && element.name) {
      var value = element.getValue();
      if (value != undefined) {
        var pair = { };
        pair[element.name] = value;
        return Object.toQueryString(pair);
      }
    }
    return '';
  },

  getValue: function(element) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    return Form.Element.Serializers[method](element);
  },

  setValue: function(element, value) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    Form.Element.Serializers[method](element, value);
    return element;
  },

  clear: function(element) {
    $(element).value = '';
    return element;
  },

  present: function(element) {
    return $(element).value != '';
  },

  activate: function(element) {
    element = $(element);
    try {
      element.focus();
      if (element.select && (element.tagName.toLowerCase() != 'input' ||
          !['button', 'reset', 'submit'].include(element.type)))
        element.select();
    } catch (e) { }
    return element;
  },

  disable: function(element) {
    element = $(element);
    element.disabled = true;
    return element;
  },

  enable: function(element) {
    element = $(element);
    element.disabled = false;
    return element;
  }
};

/*--------------------------------------------------------------------------*/

var Field = Form.Element;
var $F = Form.Element.Methods.getValue;

/*--------------------------------------------------------------------------*/

Form.Element.Serializers = {
  input: function(element, value) {
    switch (element.type.toLowerCase()) {
      case 'checkbox':
      case 'radio':
        return Form.Element.Serializers.inputSelector(element, value);
      default:
        return Form.Element.Serializers.textarea(element, value);
    }
  },

  inputSelector: function(element, value) {
    if (Object.isUndefined(value)) return element.checked ? element.value : null;
    else element.checked = !!value;
  },

  textarea: function(element, value) {
    if (Object.isUndefined(value)) return element.value;
    else element.value = value;
  },

  select: function(element, value) {
    if (Object.isUndefined(value))
      return this[element.type == 'select-one' ?
        'selectOne' : 'selectMany'](element);
    else {
      var opt, currentValue, single = !Object.isArray(value);
      for (var i = 0, length = element.length; i < length; i++) {
        opt = element.options[i];
        currentValue = this.optionValue(opt);
        if (single) {
          if (currentValue == value) {
            opt.selected = true;
            return;
          }
        }
        else opt.selected = value.include(currentValue);
      }
    }
  },

  selectOne: function(element) {
    var index = element.selectedIndex;
    return index >= 0 ? this.optionValue(element.options[index]) : null;
  },

  selectMany: function(element) {
    var values, length = element.length;
    if (!length) return null;

    for (var i = 0, values = []; i < length; i++) {
      var opt = element.options[i];
      if (opt.selected) values.push(this.optionValue(opt));
    }
    return values;
  },

  optionValue: function(opt) {
    // extend element because hasAttribute may not be native
    return Element.extend(opt).hasAttribute('value') ? opt.value : opt.text;
  }
};

/*--------------------------------------------------------------------------*/

Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
  initialize: function($super, element, frequency, callback) {
    $super(callback, frequency);
    this.element   = $(element);
    this.lastValue = this.getValue();
  },

  execute: function() {
    var value = this.getValue();
    if (Object.isString(this.lastValue) && Object.isString(value) ?
        this.lastValue != value : String(this.lastValue) != String(value)) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  }
});

Form.Element.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});

/*--------------------------------------------------------------------------*/

Abstract.EventObserver = Class.create({
  initialize: function(element, callback) {
    this.element  = $(element);
    this.callback = callback;

    this.lastValue = this.getValue();
    if (this.element.tagName.toLowerCase() == 'form')
      this.registerFormCallbacks();
    else
      this.registerCallback(this.element);
  },

  onElementEvent: function() {
    var value = this.getValue();
    if (this.lastValue != value) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  },

  registerFormCallbacks: function() {
    Form.getElements(this.element).each(this.registerCallback, this);
  },

  registerCallback: function(element) {
    if (element.type) {
      switch (element.type.toLowerCase()) {
        case 'checkbox':
        case 'radio':
          Event.observe(element, 'click', this.onElementEvent.bind(this));
          break;
        default:
          Event.observe(element, 'change', this.onElementEvent.bind(this));
          break;
      }
    }
  }
});

Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});
if (!window.Event) var Event = { };

Object.extend(Event, {
  KEY_BACKSPACE: 8,
  KEY_TAB:       9,
  KEY_RETURN:   13,
  KEY_ESC:      27,
  KEY_LEFT:     37,
  KEY_UP:       38,
  KEY_RIGHT:    39,
  KEY_DOWN:     40,
  KEY_DELETE:   46,
  KEY_HOME:     36,
  KEY_END:      35,
  KEY_PAGEUP:   33,
  KEY_PAGEDOWN: 34,
  KEY_INSERT:   45,

  cache: { },

  relatedTarget: function(event) {
    var element;
    switch(event.type) {
      case 'mouseover': element = event.fromElement; break;
      case 'mouseout':  element = event.toElement;   break;
      default: return null;
    }
    return Element.extend(element);
  }
});

Event.Methods = (function() {
  var isButton;

  if (Prototype.Browser.IE) {
    var buttonMap = { 0: 1, 1: 4, 2: 2 };
    isButton = function(event, code) {
      return event.button == buttonMap[code];
    };

  } else if (Prototype.Browser.WebKit) {
    isButton = function(event, code) {
      switch (code) {
        case 0: return event.which == 1 && !event.metaKey;
        case 1: return event.which == 1 && event.metaKey;
        default: return false;
      }
    };

  } else {
    isButton = function(event, code) {
      return event.which ? (event.which === code + 1) : (event.button === code);
    };
  }

  return {
    isLeftClick:   function(event) { return isButton(event, 0) },
    isMiddleClick: function(event) { return isButton(event, 1) },
    isRightClick:  function(event) { return isButton(event, 2) },

    element: function(event) {
      event = Event.extend(event);

      var node          = event.target,
          type          = event.type,
          currentTarget = event.currentTarget;

      if (currentTarget && currentTarget.tagName) {
        // Firefox screws up the "click" event when moving between radio buttons
        // via arrow keys. It also screws up the "load" and "error" events on images,
        // reporting the document as the target instead of the original image.
        if (type === 'load' || type === 'error' ||
          (type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
            && currentTarget.type === 'radio'))
              node = currentTarget;
      }
      if (node.nodeType == Node.TEXT_NODE) node = node.parentNode;
      return Element.extend(node);
    },

    findElement: function(event, expression) {
      var element = Event.element(event);
      if (!expression) return element;
      var elements = [element].concat(element.ancestors());
      return Selector.findElement(elements, expression, 0);
    },

    pointer: function(event) {
      var docElement = document.documentElement,
      body = document.body || { scrollLeft: 0, scrollTop: 0 };
      return {
        x: event.pageX || (event.clientX +
          (docElement.scrollLeft || body.scrollLeft) -
          (docElement.clientLeft || 0)),
        y: event.pageY || (event.clientY +
          (docElement.scrollTop || body.scrollTop) -
          (docElement.clientTop || 0))
      };
    },

    pointerX: function(event) { return Event.pointer(event).x },
    pointerY: function(event) { return Event.pointer(event).y },

    stop: function(event) {
      Event.extend(event);
      event.preventDefault();
      event.stopPropagation();
      event.stopped = true;
    }
  };
})();

Event.extend = (function() {
  var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
    m[name] = Event.Methods[name].methodize();
    return m;
  });

  if (Prototype.Browser.IE) {
    Object.extend(methods, {
      stopPropagation: function() { this.cancelBubble = true },
      preventDefault:  function() { this.returnValue = false },
      inspect: function() { return "[object Event]" }
    });

    return function(event) {
      if (!event) return false;
      if (event._extendedByPrototype) return event;

      event._extendedByPrototype = Prototype.emptyFunction;
      var pointer = Event.pointer(event);
      Object.extend(event, {
        target: event.srcElement,
        relatedTarget: Event.relatedTarget(event),
        pageX:  pointer.x,
        pageY:  pointer.y
      });
      return Object.extend(event, methods);
    };

  } else {
    Event.prototype = Event.prototype || document.createEvent("HTMLEvents")['__proto__'];
    Object.extend(Event.prototype, methods);
    return Prototype.K;
  }
})();

Object.extend(Event, (function() {
  var cache = Event.cache;

  function getEventID(element) {
    if (element._prototypeEventID) return element._prototypeEventID[0];
    arguments.callee.id = arguments.callee.id || 1;
    return element._prototypeEventID = [++arguments.callee.id];
  }

  function getDOMEventName(eventName) {
    if (eventName && eventName.include(':')) return "dataavailable";
    return eventName;
  }

  function getCacheForID(id) {
    return cache[id] = cache[id] || { };
  }

  function getWrappersForEventName(id, eventName) {
    var c = getCacheForID(id);
    return c[eventName] = c[eventName] || [];
  }

  function createWrapper(element, eventName, handler) {
    var id = getEventID(element);
    var c = getWrappersForEventName(id, eventName);
    if (c.pluck("handler").include(handler)) return false;

    var wrapper = function(event) {
      if (!Event || !Event.extend ||
        (event.eventName && event.eventName != eventName))
          return false;

      Event.extend(event);
      handler.call(element, event);
    };

    wrapper.handler = handler;
    c.push(wrapper);
    return wrapper;
  }

  function findWrapper(id, eventName, handler) {
    var c = getWrappersForEventName(id, eventName);
    return c.find(function(wrapper) { return wrapper.handler == handler });
  }

  function destroyWrapper(id, eventName, handler) {
    var c = getCacheForID(id);
    if (!c[eventName]) return false;
    c[eventName] = c[eventName].without(findWrapper(id, eventName, handler));
  }

  function destroyCache() {
    for (var id in cache)
      for (var eventName in cache[id])
        cache[id][eventName] = null;
  }


  // Internet Explorer needs to remove event handlers on page unload
  // in order to avoid memory leaks.
  if (window.attachEvent) {
    window.attachEvent("onunload", destroyCache);
  }

  // Safari has a dummy event handler on page unload so that it won't
  // use its bfcache. Safari <= 3.1 has an issue with restoring the "document"
  // object when page is returned to via the back button using its bfcache.
  if (Prototype.Browser.WebKit) {
    window.addEventListener('unload', Prototype.emptyFunction, false);
  }

  return {
    observe: function(element, eventName, handler) {
      element = $(element);
      var name = getDOMEventName(eventName);

      var wrapper = createWrapper(element, eventName, handler);
      if (!wrapper) return element;

      if (element.addEventListener) {
        element.addEventListener(name, wrapper, false);
      } else {
        element.attachEvent("on" + name, wrapper);
      }

      return element;
    },

    stopObserving: function(element, eventName, handler) {
      element = $(element);
      var id = getEventID(element), name = getDOMEventName(eventName);

      if (!handler && eventName) {
        getWrappersForEventName(id, eventName).each(function(wrapper) {
          element.stopObserving(eventName, wrapper.handler);
        });
        return element;

      } else if (!eventName) {
        Object.keys(getCacheForID(id)).each(function(eventName) {
          element.stopObserving(eventName);
        });
        return element;
      }

      var wrapper = findWrapper(id, eventName, handler);
      if (!wrapper) return element;

      if (element.removeEventListener) {
        element.removeEventListener(name, wrapper, false);
      } else {
        element.detachEvent("on" + name, wrapper);
      }

      destroyWrapper(id, eventName, handler);

      return element;
    },

    fire: function(element, eventName, memo) {
      element = $(element);
      if (element == document && document.createEvent && !element.dispatchEvent)
        element = document.documentElement;

      var event;
      if (document.createEvent) {
        event = document.createEvent("HTMLEvents");
        event.initEvent("dataavailable", true, true);
      } else {
        event = document.createEventObject();
        event.eventType = "ondataavailable";
      }

      event.eventName = eventName;
      event.memo = memo || { };

      if (document.createEvent) {
        element.dispatchEvent(event);
      } else {
        element.fireEvent(event.eventType, event);
      }

      return Event.extend(event);
    }
  };
})());

Object.extend(Event, Event.Methods);

Element.addMethods({
  fire:          Event.fire,
  observe:       Event.observe,
  stopObserving: Event.stopObserving
});

Object.extend(document, {
  fire:          Element.Methods.fire.methodize(),
  observe:       Element.Methods.observe.methodize(),
  stopObserving: Element.Methods.stopObserving.methodize(),
  loaded:        false
});

(function() {
  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards and John Resig. */

  var timer;

  function fireContentLoadedEvent() {
    if (document.loaded) return;
    if (timer) window.clearInterval(timer);
    document.fire("dom:loaded");
    document.loaded = true;
  }

  if (document.addEventListener) {
    if (Prototype.Browser.WebKit) {
      timer = window.setInterval(function() {
        if (/loaded|complete/.test(document.readyState))
          fireContentLoadedEvent();
      }, 0);

      Event.observe(window, "load", fireContentLoadedEvent);

    } else {
      document.addEventListener("DOMContentLoaded",
        fireContentLoadedEvent, false);
    }

  } else {
    document.write("<script id=__onDOMContentLoaded defer src=//:><\/script>");
    $("__onDOMContentLoaded").onreadystatechange = function() {
      if (this.readyState == "complete") {
        this.onreadystatechange = null;
        fireContentLoadedEvent();
      }
    };
  }
})();
/*------------------------------- DEPRECATED -------------------------------*/

Hash.toQueryString = Object.toQueryString;

var Toggle = { display: Element.toggle };

Element.Methods.childOf = Element.Methods.descendantOf;

var Insertion = {
  Before: function(element, content) {
    return Element.insert(element, {before:content});
  },

  Top: function(element, content) {
    return Element.insert(element, {top:content});
  },

  Bottom: function(element, content) {
    return Element.insert(element, {bottom:content});
  },

  After: function(element, content) {
    return Element.insert(element, {after:content});
  }
};

var $continue = new Error('"throw $continue" is deprecated, use "return" instead');

// This should be moved to script.aculo.us; notice the deprecated methods
// further below, that map to the newer Element methods.
var Position = {
  // set to true if needed, warning: firefox performance problems
  // NOT neeeded for page scrolling, only if draggable contained in
  // scrollable elements
  includeScrollOffsets: false,

  // must be called before calling withinIncludingScrolloffset, every time the
  // page is scrolled
  prepare: function() {
    this.deltaX =  window.pageXOffset
                || document.documentElement.scrollLeft
                || document.body.scrollLeft
                || 0;
    this.deltaY =  window.pageYOffset
                || document.documentElement.scrollTop
                || document.body.scrollTop
                || 0;
  },

  // caches x/y coordinate pair to use with overlap
  within: function(element, x, y) {
    if (this.includeScrollOffsets)
      return this.withinIncludingScrolloffsets(element, x, y);
    this.xcomp = x;
    this.ycomp = y;
    this.offset = Element.cumulativeOffset(element);

    return (y >= this.offset[1] &&
            y <  this.offset[1] + element.offsetHeight &&
            x >= this.offset[0] &&
            x <  this.offset[0] + element.offsetWidth);
  },

  withinIncludingScrolloffsets: function(element, x, y) {
    var offsetcache = Element.cumulativeScrollOffset(element);

    this.xcomp = x + offsetcache[0] - this.deltaX;
    this.ycomp = y + offsetcache[1] - this.deltaY;
    this.offset = Element.cumulativeOffset(element);

    return (this.ycomp >= this.offset[1] &&
            this.ycomp <  this.offset[1] + element.offsetHeight &&
            this.xcomp >= this.offset[0] &&
            this.xcomp <  this.offset[0] + element.offsetWidth);
  },

  // within must be called directly before
  overlap: function(mode, element) {
    if (!mode) return 0;
    if (mode == 'vertical')
      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
        element.offsetHeight;
    if (mode == 'horizontal')
      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
        element.offsetWidth;
  },

  // Deprecation layer -- use newer Element methods now (1.5.2).

  cumulativeOffset: Element.Methods.cumulativeOffset,

  positionedOffset: Element.Methods.positionedOffset,

  absolutize: function(element) {
    Position.prepare();
    return Element.absolutize(element);
  },

  relativize: function(element) {
    Position.prepare();
    return Element.relativize(element);
  },

  realOffset: Element.Methods.cumulativeScrollOffset,

  offsetParent: Element.Methods.getOffsetParent,

  page: Element.Methods.viewportOffset,

  clone: function(source, target, options) {
    options = options || { };
    return Element.clonePosition(target, source, options);
  }
};

/*--------------------------------------------------------------------------*/

if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
  function iter(name) {
    return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
  }

  instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
  function(element, className) {
    className = className.toString().strip();
    var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
    return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
  } : function(element, className) {
    className = className.toString().strip();
    var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
    if (!classNames && !className) return elements;

    var nodes = $(element).getElementsByTagName('*');
    className = ' ' + className + ' ';

    for (var i = 0, child, cn; child = nodes[i]; i++) {
      if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
          (classNames && classNames.all(function(name) {
            return !name.toString().blank() && cn.include(' ' + name + ' ');
          }))))
        elements.push(Element.extend(child));
    }
    return elements;
  };

  return function(className, parentElement) {
    return $(parentElement || document.body).getElementsByClassName(className);
  };
}(Element.Methods);

/*--------------------------------------------------------------------------*/

Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
  initialize: function(element) {
    this.element = $(element);
  },

  _each: function(iterator) {
    this.element.className.split(/\s+/).select(function(name) {
      return name.length > 0;
    })._each(iterator);
  },

  set: function(className) {
    this.element.className = className;
  },

  add: function(classNameToAdd) {
    if (this.include(classNameToAdd)) return;
    this.set($A(this).concat(classNameToAdd).join(' '));
  },

  remove: function(classNameToRemove) {
    if (!this.include(classNameToRemove)) return;
    this.set($A(this).without(classNameToRemove).join(' '));
  },

  toString: function() {
    return $A(this).join(' ');
  }
};

Object.extend(Element.ClassNames.prototype, Enumerable);

/*--------------------------------------------------------------------------*/

Element.addMethods();

/* Writing crunched file pp_top_static.js */

// minified CVS tag version

var popup_lottery_window=null;
var popup_login_window=null;

function go_register(b_channel){
	if(self.opener == null){
		var base_window = self;
	}else{
		var base_window = self.opener;
	}

	var area;

	if (typeof(bus_channel) == 'undefined') {
		var bus_channel = '';
	}

	if (b_channel != null && b_channel !=  '') {
			bus_channel = b_channel;
	} else {
			area = "SB";
	}

	base_window.open(tld_secure+"?action=go_register_popup&bus_channel=" + bus_channel , "pp_registration" , "width=642, height=620, scrollbars=no,  menubar=no, status=no, scrollbars=no, resizable=yes,screenX=5, screenY=5, left=5, top=5");
}

function go_register_inline(b_channel){
	var base_window = self;

	var area;

	if (typeof(bus_channel) == 'undefined') {
		var bus_channel = '';
	}

	if (b_channel != null && b_channel !=  '') {
			bus_channel = b_channel;
	} else {
			area = "SB";
	}

	base_window.top.location = 	tld_secure+"?action=go_register_inline&bus_channel=" + bus_channel;
}

function go_login () {
	document.fmLogin.submit();
}

function go_login_err () {
	document.fmLoginErr.submit();
}



function roll(sName,sAction,sPath){
	if (document.images){
		var oImg=eval("document.images['"+sName+"']");
		oImg.src=tld_gif+"/"+sPath+sName+"_"+sAction+".gif";
	}
}

function do_lottery_receipt() {
	popup_lottery_window = window.open(tld+"?action=do_lottery_receipt","popup_lottery_window","width=420,height=520");

}
function roll3(sName,sNumber,sAction,sPath) {
	if(document.images) {
		var oImg=eval("document.images['"+sName+sNumber+"']");
		oImg.src=tld_gif+"/"+sPath+sName+"_"+sAction+".gif"
	}
}

function encode_url (u) {
	var url = "" + u;
	var l = url.length;
	var i;
	var ret = "";
	var c;

	for (i = 0; i < l; i++) {
		c = url.charAt(i);
		if (c == '&') {
			ret = ret + '~';
		} else {
			if (c == ':') {
				ret = ret + '^';
			} else {
				ret = ret + c;
			}
		}
	}
	return ret;
}

function readCookie(name) {
	var nameEQ = name + "=";
	var ca = document.cookie.split(';');
	for(var i=0;i < ca.length;i++) {
		var c = ca[i];
		while (c.charAt(0)==' ') c = c.substring(1,c.length);
		if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
	}
	return "";
}

function get_aff_params(affId) {

	var tdaffId = readCookie("TDAFFID");
	var comjId	= readCookie("COMJ");
	var acd = readCookie("BCON");
	var btag = readCookie("BANNER_ID");
	var ef_id = readCookie("EF_ID");
	var raf_id = readCookie("RAF_ID");
	var rollerraf_id = readCookie("ROLLERRAF_ID");
	var plutusraf_id = readCookie("PLUTUSRAF_ID");

	if(comjId != '') {
		var comjIdsplit = comjId.split('|');
		var comjIdsplitaid = comjIdsplit[0].split(':');
		var comjIdsplitpid = comjIdsplit[1].split(':');
		var comjIdsplitsid = comjIdsplit[2].split(':');
		var aid = comjIdsplitaid[1];
		var pid = comjIdsplitpid[1];
		var sid = comjIdsplitsid[1];
	}

	var url = "";

	if(tdaffId) {
		url = add_aff_param( url, "tdaffid", tdaffId );
	}else if((aid && pid && sid)) {
		url = add_aff_param( url, "aid", aid );
		url = add_aff_param( url, "pid", pid );
		url = add_aff_param( url, "sid", sid );
	}

	url = add_aff_param( url, "AFF_ID", affId );
	url = add_aff_param( url, "ACD", acd );
	url = add_aff_param( url, "rollerraf_id", rollerraf_id );
	url = add_aff_param( url, "plutusraf_id", plutusraf_id );
	url = add_aff_param( url, "raf_id", raf_id );
	url = add_aff_param( url, "ef_id", ef_id );
	url = add_aff_param( url, "btag", btag );

	return url;
}



/*
*
* Function to append an aff param to an existing url
*
* @param url string, the url to append an aff param to
* @param name string, the name of the aff param
* @param value string, the value of the aff param
* @return url string, the modified url
*
* */
function add_aff_param( url, name, value ) {

	if ( name != '' && value != '' ){
		var link_char = '';
		if ( url != '' ){
			link_char = '&';
		}

		url += link_char + name + '=' + value;
	}

	return url;
}



/*
*
* Function to take a url and append the AFF_ID if available
*
* @param url string, the url to append an aff_id to
* @return void
*
* */
function append_aff_id(url) {
	var affId = readCookie("AFF_ID");
	var output_url = url;
	if(affId == 7023) { affId = ''; }
	/* If no AFF_ID, then don't append anything */
	if(affId != '') {
		var aff_params = get_aff_params(affId);
		if ( aff_params != '' ) {
			output_url = url + '/?' + aff_params;
		}
	}
	self.location.href=output_url;
}

function open_poker() {

	var url = poker_url;

	var affId = readCookie("AFF_ID");
	var aff_params = get_aff_params(affId);

	if ( aff_params != '' ) {
		url += '?' + aff_params;
	}

	self.location.href=url;
}

function open_casino() {

	var url = cas_cgi_url;

	var affId = readCookie("AFF_ID");
	if(affId == 7023)
		affId = '';

	var aff_params = get_aff_params(affId);
	if ( aff_params != '' ) {
		url += '?' + aff_params;
	}

	self.location.href=url;
}

function open_live_casino() {

	var url = live_casino_url;

	var affId = readCookie("AFF_ID");
	if(affId == 7023)
		affId = '';
	var aff_params = get_aff_params(affId);

	if ( aff_params != '' ) {
		url += '?' + aff_params;
	}

	self.location.href=url;
}

function MM_openBrWindow(theURL,winName,features) { //v2.0
	window.open(theURL,winName,features);
}

function popup(url, name, features) {
	var defaultFeatures = 'location=0,statusbar=0,menubar=0,scrollbars=0,';
	defaultFeatures += features;
	var theWindow = window.open(url, name, defaultFeatures);
	theWindow.focus();
}

// place a bet directly from the bet highlights
function bh_place_bet(bh_ev_oc_id,col,row) {

	var bh_price_type = document.getElementById('bh_price_type_' + bh_ev_oc_id).value;
	var bh_lp_num     = document.getElementById('bh_lp_num_' + bh_ev_oc_id).value;
	var bh_lp_den     = document.getElementById('bh_lp_den_' + bh_ev_oc_id).value;

	BS_set_leg('price_type', bh_price_type);
	BS_set_leg('lp_num', bh_lp_num);
	BS_set_leg('lp_den', bh_lp_den);
	BS_set_leg('selections', bh_ev_oc_id);
	BS_set_leg('bet_origin', 'HP_BH_(' + col + ',' + row + ')');

	BS_go_bet();
}

// Coupon details
var COUPON    = {};
var DATEROWS = {};
var SELNROWS = {};

// handler for messages setting up data structure that represents the page
// we have a COUPON which contains a number of DATEROWS
// within the DATEROWS are our SELNROWS, the rows of selection
function cpnmsg(msg_type) {

	if (msg_type == 'CPN') {
		_got_CPN.apply(this, arguments);
	} else if (msg_type == 'DATEROW') {
		_got_DATEROW.apply(this, arguments);
	} else if (msg_type == 'SELNSROW') {
		_got_SELNSROW.apply(this, arguments);
	} else if (msg_type == 'SELNSPRC') {
		_got_SELNSPRC.apply(this, arguments);
	} else {
		throw('Unexpected msg_type "' + msg_type + '"');
	}
}

function _got_CPN(junk, cpn_id, col_count) {

	var cpn = {
		id:  cpn_id
	};

	cpn.col_keys = [];

	for (var i = 0; i < col_count; i++) {
		cpn.col_keys[i] = i;
	}

	COUPON[cpn_id]  = cpn;

	// Mark TIME column as sorted (since it always must be) and the others as unsorted.
	cpn.sort_dirs = {};
	cpn.sort_dirs['TIME'] = 1;
	// The coupon is originally sorted by date.
	cpn.date_sort_dir = 1;
	for (var i = 0; i < col_count; i++) {
		cpn.sort_dirs[cpn.col_keys[i]] = 0;
	}

	// Array to hold the ids of date objects for this coupon
	cpn.date_rows = [];
}

function _got_DATEROW(junk, date_id, cpn_id, date_str) {

	var cpn = COUPON[cpn_id];

	var daterow = {
		id:     date_id,
		cpn_id: cpn_id,
		date_str:   date_str
	};

	DATEROWS[date_id] = daterow;

	//array to hold the ids of the selections for this date
	daterow.seln_rows = [];

	cpn.date_rows.push(date_id);
}

function _got_SELNSROW(junk, row_id, date_id, cpn_id, date_str) {

	var cpn  = COUPON[cpn_id];
	var date = DATEROWS[date_id];

	var selnsrow = {
		id:       row_id,
		date_id:  date_id,
		cpn_id:   cpn_id,
		date_str: date_str
	}

	SELNROWS[row_id] = selnsrow;
	selnsrow.srt_odds = {};

	date.seln_rows.push(row_id);
}

function _got_SELNSPRC(junk, row_id, col_key, lp_num, lp_den) {

	var selnsrow  = SELNROWS[row_id];
	selnsrow.srt_odds[col_key] = [lp_num, lp_den];
}

// assign the actual DOM onjects to the data structures we just built
function complete_cpn(cpn_id) {
	var cpn = COUPON[cpn_id];

	cpn.tbody = document.getElementById(cpn.id);

	for (var j = 0; j < cpn.date_rows.length; j++) {

		var daterow = DATEROWS[cpn.date_rows[j]];
		daterow.trdata = document.getElementById(daterow.id);

		for (var i = 0; i < daterow.seln_rows.length; i++) {
			var selns_row = SELNROWS[daterow.seln_rows[i]];
			selns_row.trdata = document.getElementById(selns_row.id);
		}
	}
}

function cpn_sort(cpn_id, sort_by) {

	var cpn = COUPON[cpn_id];

	// Figure out which direction we should sort in,
	// updating the relevant coupon sort dir fields.

	// Toggle the current sort direction for this sort key, or
	// set to ascending if not currently sorted.
	cpn.sort_dirs[sort_by] = cpn.sort_dirs[sort_by] * -1;
	if (cpn.sort_dirs[sort_by] == 0) {
		cpn.sort_dirs[sort_by] = 1;
	}
	// Mark the other sort keys as now unsorted.
	for (var i = 0; i < cpn.col_keys.length; i++) {
		var col_key = cpn.col_keys[i];
		if (col_key != sort_by) {
			cpn.sort_dirs[col_key] = 0;
		}
	}
	if (sort_by != 'TIME') {
		// If we're not sorting by time, the time col is now unsorted.
		cpn.sort_dirs['TIME'] = 0;
	}

	var sort_dir      = cpn.sort_dirs[sort_by];

	var daterow_ordered = [];

	// remove the date and seln rows
	// we grab the date rows so tht we can put them back
	// in the same order if we are not sorting by date
	for (var j = 0; j < cpn.date_rows.length; j++) {
		var daterow = DATEROWS[cpn.date_rows[j]];
		daterow_ordered.push(daterow);
		cpn.tbody.removeChild(daterow.trdata);
		for (var i = 0; i < daterow.seln_rows.length; i++) {
			var seln_row = SELNROWS[daterow.seln_rows[i]];
			cpn.tbody.removeChild(seln_row.trdata);
		}
	}

	// re order the dates if we are ordering by date
	if (sort_by == 'TIME') {
		daterow_ordered.sort(
			function(a,b) {
				return cpn_cmp_rows(sort_by,sort_dir,a,b);
			}
		);
	}

	// clear cpn.date_rows, it will now contain the new ordering
	cpn.date_rows = [];

	for (var j = 0; j < daterow_ordered.length; j++) {

		var daterow = daterow_ordered[j];
		var selnrow_ordered = [];

		// write the date row to the page
		cpn.tbody.appendChild(daterow.trdata);

		cpn.date_rows.push(daterow.id);

		// get this dates selection rows
		for (var i = 0; i < daterow.seln_rows.length; i++) {

			var seln_row = SELNROWS[daterow.seln_rows[i]];

			selnrow_ordered.push(seln_row);
		}

		// sort them
		selnrow_ordered.sort(
			function(a,b) {
				return cpn_cmp_rows(sort_by,sort_dir,a,b);
			}
		);

		// write them to the page in the new order
		for (var i = 0; i < selnrow_ordered.length; i++) {
			var seln_row = selnrow_ordered[i];
			cpn.tbody.appendChild(seln_row.trdata);
		}
	}

	// Update the sort indicators shown in the page.
	cpn_upd_sort_indicators(cpn_id)

}

// Compare coupon rows.
//
// Params:
//   sort_by       - Either TIME, or a col_key to sort by that column's odds.
//   sort_dir      - Main sort direction (1 = ascending, -1 = descending).
//   cpnrowA/B     - Coupon row objects (as found in SELNROWS).
//
// Returns:
//   A negative number if A < B, zero if A == B or a positive number if A > B.
//
function cpn_cmp_rows(sort_by, sort_dir, cpnrowA, cpnrowB) {

	// How should we compare the rows?

	if (sort_by == 'TIME') {

		if (cpnrowA.date_str < cpnrowB.date_str) {
			return -sort_dir;
		} else if (cpnrowA.date_str > cpnrowB.date_str) {
			return sort_dir;
		}

		// No differences - fall through.

	} else {

		// sort_by must be the column key whose odds we sort by.

		var oddsA = cpnrowA.srt_odds[sort_by];
		var oddsB = cpnrowB.srt_odds[sort_by];

		// Empty cells should sort after everything else,
		// regardless of the sort order.

		if (oddsA == null) {
			oddsA = sort_dir < 0 ? [1,9999] : [9999,1];
		}
		if (oddsB == null) {
			oddsB = sort_dir < 0 ? [1,9999] : [9999,1];
		}

		// Compare using classic fraction inequality:

		var d = oddsA[0] * oddsB[1] - oddsA[1] * oddsB[0];
		if (d < 0) {
			return -sort_dir;
		} else if (d > 0) {
			return sort_dir;
		}

		// No differences - fall through.

	}

	// No differences found so far - compare ids. We ignore the sort
	// direction in the hope of preserving the original ordering.

	if (cpnrowA.id < cpnrowB.id) {
		return -1;
	} else if (cpnrowA.id > cpnrowB.id) {
		return 1;
	}

	// No differences found whatsoever.
	return 0;
}

// Update the coupon sort direction indicators.
//
function cpn_upd_sort_indicators(cpn_id) {

	var cpn = COUPON[cpn_id];

	var col_keys = ['TIME'].concat(cpn.col_keys);

	for (var i = 0; i < col_keys.length; i++) {

		var col_key = col_keys[i];

		// Find the "th" element for this column.

		var col_th_id = cpn_id + '_col_' + col_key;
		var col_th = document.getElementById(col_th_id);

		if (col_th == null) {
			continue;
		}

		// Look for the ascending/descending images inside it.
		// Add them if they don't exist.

		var anchors = col_th.getElementsByTagName('a');
		var a = anchors[0];
		var imgs = a.getElementsByTagName('img');

		if (!imgs.length) {
			var img0 = document.createElement('img');
			img0.src = CPN.img_sort_asc;
			img0.alt = '(asc.)';
			img0.style.display = 'none';
			a.appendChild(img0);
			var img1 = document.createElement('img');
			img1.src = CPN.img_sort_dsc;
			img1.alt = '(desc.)';
			img1.style.display = 'none';
			a.appendChild(img1);
			imgs = [ img0, img1 ];
		}

		// Hide or show them as appropriate for this column.

		if (cpn.sort_dirs[col_key] == -1) {
			imgs[0].style.display = 'none';
			imgs[1].style.display = 'inline';
		} else if (cpn.sort_dirs[col_key] == 1) {
			imgs[0].style.display = 'inline';
			imgs[1].style.display = 'none';
		} else {
			imgs[0].style.display = 'none';
			imgs[1].style.display = 'none';
		}

	}

	return;
}



function btn_position(){
	if(window.innerWidth!=undefined){
		var posX = (window.innerWidth) - 104 ;
		var posY = (window.innerHeight) - 104 ;
		if(document.body.offsetWidth < window.innerWidth){
			posX = posX - 8;
		}
		if(document.body.offsetHeight < window.innerHeight){
			posY = posY;
		}
	}else{  //for internet explorer

		var posX = (document.documentElement.clientWidth) - 104 ; // need to add 8px if scrollbar
		var posY = (document.documentElement.clientHeight) - 104 ;
		if(document.body.offsetWidth > document.documentElement.clientWidth){
			posX = posX - 8;
		}
		if(document.body.offsetHeight > document.documentElement.clientHeight){
			posY = posY;
		}
	}

	if(navigator.userAgent.toLowerCase().indexOf('chrome') > -1){
		if(document.body.scrollWidth > window.innerWidth){
			posY = posY -8;
		}
		if(document.body.scrollHeight > window.innerHeight){
			posX = posX - 8;
		}
	}

	document.getElementById('suggestion_box').style.left='0px';
	document.getElementById('suggestion_box').style.bottom='-3px';

	if(window.innderWidth > 1024 || document.documentElement.clientWidth > 1024){
		document.getElementById('suggestion_box').style.display='block';
	}

	if(window.innderWidth < 1024 || document.documentElement.clientWidth < 1024 || document.documentElement.clientHeight < 600 || window.innerHeight < 600){
		document.getElementById('suggestion_box').style.display='none';
	}
}


/* Writing crunched file alerts.js */
/*
 * Copyright (c) 2010 Orbis Technology Ltd. All rights reserved.
 */


/*
  This file contains statically loaded javascript for the alert popups.
*/

// Previously autoCheckB2VATRPopupTimer.
function autoCheckAlertsPopupTimer () {

	// Set up the currentEventAlerts array.
	for (var i = 0; i < alertTypes.length; i++) {
		currentEventAlerts[alertTypes[i]] = "";
	}

	// Call first time to set things up.
	setAlertPopupTimer(false, '');

	var check_interval = 1000;

	document.PollingAjaxHelper.setInterval(
		"autoCheckAlertsPopupTimer",
		function() {setAlertPopupTimer(false, '');},
		check_interval
	);
}

// Set up the timer for the alert popup.
// force_next is a boolean that can force the function to reset the timeout.
// alert_type forces the type of alert being setup. An empty string indicates
// that all types should be set up. This probably only be the case on init.
function setAlertPopupTimer (force_next, alert_type) {

	var i                 = 0;
	var j                 = 0;
	var alert_elem        = "";
	var alert_types       = new Array();
	var found_alert_types = new Array();
	var popup_data        = new Array();
	var popup_ev_ids      = new Array();
	var popup_start_times = new Array();
	var timeout_times     = new Array();
	var got_data          = false;

	// Build up a local array of the alert_types we are dealing with. For now it
	// will either be all of them (as defined by the global array variable
	// alertTypes) or a single alert_type as defined by the string parameter
	// alert_type.
	if (alert_type == '') {
		alert_types = alertTypes;
	} else {
		alert_types.push(alert_type);
	}

	if (!appears_logged_in()) {
		// Delete all alert_types found in alertTypesLoginNeeded
		for (i = 0; i < alertTypesLoginNeeded.length; i++) {
			_deleteFromAlertsCookie(alertTypesLoginNeeded[i]);
			// Hide any displayed alert popups for this alert_type.
			_hideAlertPopup(alertTypesLoginNeeded[i]);
		}
	}

	// Try to get the cookie and if it does not exist or is empty abort.
	var events = '';
	try {
		events = get_cookie('ALERTS');
	} catch(err) {}

	if (events == '') {
		return
	}

	var arr = events.split('|');

	// Check if there has been a change and
	// if we have not just closed the pop up
	if (alertServerTime == parseInt(arr[0]) && !force_next) {

		// Check to see whether the cookie has been updated - we may need to change
		// the first alert event(s) list.
		var temp_popup_ev_ids      = new Array();
		var temp_popup_start_times = new Array();
		var temp_timeout_times     = new Array();
		var temp_alert_types       = alert_types;
		alert_types                = new Array();

		for (i = 0; i < temp_alert_types.length; i++) {

			temp_popup_ev_ids      = new Array();
			temp_popup_start_times = new Array();
			temp_timeout_times     = new Array();

			// Check that the event list for this alert_type popup hasn't changed. (i.e
			// the cookie has had a new event added that should appear in the popup
			// since the popup timeout was set).
			popup_data             = _getAlertPopupData(arr, temp_alert_types[i]);
			temp_popup_ev_ids      = popup_data[0];
			temp_popup_start_times = popup_data[1];
			temp_timeout_times     = popup_data[2];
			temp_found_alert_types = popup_data[3];

			if (temp_popup_ev_ids[temp_alert_types[i]] != currentEventAlerts[temp_alert_types[i]]) {
				force_next = true;
				got_data   = true;
				alert_types.push(temp_alert_types[i]);

				// Did we get any data for this alert_type?
				if (temp_found_alert_types.length > 0) {
					found_alert_types.push(temp_alert_types[i]);
				}

				popup_ev_ids[temp_alert_types[i]]      = temp_popup_ev_ids[temp_alert_types[i]];
				popup_start_times[temp_alert_types[i]] = temp_popup_start_times[temp_alert_types[i]];
				timeout_times[temp_alert_types[i]]     = temp_timeout_times[temp_alert_types[i]]
			}
		}

		if (!force_next) {
			return;
		}
	}

	if (parseInt(arr[0]) > alertServerTime) {
		alertServerTime = parseInt(arr[0]);
	} else if (parseInt(arr[0]) < alertServerTime) {
		arr[0] = alertServerTime;
		set_cookie('ALERTS',arr.join('|'),'','/');
	} else {
		// Must be force_next = true. Just carry on.
	}

	// If an alert_type already has an active popup, we ignore it here, as the
	// next timeout will be set when the popup is closed.
	var existing_alert_popup_arr = _getAlertTypesWithActivePopups();

	for (i = 0; i < existing_alert_popup_arr.length; i++) {

		for (j = 0; j < alert_types.length; j++) {
			// Remove alert_types that exist in existing_alert_popup_arr from alert_types.
			if (alert_types[j] == existing_alert_popup_arr[i]) {
				alert_types.splice(j, 1);
			}
		}
	}

	// Check that there is still something to do; return if not.
	if (alert_types.length == 0) {
		return;
	}

	// Clear the timeouts of the alert_types we are setting new timeouts for.
	_clearAlertTimeouts(alert_types);

	// alert_type specific operations.
	for (i = 0; i < alert_types.length; i++) {

		switch(alert_types[i]) {
			case "C":
				// Check the deactivation period. Any events that fall into this period
				// should not have alert popups. Mark them as viewed.
				var curr_time           = parseInt(new Date().getTime()/1000);
				var deactivation_period = parseInt(arr[1]) - curr_time;

				if (deactivation_period > 0) {
					// There is still a deactivation period in place. Scrap any events that
					// fall into this period and re-run the function.
					//
					// The activation_time is a modification of the server time based on
					// the current value of alertServerTime plus the difference between the
					// current local time and stored value of alertLocalTime plus the
					// remaining deactivation_period.
					var activation_time = alertServerTime + (curr_time - alertLocalTime) + deactivation_period;
					var scrapped_events = _scrapEventsBeforeActivationTime(activation_time, alert_types[i]);

					if (scrapped_events) {
						setAlertPopupTimer(force_next, alert_type);
						return;
					}
				}

				break
			default:
				// Do nothing.
		}
	}

	// Generate the alert popup event data and set a timeout to add it to the ajax
	// queue.
	if (!got_data) {
		popup_data        = _getAlertPopupData(arr, alert_types);
		popup_ev_ids      = popup_data[0];
		popup_start_times = popup_data[1];
		timeout_times     = popup_data[2];
		found_alert_types = popup_data[3];
	}

	// Set the timeouts. Pass through the ev_id(s), alert popup time and alert_type.
	for (i = 0; i < found_alert_types.length; i++) {

		// We must do this to prevent the loop overwriting timeout variables.
		var timeout_func = function (timeout_ev_ids, timeout_alert_type) {
			return function(){ _queueAlertPopup(timeout_ev_ids, timeout_alert_type);}
		} (popup_ev_ids[found_alert_types[i]], found_alert_types[i]);

		var timeout_time = parseInt(timeout_times[found_alert_types[i]]) * 1000;

		alertTimer[alert_type] = setTimeout(timeout_func, timeout_time);

		// Store the ev_id(s) against the alert_type in currentEventAlerts.
		currentEventAlerts[found_alert_types[i]] = popup_ev_ids[found_alert_types[i]];
	}

	return;
}

// Adds or removes an event from the ALERTS cookie.
function addRemoveEventAlert (ev_id, start_time, alert_type, upd_action) {

	var success = true;

	switch(upd_action) {
		case "add":

			_addEventAlert(ev_id, start_time, alert_type);

			break;
		case "remove":

			_removeEventAlert(ev_id, alert_type);

			break;
		default:
			// Unknown upd_action.
	}

	return;
}

// Adds an event to the ALERTS cookie. It is expected that checkForEventInAlertCookie
// is called prior to this to prevent duplicates.
function _addEventAlert(ev_id, start_time, alert_type) {

	// This event doesn't already exist in the cookie for this alert_type.
	// OK to add.
	var c_value = get_cookie('ALERTS');

	var arr = c_value.split('|');

	// Ensure the cookie hasn't been deleted somehow. Re-initialise if so.
	if (arr.length == 0) {
		arr[0] = 0;
		arr[1] = 0;
	}

	// Add the event tuple in the correct position in the array.
	// (We do not care about the fact that #s will potentially affect the ordering).
	//
	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	var i     = 4;
	var added = false;

	// Find the events.
	for (i = 4; i < arr.length; i = i + 3) {
		if (parseInt(arr[i-1]) > parseInt(start_time)) {
			// Add the new event before the current found event.
			arr.splice(i-2, 0, ev_id, start_time, alert_type);
			added = true;
			break;
		}
	}

	// If we haven't added it yet, it belongs at the end of the cookie.
	if (!added) {
		arr.push(ev_id, start_time, alert_type);
	}

	set_cookie('ALERTS',arr.join('|'),'','/');

	return;
}

// Removes an event from the ALERTS cookie.
function _removeEventAlert(ev_id, alert_type) {

	var c_value = get_cookie('ALERTS');

	var arr = c_value.split('|');

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	var i       = 4;
	var removed = false;

	// Find the events.
	for (i = 4; i < arr.length; i = i + 3) {
		if (arr[i] == alert_type && arr[i-2] == ev_id) {
			// Remove the tuple.
			arr.splice(i-2, 3);
			removed = true;
			break;
		}
	}

	if (removed) {
		set_cookie('ALERTS',arr.join('|'),'','/');

		// We must regenerate the timeouts for this alert_type.
		setAlertPopupTimer(true, alert_type);
	}

	return;
}

// Returns a boolean indicating whether or not an event has been added to the
// ALERTS cookie for a given alert_type.
function checkForEventInAlertCookie (ev_id, alert_type) {

	var event_exists = false;

	var c_value = get_cookie('ALERTS');

	var arr = c_value.split('|');

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	var i = 4;

	// Find the events.
	for (i = 4; i < arr.length; i = i + 3) {
		if (arr[i] == alert_type && arr[i-2] == ev_id) {
			event_exists = true;
			break;
		}
	}

	return event_exists;
}

// Queue of alert popups. This prevents simultaneous ajax calls and time variable
// changes.
function _queueAlertPopup(ev_id_list, alert_type) {

	var alert_data = new Array();

	// Create an array object containing the alert information.
	alert_data.push(ev_id_list, alert_type);

	// Add the alert information to the queue.
	alertsQueue.push(alert_data);

	// If the queue isn't already being processed, we must tell it to start.
	if (alertsQueue.length < 2) {
		_queueAlertPopupPoll();
	}
}

function _queueAlertPopupPoll() {

	if (alertsQueue.length > 0) {

		if (alertsQueueProcessing == 0) {

			alertsQueueProcessing = 1;

			// Get the first item in the queue.
			var alert_data      = alertsQueue[0];
			var ev_id_list      = alert_data[0];
			var alert_type      = alert_data[1];

			// Process the alert popup.
			_openAlertPopup(ev_id_list, alert_type);

			// Remove the item. Do this as late as possible.
			alertsQueue.shift();

			// Continue polling.
			alertsQueueProcessing = 0;
			_queueAlertPopupPoll();
		} else {
			// Wait a bit before trying again so that the browser doesn't collapse.
			setTimeout(_queueAlertPopupPoll, 100);
		}
	}
}

// AJAX call to the server which retrieves the popup
function _openAlertPopup(ev_id_list, alert_type) {

	var clientdata = {
		id      : 'alert_popup_' + alert_type,
		retries : 3
	};

	var url = "";

	if (document.location.protocol == 'http:') {
		url = alertTypeCGIUrls[alert_type];
	} else {
		url = alertTypeSCGIUrls[alert_type];
	}

	url = url + '?action=goAlertPopup&ev_id_list=' + ev_id_list + '&alert_type=' + alert_type;

	_getAlertMakeAjaxRequest(url, clientdata, _getAlertGotAjaxContent);
}

// Wrapper to call different closing popups properly
function doAlertButtonAction(button, alert_type, ev_id_list, id) {
	switch (button) {
		case "Close" :
			closeAlertPopup('Never',alert_type,ev_id_list);
			break;
		case "Never" :
			closeAlertPopup('Never',alert_type,ev_id_list);
			break;
		case "ghShow" :
			closeAlertPopup('Show',alert_type,ev_id_list);
			open_etote_window();
			break;
		case "atrShow":
		case "rpShow" :
			closeAlertPopup('Show',alert_type,ev_id_list);
			open_rp_window(id);
			break;
		case "OK" :
			closeAlertPopup('Show',alert_type,ev_id_list);
			break;
	}
}

// If "never" is true, clear the cookie and set preference to the new value
// Otherwise it deletes the specified event tuple.
function closeAlertPopup (choice, alert_type, ev_id_list) {

	// ev_ids should be a string of pipe separated ev_ids. Put them into an array.
	var ev_id_arr = ev_id_list.split('|');

	// Clear the store of the previous event alert for this alert_type.
	currentEventAlerts[alert_type] = "";

	// Hide the popup
	var alert_elem = document.getElementById('alert_popup_' + alert_type);

	if (alert_elem) {
		alert_elem.style.display='none';
		repositionEPL();
	}

	// Update the preference - this will only apply to alert types that require a
	// customer to be logged in. Currently this is only "B".
	switch(alert_type) {
		case "B":
			set_pref('B2V_ALERT_POPUP', ((choice == "Keephidden")?"Show":choice));
			break;
		default:
			// Do nothing.
	}

	var mark_viewed = true;

	switch(choice) {
		case "Never":
			// Clear the cookie of all alerts of type alert_type.
			_deleteFromAlertsCookie(alert_type);
			mark_viewed = false;
			break;
		case "Deactivate":
			// Set the deactivation period.
			setAlertDeactivationPeriod();
			break;
		case "Keephidden":
			document.getElementById("start-evt-info").style.display = "none";
		case "Show":
			// Do nothing.
			break;
		default:
			// Do nothing.
	}

	if (mark_viewed) {
		_markEventAsViewed(alert_type, ev_id_arr);
	}

	// Update current server time. This relies on the user's system clock
	// which is very likely to be reliable. The clock is updated as follows:
	// current server time = old server time + difference between alertLocalTime
	// and the current local time.
	var curr_time         = parseInt(new Date().getTime()/1000);
	var local_time_change = curr_time - alertLocalTime;
	// Update the server time.
	alertServerTime       = alertServerTime + local_time_change;
	// Update the local time.
	alertLocalTime        = curr_time;

	if (mark_viewed) {
		// Set up the timer for the next event (unless we never wish to show this
		// event_type again.
		setAlertPopupTimer (true, alert_type);
	}
}

// Sets the deactivation period in the ALERTS cookie based on the current time
// and the config item ALERT_DEACTIVATION_TIME_OPTION.
function setAlertDeactivationPeriod () {

	var current_local_time = parseInt(new Date().getTime()/1000);
	var reactivation_time  = current_local_time + parseInt(alert_deactivation_time_option);

	var c_value = get_cookie('ALERTS');
	var arr     = c_value.split('|');

	// Update the reactivation_time in the cookie (index = 1).
	arr[1] = reactivation_time;

	set_cookie('ALERTS',arr.join('|'),'','/');
}

// Clear all instances of the specified alert_type from the ALERTS cookie.
function _deleteFromAlertsCookie (alert_type) {

	var c_value = get_cookie('ALERTS');

	if (c_value == '') {
		return;
	}

	var arr     = c_value.split('|');
	var new_arr = new Array();

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	//
	// Add the first two items to the new cookie.
	new_arr.push(arr[0]);
	new_arr.push(arr[1]);

	// Start the loop at the first event's alert_type (index 4).
	for (var i = 4; i < arr.length; i = i + 3) {
		if (arr[i] != alert_type) {
			// ev_id
			new_arr.push(arr[i-2]);
			// start_time
			new_arr.push(arr[i-1]);
			// alert_type
			new_arr.push(arr[i]);
		}
	}

	// Set the new cookie (which now contains no values of the specified alert_type.
	set_cookie('ALERTS',new_arr.join('|'),'','/');
}

function _clearAlertTimeouts (alert_type_arr) {

	for (var i = 0; i < alert_type_arr.length; i++) {
		if (alertTimer[alert_type_arr[i]] && alertTimer[alert_type_arr[i]] != '') {
			clearTimeout(alertTimer[alert_type_arr[i]]);
		}
	}
}

function _hideAlertPopup (alert_type) {

	var alert_elem = document.getElementById('alert_popup_' + alert_type);

	// If it exists, hide it.
	if (alert_elem) {
		alert_elem.style.display = 'none';
	}
}

function _hideAllAlertPopups () {

	var alert_elem = "";

	for (var i = 0; i < alertTypes.length; i++) {
		_hideAlertPopup(alertTypes[i]);
	}
}

// Returns an array containing the alert_types that have active popups.
function _getAlertTypesWithActivePopups () {

	var existing_alert_popup_arr = new Array();

	for (var i = 0; i < alertTypes.length; i++) {
		var alert_elem = document.getElementById('alert_popup_' + alertTypes[i]);

		if (alert_elem && alert_elem.style.display != 'none') {
			existing_alert_popup_arr.push(alertTypes[i]);
		}
	}

	return existing_alert_popup_arr;
}

// Returns the preview time for a given alert_type. Defaults to 0.
function _getAlertPreviewTime (alert_type) {

	var alert_preview_time = 0;

	if (alertTypePreviewTime[alert_type]) {
		alert_preview_time = alertTypePreviewTime[alert_type];
	}

	return alert_preview_time;
}

// Indicates that an alert popup has been displayed already.
function _markEventAsViewed (alert_type, ev_id_arr) {

	var updated = false;

	var c_value = get_cookie('ALERTS');

	var arr = c_value.split('|');

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	var i = 4;
	var j = 0;

	// Find the events. Ensure they have not already been marked as viewed/ignored.
	for (i = 4; i < arr.length; i = i + 3) {
		if (arr[i] == alert_type && arr[i-1].indexOf('#') < 0) {
			for (j = 0; j < ev_id_arr.length; j++) {
				if (arr[i-2] == ev_id_arr[j]) {
					// Prepend a hash to the start_time.
					arr[i-1] = '#' + arr[i-1];
					updated = true;
				}
			}
		}
	}

	// Update the cookie if necessary.
	if (updated) {
		set_cookie('ALERTS',arr.join('|'),'','/');
	}
}

// Works out what values in the cookie for a specified alert_type exist before
function _scrapEventsBeforeActivationTime (activation_time, alert_type) {

	var updated = false;

	var c_value = get_cookie('ALERTS');

	var arr = c_value.split('|');

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	var i = 4;

	// Find the events. Ensure they have not already been marked as viewed/ignored.
	for (i = 4; i < arr.length; i = i + 3) {
		if (arr[i] == alert_type && arr[i-1].indexOf('#') < 0) {
			// Check the start_time against the reactivation_time. If start_time is
			// less than reactivation_time then we scrap this event and mark it as
			// viewed.
			if (parseInt(arr[i-1]) < parseInt(activation_time)) {
				arr[i-1] = '#' + arr[i-1];
				updated = true;
			}
		}
	}

	// Update the cookie if necessary.
	if (updated) {
		set_cookie('ALERTS',arr.join('|'),'','/');
	}

	return updated;
}

// Takes the cookie data array and prepares the ajax request data for the alert
// popup. Returns the ajax request lists for each alert_type requested.
function _getAlertPopupData (arr, alert_types) {

	// For each alert_type in the cookie find the first event (that hasn't been
	// set to ignore by the customer) in addition to any events that should be
	// grouped with it.
	//
	// We will keep track of which alert_types have been found in the cookie.
	//
	// Initialise some variables for the loop.
	var found_alert_types        = new Array();
	var found_alert_type_data    = new Array();
	var valid_alert_type         = false;
	var group_alerts             = false;
	var alert_type_already_found = false;
	var can_break_early          = true;
	var i                        = 0;
	var j                        = 0;

	// 0 = Server Time, 1 = Activation_time, 2 = event_1 id, 3 = event_1 start_time
	// 4 = event_1 alert_type.
	for (i = 4; i < arr.length; i = i + 3) {

		// Have we found the top instance of each required alert_type? We can only
		// break out early here if we have no groupable alert_types.
		if (can_break_early && found_alert_types.length == alert_types.length) {
			break;
		}

		// Is this event to be ignored? If so, ignore it.
		if (arr[i-1].indexOf('#') < 0) {

			// Ensure we are only handling the required alert_types.
			valid_alert_type = false;

			for (j = 0; j < alert_types.length; j++) {
				if (alert_types[j] == arr[i]) {
					valid_alert_type = true;
					break;
				}
			}

			// Do we care about this alert_type?
			if (!valid_alert_type) {
				continue;
			}

			// Do we need to group multiple events into a single alert for this alert_type?
			group_alerts = false;

			for (j = 0; j < groupable_alert_types.length; j++) {
				if (groupable_alert_types[j] == arr[i]) {
					group_alerts    = true;
					can_break_early = false;
					break;
				}
			}

			// If we are not grouping alerts, we need only the first alert for each
			// alert_type.
			alert_type_already_found = false;

			for (j = 0; j < found_alert_types.length; j++) {
				if (found_alert_types[j] == arr[i]) {
					alert_type_already_found = true;
					break;
				}
			}

			// We already have a value for this alert_type. If we are not grouping we
			// simply continue here, otherwise we check the start_time in relation to
			// the start_time of the first event of this alert_type.
			if (alert_type_already_found) {
				if (!group_alerts) {
					continue;
				} else {
					// Compare this event against the first event's start time with respect
					// to the config item ALERT_TIME_GROUPING.
					if (parseInt(found_alert_type_data[arr[i]][1]) + parseInt(alert_time_grouping) < parseInt(arr[i-1])) {
						continue;
					}
				}
			} else {
				found_alert_types.push(arr[i]);

				// Initialise the data array for this alert_type.
				found_alert_type_data[arr[i]] = new Array();
			}

			// If we get here, this event will form part of the alert. Add it to the
			// array ready to be added to the timeout call.
			//
			// Add the ev_id.
			found_alert_type_data[arr[i]].push(arr[i-2]);
			// Add the start_time.
			found_alert_type_data[arr[i]].push(parseInt(arr[i-1]));
		}
	}

	// We must now set up the timeouts.
	//
	// Initialise the time variable.
	var time                      = 0;
	var ev_id_list                = "";
	var ev_start_time_list        = "";
	var alert_type_ev_ids         = new Array();
	var alert_type_ev_start_times = new Array();
	var alert_type_timeout_time   = new Array();
	var random_additional_time    = 0;

	// Initialise alert_type_ev_ids and alert_type_ev_start_times
	for (i = 0; i < alert_types.length; i++) {
		alert_type_ev_ids[alert_types[i]]         = "";
		alert_type_ev_start_times[alert_types[i]] = "";
	}

	for (i = 0; i < found_alert_types.length; i++) {
		// Reset the time var and add on the preview time + a 5s "page load allowance"
		// for the given alert_type.
		time = alertServerTime + 5 + parseInt(_getAlertPreviewTime(found_alert_types[i]));

		// Add a random amount of time to prevent a large number of simultaneous
		// requests to the server for popular events. Random time is a value between
		// 0 and 10 seconds.
		random_additional_time = random_timeout = Math.floor(Math.random() * alertPopupTimeWindow);
		time = time + random_additional_time;

		// Find the difference between the required popup time and the server time.
		time = parseInt(found_alert_type_data[found_alert_types[i]][1]) - time;

		// If the customer leaves an old popup on the screen for a long time, some
		// following alerts may be past their start time, display these immediately.
		if (time <= 0) {
			time = 1;
		}

		// If the event starts in more than a day we do not set up a timeout.
		if (time > 86400) {
			continue;
		}

		// Reset the lists.
		ev_id_list         = "";
		ev_start_time_list = "";

		// Populate the lists.
		// j   = ev_id idx
		// j+1 = start_time idx
		for (j = 0; j < found_alert_type_data[found_alert_types[i]].length; j = j + 2) {
			if (ev_id_list == "") {
				ev_id_list = found_alert_type_data[found_alert_types[i]][j];
			} else {
				ev_id_list = ev_id_list + "|" + found_alert_type_data[found_alert_types[i]][j];
			}

			if (ev_start_time_list == "") {
				ev_start_time_list = found_alert_type_data[found_alert_types[i]][j+1];
			} else {
				ev_start_time_list = ev_start_time_list + "|" + found_alert_type_data[found_alert_types[i]][j+1];
			}
		}

		// Store the lists in the arrays.
		alert_type_ev_ids[found_alert_types[i]]         = ev_id_list;
		alert_type_ev_start_times[found_alert_types[i]] = ev_start_time_list;
		alert_type_timeout_time[found_alert_types[i]]   = time;
	}

	return [alert_type_ev_ids, alert_type_ev_start_times, alert_type_timeout_time, found_alert_types];
}

function _getAlertMakeAjaxRequest(url, clientdata, callback) {

	if (document.PollingAjaxHelper.checkSemaphore()) {
		// Attempt this again in 300ms.
		document.PollingAjaxHelper.setTimeout(
			"_getAlertMakeAjaxRequest",
			function() {_getAlertMakeAjaxRequest(url, clientdata, callback);},
			300);

		return;
	}

	document.PollingAjaxHelper.aquireSemaphore();

	var req = null;

	if (window.XMLHttpRequest) {
		req = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		req = new ActiveXObject('Microsoft.XMLHTTP');
	}

	if (req) {
		req.onreadystatechange = function() {
			if (req.readyState != 4) return;
			var reqStatus;
			try {
				reqStatus = req.status;
			} catch (e) {
				reqStatus = '';
			}
			if (reqStatus != 200) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,false,'HTTP');
			} else {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,true,req.responseText);
			}
		}
		try {
			req.open('GET', url, true);
			req.send(null);
		} catch (e) {
			document.PollingAjaxHelper.releaseSemaphore();
			callback(url,clientdata,false,'UNSUPPORTED');
		}
	} else {
		document.PollingAjaxHelper.releaseSemaphore();
		callback(url,clientdata,false,'UNSUPPORTED');
	}
}

function repositionEPL () {
	var eplAlert   = document.getElementById('alert_popup_E'),
		eplContent = eplAlert.getElementsByTagName('div')[0],
		birAlert   = document.getElementById('alert_popup_C'),
		birContent = birAlert.getElementsByTagName('div')[0],
		birAlertVisible = window.getComputedStyle(birAlert).getPropertyValue('display') != 'none';

	if (eplAlert && birAlert && birAlertVisible) {
		eplContent.style.marginBottom = birContent.clientHeight + 'px';
	} else {
		if(typeof(eplContent) != 'undefined' && eplContent != null) {
			eplContent.style.marginBottom = '0';
		}
	}
}

function positionBetAlert(holder_el){
	holder_el.style.display = 'block';
	holder_el.style.position = 'fixed';

	var wHeight = '';
	var dHeight = '';

	if (self.innerHeight) {
			wHeight = self.innerHeight;
	}else if (document.documentElement && document.documentElement.clientHeight) {
			wHeight = document.documentElement.clientHeight;
	}else if (document.body) {
			wHeight = document.body.clientHeight;
	}

	var baseHeight = document.getElementById("start-evt-info").clientHeight;

	var hCalc = (wHeight  - baseHeight) + 'px';
	holder_el.style.top = hCalc;
}


function _getAlertGotAjaxContent(url, clientdata, ok, response) {

	var holder_el = document.getElementById(clientdata.id);

	if (ok) {

		// Blank response means no new data.
		if (response == "") {
			return;
		}

		var parts = _getAlertParseScriptTags(response);

		if (holder_el) {
			holder_el.innerHTML = parts[0];
			if (clientdata.id == 'alert_popup_C') {
				positionBetAlert(holder_el);
				repositionEPL();
			} else {
				holder_el.style.display = '';
			}
		}

		if(clientdata.id == 'alert_popup_C'){
			window.onresize = function(){positionBetAlert(holder_el)};
		}

		if (parts[1].length) {
			try {
				_getAlertGlobalEval(parts[1]);
			} catch (e) {
				ok = false;
			}
		}
	}
}

function _getAlertParseScriptTags(str) {

	var html = '';
	var js   = '';
	var i = 0;
	var state = 'HTML';
	var script_re = new RegExp('<(/?)' + 'scr'+'ipt' + '([^>]*)>', 'gi');

	while ((mtch = script_re.exec(str)) != null) {

		mS = mtch.index;

		if (state == 'HTML') {
			html += str.substring(i, mS);
		} else {
			js += str.substring(i, mS) + ';\n';
		}

		var closer = mtch[1];
		var attrs  = mtch[2];

		if (closer == '/') {
			state = 'HTML';
		} else {
			if ( attrs.charAt(attrs.length - 1) != '/' &&
			     attrs.indexOf('src=') == -1 ) {
				state = 'JS';
			}
		}

		i = script_re.lastIndex;
	}

	if (state == 'HTML') {
		html += str.substring(i);
	} else {
		js += str.substring(i);
	}

	return [ html, js ];
}

var _getAlertGlobalEval = function (src) {

	if (window.execScript) {
		window.execScript(src);
		return;
	}

	var fn = function() {
		window.eval.call(window,src);
	};

	fn();
};


/* Writing crunched file scone.js */
/*
 * Sortable CONtainer Elements.
 *
 * Summary:
 *
 *   Functions for adding and removing html fragments from html elements,
 *   associating object data with elements, and optionally establishing and
 *   maintaining a sort order for elements. Particulary useful with tmpl.js.
 *
 * Justification for existence: (i.e. why not just use the DOM + innerHTML?)
 *
 *  * Capable of working around (some of) IE's innerHTML restrictions and so
 *    can be used to efficiently sort and modify rows within a table body.
 *
 *  * An item can consist of multiple elements; this is particularly useful
 *    in tables. There's no need for each element to have an id, either.
 *
 *  * Being able to associate objects with items relieves the programmer of
 *    the need to maintain separate hash tables all over the place.
 *
 *  * Has special support for nested containers; scone_cut() + scone_paste()
 *    allows the representation of an object to be re-generated without the
 *    need to re-generate all of its (potentially complex) child elements.
 *
 *  * If used with tmpl.js, allows HTML supplied by 3rd-party designers to
 *    be made dynamic with very few modifications (unlike re-writing it all
 *    as JS DOM calls!).
 *
 */

// ensure CVS revision number survives minification

/* -------- Private static variables. ------ */

var _scones            = {};
var _scone_for         = {};
var _scone_dummy_elem  = null;
var _scone_debug       = false;


/* -------- Public functions. -------- */


// Create a scone backed by an HTML element.
//
// The HTML element can be almost any element APART from:
//   TABLE : Explictly define a TBODY with an id and use that instead.
//
// Params:
//   sconeElemId = The "id" attribute of existing HTML element.
//   info        = Arbitrary information which the caller wants to associate
//                 with the scone. Retrieve with scone_get_info().
//   cmpFn       = Function when sorting to compare object representations of
//                 items. If cmpFn is null, items are always added at the end
//                 of the scone and scone_sort() has no effect.
//   cmpMode     = Passed as first argument to cmpFn. Typically used to control
//                 the type of sorting performed.
//
// Notes:
//   * Any existing contents of the HTML element given by sconeElemId will be
//     deleted.
//   * The cmpFn must have signature f(cmpMode, itemObjA, itemObjB) and return
//     -1, 0 or +1 for A < B, A == B and A > B respectively.
//
// Returns sconeElemId, or throws an error if the scone could not be created.
//
function scone_create(sconeElemId, info, cmpFn, cmpMode) {

	if (_scones[sconeElemId] != undefined) {
			throw("Scone \"" + sconeElemId + "\" already exists.");
	}

	var scone_elem = document.getElementById(sconeElemId);
	if (!scone_elem) {
			throw("Element \"" + sconeElemId + "\" not found.");
	}

	var elem_type = scone_elem.nodeName.toLowerCase();
	if (elem_type == "table") {
			throw("Element \"" + sconeElemId + "\" cannot be used since it is a " +
			       elem_type + "; use a tbody instead.");
	}

	while (scone_elem.lastChild) {
		scone_elem.removeChild(scone_elem.lastChild);
	}

	var scone = {
			info:               info,
			cmpFn:              cmpFn,
			cmpMode:            cmpMode,
			elemType:           elem_type,
			parentSconeItemId:  null,
			items:              [],
			itemIdHash:         {},
			scone_elem:         scone_elem
	};

	// Check if this scone is an item in another scone, or if it has been created
	// within an item of another scone.

	var elem = scone_elem;
	var pscone_id      = null;
	var pscone_item_id = null;
	while (elem) {
			if (elem.id) {
				if (_scone_for[elem.id] != undefined) {
					pscone_id      = _scone_for[elem.id];
					pscone_item_id = elem.id;
					break;
				}
			}
			elem = elem.parentNode;
	}
	if (pscone_item_id) {
			scone.parentSconeItemId = pscone_item_id;
			var pitem = _scones[pscone_id].itemIdHash[pscone_item_id];
			// mark our scone as a child of the parent item
			pitem.childSconeIdHash[sconeElemId] = true;
	}

	_scones[sconeElemId] = scone;
	return sconeElemId;
}


// Does a scone exist?
function scone_exists(sconeElemId) {
	return (_scones[sconeElemId] != undefined);
}


// Get the info object associated with a scone, or null if the scone
// does not exist.
function scone_get_info(sconeElemId) {
	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			return null;
	}
	return scone.info;
}


// Add a new child item to a scone.
//
// Params:
//  itemElemId = The id attribute of the "main" element for this item.
//  html       = The HTML representation of the item. Must contain an element
//               with the id given by itemElemId (doesn't matter where).
//  info       = The object to associate with the item (used for sorting).
//  noOrder    = If true, the item will be added to the end of the scone.
//               Otherwise, the item will be inserted as determined by using
//               the scone's cmpFn and cmpMode to compare the info with that
//               of the existing items.
//
// Returns itemElemId, or throws an error if the item could not be added.
//
// Notes:
//   * Text nodes (and comments) at the top level of the HTML will be
//     discarded. If you want to insert straight text, use e.g. a <span>.
//   * The top-level elements in the HTML must be suitable for insertion into
//     the element backing the scone (e.g. rows for a tbody scone).
//   * An item with the given id must not already exist in any scone.
//   * The id atrributes of elements in the html must not already exist in the
//     document (this error may not always be detected by this function).
//   * The HTML must not contain any existing scones (corrolary of previous
//     rule really).
//   * If the scone's cmpFn is null, noOrder will be ignored.
//   * In IE we cant innerhtml options so we have to use dom tree
//     create a dummy select element and add the option in that
//     options info should be retrieved by the info argument
//

function scone_add_item(sconeElemId, itemElemId, html, info, noOrder, usePerformance) {

	// Locate scone.

	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			throw("No such scone \"" + sconeElemId + "\"");
	}

	var scone_elem = null;

	if (usePerformance) {
		// get this scones reference to the element in the DOM
		var scone_elem = scone.scone_elem;
	}

	if (!scone_elem) {
			// fall back to getting it from the DOM via getElementById
			scone_elem = document.getElementById(sconeElemId);
			if (!scone_elem) {
					throw("Element \"" + sconeElemId + "\" not found.");
			}
	}

	// Duplicate check.

	if (_scone_debug) {

		if (document.getElementById(itemElemId)) {
				throw("Item with id \"" + itemElemId +
				      "\" already exists in the document.");
		}
		if (_scone_for[itemElemId] != undefined) {
				throw("Item with id \"" + itemElemId +
				      "\" already exists in \"" + _scone_for[itemElemId] + "\"");
		}
	}

	// Determine insert position.

	var idx;
	if (noOrder || scone.cmpFn == null) {
			idx = scone.items.length;
	} else {
			idx = _scone_find_ipos(scone, info);
	}

	var before_elem;
	if (idx == scone.items.length) {
			before_elem = null;
	} else {
			before_elem = _scone_first_item_elem(scone.items[idx]);
	}

	// Add HTML to a dummy element.

	if (!_scone_dummy_elem) {
			_scone_dummy_elem = document.createElement("div");
	}
	var holder_elem = null;
	var e = "unknown";
	var t = scone.elemType;
	try {
			if (t == "div") {
				_scone_dummy_elem.innerHTML = html;
				holder_elem = _scone_dummy_elem;
			} else if (t == "tbody") {
				_scone_dummy_elem.innerHTML =
				  "<table><tbody>"
				  + html + "</tbody></table>";
				holder_elem = _scone_dummy_elem.getElementsByTagName("tbody")[0];
			} else if (t == "tr") {
				_scone_dummy_elem.innerHTML =
				  "<table><tbody><tr>"
				  + html + "</tr></tbody></table>";
				holder_elem = _scone_dummy_elem.getElementsByTagName("tr")[0];
			} else if (t == "thead") {
				_scone_dummy_elem.innerHTML =
				  "<table><thead>"
				  + html + "</thead></table>";
				holder_elem = _scone_dummy_elem.getElementsByTagName("thead")[0];
			} else if (t == "select") {
				// In IE we cant innerhtml options so we have to use dom tree
				// create a dummy select element and add the option in that
				// options info should be retrieved by the info argument
				_scone_dummy_elem = document.createElement("select");
				var opt = document.createElement('option');
				opt.text     = info.opt_text;
				opt.value    = info.opt_value;
				opt.id       = itemElemId;
				_scone_dummy_elem.options.add(opt);
				holder_elem = _scone_dummy_elem;

				// Remove the temporary select element
				_scone_dummy_elem = "";
			} else {
				_scone_dummy_elem.innerHTML = html;
				holder_elem = _scone_dummy_elem;
			}
	} catch (e) {
	}
	if (!holder_elem) {
			throw("Failed to add \"" + html + "\" to \"" + sconeElemId + "\"" +
			      " due to: " + e);
	}

	// Copy elements to correct position.

	var num_elems = 0;
	var first_elem = null;
	var new_elem = holder_elem.firstChild;
	while (new_elem) {
			var next_elem = new_elem.nextSibling;
			holder_elem.removeChild(new_elem);
			if (new_elem.nodeType == 1) {
				scone_elem.insertBefore(new_elem, before_elem);
				num_elems++;
				if (!first_elem) {
					first_elem = new_elem;
				}
			}
			new_elem = next_elem;
	}

	_scone_dummy_elem.innerHTML = "";

	// Check id of main element in item now present.

	// This check is a performance enhancement to prevent unecessary calls to getElementById
	if (!usePerformance || num_elems > 1) {

		var item_elem = document.getElementById(itemElemId);
		if (!item_elem) {
				// If not, rollback addition of elements.
				var j = 0;
				if (before_elem) {
					while (before_elem.previousSibling && j < num_elems) {
						if (before_elem.previousSibling.nodeType == 1) {
							j++;
						}
						scone_elem.removeChild(before_elem.previousSibling);
					}
				} else {
					while (scone_elem.lastChild && j < num_elems) {
						if (scone_elem.lastChild.nodeType == 1) {
							j++;
						}
						scone_elem.removeChild(scone_elem.lastChild);
					}
				}
				throw("Element with id \"" + itemElemId + "\" not found in \"" +
				      html + "\", or html is invalid.");
		}

		// Determine position of first top-level element of the item relative to
		// the main element within the item (i.e. the one with the id).

		var elem = item_elem.parentNode;
		var top_elem_above = item_elem;
		var offset_up = 0;
		while (elem && elem != scone_elem) {
				top_elem_above = elem;
				elem = elem.parentNode;
				offset_up++;
		}
		var elem = first_elem;
		var offset_left = 0;
		while (elem && elem != top_elem_above) {
				if (elem.nodeType == 1) {
					offset_left++;
				}
				elem = elem.nextSibling;
		}
	} else {
		var offset_left = 0;
		var offset_up = 0;
	}


	// Store details about the item in hashes / arrays.

	var item = {
			id               : itemElemId,
			info             : info,
			offsetLeft       : offset_left,
			offsetUp         : offset_up,
			numElems         : num_elems,
			childSconeIdHash : {}
	};

	scone.items.splice(idx, 0, item);
	scone.itemIdHash[itemElemId] = item;
	_scone_for[itemElemId] = sconeElemId;

	return itemElemId;
}


// Get the ids of the items in a scone.
function scone_get_items(sconeElemId) {
	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			throw("No such scone \"" + sconeElemId + "\"");
	}
	var itemElemIds = new Array(scone.items.length);
	for (var i = 0; i < scone.items.length; i++) {
			itemElemIds[i] = scone.items[i].id;
	}
	return itemElemIds;
}


// Does an item exist in any scone?
function scone_item_exists(itemElemId) {
	return _scone_for[itemElemId] != undefined;
}


// Get the info object for a child item in a scone, or null if there
// is no such item in any scone.
function scone_get_item_info(itemElemId) {
	var sconeElemId = _scone_for[itemElemId];
	if (!sconeElemId) {
			return null;
	}
	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			return null;
	}
	if (scone.itemIdHash[itemElemId] == undefined) {
			return null;
	}
	return scone.itemIdHash[itemElemId].info;
}


// Returns the id of the scone to which a child item with the given id
// belongs, or null if the item has not been added to a scone.
function scone_get_item_owner(itemElemId) {
	return _scone_for[itemElemId] ? _scone_for[itemElemId] : null;
}


// Get array of any child scones within an item.
function scone_get_item_children(itemElemId) {

	var child_scone_ids = [];

	var sconeElemId = _scone_for[itemElemId];
	if (!sconeElemId) {
			return child_scone_ids;
	}
	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			return child_scone_ids;
	}
	var item = scone.itemIdHash[itemElemId];
	if (item == undefined) {
			return child_scone_ids;
	}

	for (var childSconeId in item.childSconeIdHash) {
		child_scone_ids.push(childSconeId);
	}

	return child_scone_ids;
}

// If the given scone has been added as a child item in another scone,
// or created in HTML within an item in another scone, return the id of
// that item, or null otherwise.
// Notes:
//   * scone_get_item_owner(scone_get_parent_item(sconeElemId)) can be used
//     to find the containing scone of a given scone.
//   * If a scone actually is an item in another scone (as opposed to being
//     within it), scone_parent_item() will return sconeElemId itself.
function scone_get_parent_item(sconeElemId) {
	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			return null;
	}
	return scone.parentSconeItemId;
}


// Remove an item from its scone.
// Returns nothing.
function scone_remove_item(itemElemId) {

	// Locate the scone.

	var sconeElemId = _scone_for[itemElemId];
	if (!sconeElemId) {
			throw("Item \"" + itemElemId + "\" has not been added to a scone.");
	}
	var scone = _scones[sconeElemId];
	if (!scone) {
			throw("Internal error: scone in _scone_for but not in _scones.");
	}
	var scone_elem = document.getElementById(sconeElemId);
	if (!scone_elem) {
			throw("Element \"" + sconeElemId + "\" not found.");
	}

	// Locate the item (slow since we need the index).

	var idx = -1;
	for (var i = 0; i < scone.items.length; i++) {
			if (scone.items[i].id == itemElemId) {
				idx = i;
				break;
			}
	}
	if (idx < 0) {
			throw("Internal error: item in _scone_for but not in scone items.");
	}
	var item = scone.items[idx];

	// Remove the HTML elements.

	var num_elems = item.numElems;
	var elem = _scone_first_item_elem(item);
	var j = 0;
	while (elem && j < num_elems) {
			var next_elem = elem.nextSibling;
			if (elem.nodeType == 1) {
				j++;
			}
			scone_elem.removeChild(elem);
			elem = next_elem;
	}

	// Remove the item entry.

	scone.items.splice(idx, 1);
	delete scone.itemIdHash[itemElemId];
	delete _scone_for[itemElemId];

	// Free child scones.

	for (var childSconeId in item.childSconeIdHash) {
		_scone_delete(childSconeId, true, true);
	}

	return;
}


// Replace an item within a scone with new html and info.
//
// If keepChildren is true, any child scones within the item will
// be preserved (provided their ids still exist in the new html).
//
// Returns nothing.
//
function scone_replace_item(itemElemId, html, info, keepChildren) {

	var sconeElemId = scone_get_item_owner(itemElemId);

	var saved_child_ids    = [];
	var saved_child_scones = [];
	if (keepChildren) {
		saved_child_ids    = scone_get_item_children(itemElemId);
		saved_child_scones = new Array(saved_child_ids.length);
		for (var i = 0; i < saved_child_ids.length; i++) {
			saved_child_scones[i] = scone_cut(saved_child_ids[i]);
		}
	}

	scone_remove_item(itemElemId);
	scone_add_item(sconeElemId, itemElemId, html, info, null, false);

	for (var i = 0; i < saved_child_ids.length; i++) {

		if (document.getElementById(saved_child_ids[i])) {

			scone_paste(saved_child_ids[i], saved_child_scones[i]);
		}
	}

	return;
}


// Change the info associated with an item and re-position it accordingly
// within the scone if needed.
function scone_set_item_info(itemElemId, new_info, info_only) {

	var sconeElemId = scone_get_item_owner(itemElemId);
	var scone = _scones[sconeElemId];
	if (!scone) {
		throw("Could not find scone for item \"" + itemElemId + "\"");
	}

	var item = scone.itemIdHash[itemElemId];
	if (!item) {
		throw("Could not find item \"" + itemElemId +
		      "\" in scone \"" + sconeElemId + "\"");
	}

	// If this score is not sorted, just store the new info and we're done.

	if (scone.cmpFn == null) {
		item.info = new_info;
		return;
	}

	// Figure out:
	//   old position
	//   new position if old entry was still there
	//   new position with old entry gone

	var old_idx;
	for (var i = 0; i < scone.items.length; i++) {
			if (scone.items[i].id == itemElemId) {
				old_idx = i;
				break;
			}
	}
	var new_idx_pre  = _scone_find_ipos(scone, new_info);
	var new_idx_post = (old_idx < new_idx_pre) ? new_idx_pre - 1 : new_idx_pre;

	// Store the new info (note that we had to wait until we'd found the
	// new position before doing this, or else our search would have been
	// confused by the old item appearing to have the new info).

	item.info = new_info;

	// Finished if no change in position.

	if ( old_idx == new_idx_post ) return;

	// Before which element must the item now be positioned?

	var before_elem;
	if (new_idx_pre == scone.items.length) {
			before_elem = null;
	} else {
			before_elem = _scone_first_item_elem(scone.items[new_idx_pre]);
	}

	var scone_elem = document.getElementById(sconeElemId);
	if (!scone_elem) {
			throw("Element \"" + sconeElemId + "\" not found.");
	}

	// Remove and re-add item elements within the DOM.

	if (info_only != true) {
		var num_elems = item.numElems;
		var elem = _scone_first_item_elem(item);
		var j = 0;
		while (elem && j < num_elems) {
				var next_elem = elem.nextSibling;
				if (elem.nodeType == 1) {
					j++;
				}
				scone_elem.removeChild(elem);
				scone_elem.insertBefore(elem, before_elem);
				elem = next_elem;
		}
	}

	// Remove and re-add the item entry.

	scone.items.splice(old_idx, 1);
	scone.items.splice(new_idx_post, 0, item);

	return;
}

// Sort the items in a scone based on the cmpFn supplied at creation.
// If the given cmpMode is null, the existing cmpMode associated with the scone
// will be used; otherwise, the given cmpMode will be used for this sort and
// associated with the scone (replacing the existing cmpMode).
//
function scone_sort(sconeElemId, cmpMode, noStoreCmpMode) {

	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			throw("No such scone \"" + sconeElemId + "\"");
	}
	var scone_elem = document.getElementById(sconeElemId);
	if (!scone_elem) {
			throw("Element \"" + sconeElemId + "\" not found.");
	}

	if (scone.cmpFn == null) {
			return;
	}

	if (!noStoreCmpMode) {
		if (cmpMode != null) {
				scone.cmpMode = cmpMode;
		} else {
				cmpMode = scone.cmpMode;
		}
	}

	// Find elements.
	var elemsById = {};
	for (var i = 0; i < scone.items.length; i++) {
			var id = scone.items[i].id;
			var elem = _scone_first_item_elem(scone.items[i]);
			var num_elems = scone.items[i].numElems;
			var elems = new Array(num_elems);
			var j = 0;
			while (elem && j < num_elems) {
				if (elem.nodeType == 1) {
					elems[j++] = elem;
				}
				elem = elem.nextSibling;
			}
			elemsById[id] = elems;
	}

	// Sort items.
	var cmpFn = scone.cmpFn;
	var f = function (a, b) {
			return cmpFn(cmpMode, a.info, b.info);
	}
	scone.items.sort(f);

	// Remove elements.
	while (scone_elem.lastChild) scone_elem.removeChild(scone_elem.lastChild);

	// Re-insert elements.
	for (var i = 0; i < scone.items.length; i++) {
			var id = scone.items[i].id;
			var elems = elemsById[id];
			for (var j = 0; j < elems.length; j++) {
				scone_elem.appendChild(elems[j]);
			}
	}

	return;
}


// Save the state and items of a scone, then remove them.
//
// Returns a serialized copy of the scone, including its state, its items and
// the DOM / HTML representation of those items suitable for scone_restore().
//
//
// Notes:
//   * If the scone contains other scones (either as items, or within HTML
//     belonging to items), they will also be saved with the scone.
//   * Any styling or attributes applied to the scone HTML element itself
//     is NOT saved.
//   * The object returned should be treated as opaque - the format may
//     change.
//
function scone_cut(sconeElemId) {
	return _scone_cut(sconeElemId, false, false);
}


// Restore a scone saved with scone_extract.
//
// Replaces any existing contents of the element given by sconeElemId
// (which must exist).
//
// Returns nothing.
//
function scone_paste(sconeElemId, savedScone) {
	_scone_paste(sconeElemId, savedScone, false);
}


// Delete a scone and all its items (including nested scones), leaving only
// the scone HTML element itself (which will no longer be a scone).
//
// Returns nothing.
//
function scone_delete(sconeElemId) {
	_scone_delete(sconeElemId, false, false);
	return;
}


/* ------------ Private functions ----------- */


// As scone_delete, but with extra ignoreXXX params for efficiency when
// recursing.
function _scone_delete(sconeElemId, ignoreHTML, ignoreParent) {

	var scone = _scones[sconeElemId];
	if (scone == undefined) {
			throw("No such scone \"" + sconeElemId + "\"");
	}

	if (!ignoreHTML) {
			var scone_elem = document.getElementById(sconeElemId);
			if (scone_elem) {
				while (scone_elem.lastChild) {
					scone_elem.removeChild(scone_elem.lastChild);
				}
			}
	}

	if (!ignoreParent && scone.parentSconeItemId) {
			var parentSconeElemId = _scone_for[scone.parentSconeItemId];
			var parentScone = _scones[parentSconeElemId];
			var parentItem = parentScone.itemIdHash[scone.parentSconeItemId];
			delete parentItem.childSconeIdHash[sconeElemId];
	}

	for (var i = 0; i < scone.items.length; i++) {
			var item = scone.items[i];
			delete _scone_for[item.id];
			for (var childId in item.childSconeIdHash) {
				// no need to remove from doc or parent since
				// the top-level delete will have done this.
				_scone_delete(childId, true, true);
			}
	}

	delete _scones[sconeElemId];

	return;
}


// As scone_cut, but with extra params for recursive use.
function _scone_cut(sconeElemId, ignoreHTML, ignoreParent) {

	var scone = _scones[sconeElemId];

	// invalidate this scone's reference to the element in the DOM
	scone.scone_elem = null;

	if (scone == undefined) {
		throw("No such scone \"" + sconeElemId + "\"");
	}

	var saved_scone = {
		scone:         scone,
		elems:         [],
		childScones:   [],
		childSconeIds: []
	}

	if (!ignoreHTML) {
		var scone_elem = document.getElementById(sconeElemId);
		if (!scone_elem) {
				throw("Element \"" + sconeElemId + "\" not found.");
		}
		while (scone_elem.lastChild) {
			saved_scone.elems.splice(0,0, scone_elem.lastChild);
			scone_elem.removeChild(scone_elem.lastChild);
		}
	}

	if (!ignoreParent && scone.parentSconeItemId) {
			var parentSconeElemId = _scone_for[scone.parentSconeItemId];
			var parentScone = _scones[parentSconeElemId];
			var parentItem = parentScone.itemIdHash[scone.parentSconeItemId];
			delete parentItem.childSconeIdHash[sconeElemId];
	}

	for (var i = 0; i < scone.items.length; i++) {
		for (var childSconeId in scone.items[i].childSconeIdHash) {
			saved_scone.childSconeIds.push(childSconeId);
			// Recurse. There's no need to save any HTML this time.
			saved_scone.childScones.push(_scone_cut(childSconeId, true, true));
		}
		delete _scone_for[scone.items[i].id];
	}

	delete _scones[sconeElemId];

	return saved_scone;
}


// As scone_paste, but with extra param for recursion.
function _scone_paste(sconeElemId, savedScone, ignoreHTML) {

	if (_scones[sconeElemId] != undefined) {
			throw("Scone \"" + sconeElemId + "\" already exists.");
	}

	if (!ignoreHTML) {

		var scone_elem = document.getElementById(sconeElemId);
		if (!scone_elem) {
				throw("Element \"" + sconeElemId + "\" not found.");
		}
		// Remove existing contents
		while (scone_elem.lastChild) {
			scone_elem.removeChild(scone_elem.lastChild);
		}
		// Add saved elements
		for (var i = 0; i < savedScone.elems.length; i++) {
			scone_elem.appendChild(savedScone.elems[i]);
		}

		// Check if this scone is an item in another scone, or if it has been
		// pasted within an item of another scone.

		var elem = scone_elem;
		var pscone_id      = null;
		var pscone_item_id = null;
		while (elem) {
			if (elem.id) {
				if (_scone_for[elem.id] != undefined) {
					pscone_id      = _scone_for[elem.id];
					pscone_item_id = elem.id;
					break;
				}
			}
			elem = elem.parentNode;
		}
		if (pscone_item_id) {
			savedScone.scone.parentSconeItemId = pscone_item_id;
			var pitem = _scones[pscone_id].itemIdHash[pscone_item_id];
			// mark our scone as a child of the parent item
			pitem.childSconeIdHash[sconeElemId] = true;
		}

		// restore this scone's reference to the element in the DOM
		savedScone.scone.scone_elem = scone_elem;

	}

	_scones[sconeElemId] = savedScone.scone;

	for (var i = 0; i < savedScone.scone.items.length; i++) {
		var item = savedScone.scone.items[i];
		_scone_for[item.id] = sconeElemId;
	}

	for (var i = 0; i < savedScone.childScones.length; i++) {
		var childScone   = savedScone.childScones[i];
		var childSconeId = savedScone.childSconeIds[i];
		// Recurse. There's no need to restore any HTML this time.
		_scone_paste(childSconeId, childScone, true);
	}

	return;
}


// Find the first top-level HTML element in an item.
function _scone_first_item_elem(item) {
	var item_key_elem = document.getElementById(item.id);
	if (!item_key_elem) {
			throw("Element \"" + item.id + "\" not found.");
	}
	var elem = item_key_elem;
	for (var i = 0; i < item.offsetUp; i++) {
			elem = elem.parentNode;
	}
	for (var i = 0; i < item.offsetLeft; i++) {
			elem = elem.previousSibling;
	}
	return elem;
}


// Find "insert before" position for a new item by comparing its info with
// that of the existing items using the scone's sort function and mode.
// Number of comparisons will be O(log2 n).
// Returns index in the range 0 to number of items (inclusive).
// Note that if the new_info compares equal to the info of an existing item,
// it will be considered to come after the existing item.
function _scone_find_ipos(scone, new_info) {
	var arr     = scone.items;
	var cmpFn   = scone.cmpFn;
	var cmpMode = scone.cmpMode;
	var h = arr.length, l = -1, m;
	while (h - l > 1) {
			if (cmpFn(cmpMode, arr[m = h + l >> 1].info, new_info) < 0) {
				l = m;
			} else {
				h = m;
			}
	}
	if (h < arr.length && cmpFn(cmpMode, arr[h].info, new_info) == 0) {
			return h + 1;
	} else {
			return h;
	}
}


/* Writing crunched file sortabletable.js */
/*----------------------------------------------------------------------------\
|                            Sortable Table 1.12                              |
|-----------------------------------------------------------------------------|
|                         Created by Erik Arvidsson                           |
|                  (http://webfx.eae.net/contact.html#erik)                   |
|                      For WebFX (http://webfx.eae.net/)                      |
|-----------------------------------------------------------------------------|
| A DOM 1 based script that allows an ordinary HTML table to be sortable.     |
|-----------------------------------------------------------------------------|
|                  Copyright (c) 1998 - 2006 Erik Arvidsson                   |
|-----------------------------------------------------------------------------|
| Licensed under the Apache License, Version 2.0 (the "License"); you may not |
| use this file except in compliance with the License.  You may obtain a copy |
| of the License at http://www.apache.org/licenses/LICENSE-2.0                |
| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
| Unless  required  by  applicable law or  agreed  to  in  writing,  software |
| distributed under the License is distributed on an  "AS IS" BASIS,  WITHOUT |
| WARRANTIES OR  CONDITIONS OF ANY KIND,  either express or implied.  See the |
| License  for the  specific language  governing permissions  and limitations |
| under the License.                                                          |
|-----------------------------------------------------------------------------|
| 2003-01-10 | First version                                                  |
| 2003-01-19 | Minor changes to the date parsing                              |
| 2003-01-28 | JScript 5.0 fixes (no support for 'in' operator)               |
| 2003-02-01 | Sloppy typo like error fixed in getInnerText                   |
| 2003-07-04 | Added workaround for IE cellIndex bug.                         |
| 2003-11-09 | The bDescending argument to sort was not correctly working     |
|            | Using onclick DOM0 event if no support for addEventListener    |
|            | or attachEvent                                                 |
| 2004-01-13 | Adding addSortType and removeSortType which makes it a lot     |
|            | easier to add new, custom sort types.                          |
| 2004-01-27 | Switch to use descending = false as the default sort order.    |
|            | Change defaultDescending to suit your needs.                   |
| 2004-03-14 | Improved sort type None look and feel a bit                    |
| 2004-08-26 | Made the handling of tBody and tHead more flexible. Now you    |
|            | can use another tHead or no tHead, and you can chose some      |
|            | other tBody.                                                   |
| 2006-04-25 | Changed license to Apache Software License 2.0                 |  
|-----------------------------------------------------------------------------|
| Created 2003-01-10 | All changes are in the log above. | Updated 2006-04-25 |
\----------------------------------------------------------------------------*/


function SortableTable(ev_id, headers_row_idx, oTable, oSortTypes) {

	this.sortTypes = oSortTypes || [];

	this.sortColumn = null;
	this.descending = null;
	this.ev_id      = ev_id;
	this.headers_row_idx = headers_row_idx;

	var oThis = this;
	this._headerOnclick = function (e) {
		oThis.headerOnclick(e);
	};

	if (oTable) {
		this.setTable( oTable );
		this.document = oTable.ownerDocument || oTable.document;
	}
	else {
		this.document = document;
	}


	// only IE needs this
	var win = this.document.defaultView || this.document.parentWindow;
	this._onunload = function () {
		oThis.destroy();
	};
	if (win && typeof win.attachEvent != "undefined") {
		win.attachEvent("onunload", this._onunload);
	}
}

SortableTable.gecko = navigator.product == "Gecko";
SortableTable.msie = /msie/i.test(navigator.userAgent);
// Mozilla is faster when doing the DOM manipulations on
// an orphaned element. MSIE is not
SortableTable.removeBeforeSort = SortableTable.gecko;

SortableTable.prototype.onsort = function () {};

// default sort order. true -> descending, false -> ascending
SortableTable.prototype.defaultDescending = false;

// shared between all instances. This is intentional to allow external files
// to modify the prototype
SortableTable.prototype._sortTypeInfo = {};

SortableTable.prototype.setTable = function (oTable) {
	if ( this.tHead )
		this.uninitHeader();
	this.element = oTable;
	this.setTHead( oTable.tHead );
	this.setTBody( oTable.tBodies[0] );
};

SortableTable.prototype.setTHead = function (oTHead) {
	if (this.tHead && this.tHead != oTHead )
		this.uninitHeader();
	this.tHead = oTHead;
	this.initHeader( this.sortTypes );
};

SortableTable.prototype.setTBody = function (oTBody) {
	this.tBody = oTBody;
};

SortableTable.prototype.setSortTypes = function ( oSortTypes ) {
	if ( this.tHead )
		this.uninitHeader();
	this.sortTypes = oSortTypes || [];
	if ( this.tHead )
		this.initHeader( this.sortTypes );
};

// adds arrow containers and events
// also binds sort type to the header cells so that reordering columns does
// not break the sort types
SortableTable.prototype.initHeader = function (oSortTypes) {
	if (!this.tHead) return;
	var cells = this.tHead.rows[this.headers_row_idx].cells;
	var doc = this.tHead.ownerDocument || this.tHead.document;
	this.sortTypes = oSortTypes || [];
	var l = cells.length;
	var img, c;
	for (var i = 0; i < l; i++) {
		c = cells[i];
		if (this.sortTypes[i] != null && this.sortTypes[i] != "None") {
			img = doc.createElement("img");
			img.src = "/img/sb/racing/sortasc.gif";
			c.appendChild(img);
			if (this.sortTypes[i] != null)
				c._sortType = this.sortTypes[i];
			if (typeof c.addEventListener != "undefined")
				c.addEventListener("click", this._headerOnclick, false);
			else if (typeof c.attachEvent != "undefined")
				c.attachEvent("onclick", this._headerOnclick);
			else
				c.onclick = this._headerOnclick;
		}
		else
		{
			c.setAttribute( "_sortType", oSortTypes[i] );
			c._sortType = "None";
		}
	}
	this.updateHeaderArrows();
};

// remove arrows and events
SortableTable.prototype.uninitHeader = function () {
	if (!this.tHead) return;
	var cells = this.tHead.rows[this.headers_row_idx].cells;
	var l = cells.length;
	var c;
	for (var i = 0; i < l; i++) {
		c = cells[i];
		if (c._sortType != null && c._sortType != "None") {
			c.removeChild(c.lastChild);
			if (typeof c.removeEventListener != "undefined")
				c.removeEventListener("click", this._headerOnclick, false);
			else if (typeof c.detachEvent != "undefined")
				c.detachEvent("onclick", this._headerOnclick);
			c._sortType = null;
			c.removeAttribute( "_sortType" );
		}
	}
};

SortableTable.prototype.updateHeaderArrows = function () {
	if (!this.tHead) return;
	var cells = this.tHead.rows[this.headers_row_idx].cells;
	var l = cells.length;
	var img;
	for (var i = 0; i < l; i++) {
		if (cells[i]._sortType != null && cells[i]._sortType != "None") {
			img = cells[i].lastChild;
			if (i == this.sortColumn)
				img.src = "/img/sb/racing/" + (this.descending ? "sortdesc.gif" : "sortasc.gif");
			else
				img.src = "/img/sb/racing/sortnone.gif";
		}
	}
};

SortableTable.prototype.headerOnclick = function (e) {
	// find TD element
	var el = e.target || e.srcElement;
	while (el.tagName != "TH")
		el = el.parentNode;

  var doc = this.tHead.ownerDocument || this.tHead.document;
  var initalSort = doc.getElementById("initialsort_" + this.ev_id);
  initalSort.style.display = "none";

	this.sort(SortableTable.msie ? SortableTable.getCellIndex(el) : el.cellIndex);
};

// IE returns wrong cellIndex when columns are hidden
SortableTable.getCellIndex = function (oTd) {
	var cells = oTd.parentNode.childNodes
	var l = cells.length;
	var i;
	for (i = 0; cells[i] != oTd && i < l; i++)
		;
	return i;
};

SortableTable.prototype.getSortType = function (nColumn) {
	return this.sortTypes[nColumn] || "String";
};

// only nColumn is required
// if bDescending is left out the old value is taken into account
// if sSortType is left out the sort type is found from the sortTypes array

SortableTable.prototype.sort = function (nColumn, bDescending, sSortType) {
	if (!this.tBody) return;

	if (sSortType == null)
		sSortType = this.getSortType(nColumn);

	// exit if None
	if (sSortType == "None")
		return;

	if (bDescending == null) {
		if (this.sortColumn != nColumn)
			this.descending = this.defaultDescending;
		else
			this.descending = !this.descending;
	}
	else
		this.descending = bDescending;

	if (sSortType == "Odds" && this.sortColumn != nColumn) {
		this.descending = !this.descending;
	}

	this.sortColumn = nColumn;

	if (typeof this.onbeforesort == "function")
		this.onbeforesort();

	var f = this.getSortFunction(sSortType, nColumn);
	var a = this.getCache(sSortType, nColumn);
	var tBody = this.tBody;

	a.sort(f);

	if (this.descending)
		a.reverse();

	if (SortableTable.removeBeforeSort) {
		// remove from doc
		var nextSibling = tBody.nextSibling;
		var p = tBody.parentNode;
		p.removeChild(tBody);
	}

	// insert in the new order
	var l = a.length;
	for (var i = 0; i < l; i++)
		tBody.appendChild(a[i].element);

	if (SortableTable.removeBeforeSort) {
		// insert into doc
		p.insertBefore(tBody, nextSibling);
	}

	this.updateHeaderArrows();

	this.destroyCache(a);

	if (typeof this.onsort == "function")
		this.onsort();
};

SortableTable.prototype.asyncSort = function (nColumn, bDescending, sSortType) {
	var oThis = this;
	this._asyncsort = function () {
		oThis.sort(nColumn, bDescending, sSortType);
	};
	window.setTimeout(this._asyncsort, 1);
};

SortableTable.prototype.getCache = function (sType, nColumn) {
	if (!this.tBody) return [];
	var rows = this.tBody.rows;
	var l = rows.length;
	var a = new Array(l);
	var r;
	for (var i = 0; i < l; i++) {
		r = rows[i];
		a[i] = {
			value:		this.getRowValue(r, sType, nColumn),
			element:	r
		};
	};
	return a;
};

SortableTable.prototype.destroyCache = function (oArray) {
	var l = oArray.length;
	for (var i = 0; i < l; i++) {
		oArray[i].value = null;
		oArray[i].element = null;
		oArray[i] = null;
	}
};

SortableTable.prototype.getRowValue = function (oRow, sType, nColumn) {
	// if we have defined a custom getRowValue use that

	if (this._sortTypeInfo[sType] && this._sortTypeInfo[sType].getRowValue)
		return this._sortTypeInfo[sType].getRowValue(oRow, nColumn);

	var s;
	var c = oRow.cells[nColumn];
	if (typeof c.innerText != "undefined")
		s = c.innerText;
	else
		s = SortableTable.getInnerText(c);

	return this.getValueFromString(s, sType);
};

SortableTable.getInnerText = function (oNode) {
	var s = "";
	var cs = oNode.childNodes;
	var l = cs.length;
	for (var i = 0; i < l; i++) {
		switch (cs[i].nodeType) {
			case 1: //ELEMENT_NODE
				s += SortableTable.getInnerText(cs[i]);
				break;
			case 3:	//TEXT_NODE
				s += cs[i].nodeValue;
				break;
		}
	}
	return s;
};

SortableTable.prototype.getValueFromString = function (sText, sType) {
	if (this._sortTypeInfo[sType])
		return this._sortTypeInfo[sType].getValueFromString( sText );
	return sText;
};

SortableTable.prototype.getSortFunction = function (sType, nColumn) {
	if (this._sortTypeInfo[sType])
		return this._sortTypeInfo[sType].compare;
	return SortableTable.basicCompare;
};

SortableTable.oddsCompare = function oddsCompare(n1, n2) {
	if (parseFloat(n1.value) < parseFloat(n2.value))
		return -1;
	if (parseFloat(n2.value) < parseFloat(n1.value))
		return 1;
	return 0;
};

SortableTable.getGHRunnerNum = function (oRow, nColumn) {

	var s;
	var c = oRow.cells[0];
	if (typeof c.innerText != "undefined")
		s = c.innerText;
	else
		s = SortableTable.getInnerText(c);
	return this.getValueFromString(s, "GreyhoundDog");
};

SortableTable.getOdds = function (oRow, nColumn) {
	var s;
	var c = oRow.cells[nColumn];

	if (typeof c.innerText != "undefined") {
		s = c.innerText;
	} else {
		s = SortableTable.getInnerTextOdds(c);
	}

	if (s == "") {
		s = "0.0";
	}

	return this.getValueFromString(s, "Odds");
};

// the odds element contains als sorts of data we dont wont to sort by
// we only want to sort by the firts element of data, the current odds
SortableTable.getInnerTextOdds = function (oNode) {
	var s = "";
	var cs = oNode.childNodes;
	var l = cs.length;
	var break_out  = 0;
	for (var i = 0; i < l; i++) {

		switch (cs[i].nodeType) {
			case 1: //ELEMENT_NODE
				s = SortableTable.getInnerTextOdds(cs[i]);
				break_out = 1;
				break;
			case 3:	//TEXT_NODE
				s = cs[i].nodeValue;
				break_out = 1;
				break;
		}

		if (break_out == 1) {
			break;
		}
	}

	return s;
};

SortableTable.prototype.destroy = function () {
	this.uninitHeader();
	var win = this.document.parentWindow;
	if (win && typeof win.detachEvent != "undefined") {	// only IE needs this
		win.detachEvent("onunload", this._onunload);
	}
	this._onunload = null;
	this.element = null;
	this.tHead = null;
	this.tBody = null;
	this.document = null;
	this._headerOnclick = null;
	this.sortTypes = null;
	this._asyncsort = null;
	this.onsort = null;
};

// Adds a sort type to all instance of SortableTable
// sType : String - the identifier of the sort type
// fGetValueFromString : function ( s : string ) : T - A function that takes a
//    string and casts it to a desired format. If left out the string is just
//    returned
// fCompareFunction : function ( n1 : T, n2 : T ) : Number - A normal JS sort
//    compare function. Takes two values and compares them. If left out less than,
//    <, compare is used
// fGetRowValue : function( oRow : HTMLTRElement, nColumn : int ) : T - A function
//    that takes the row and the column index and returns the value used to compare.
//    If left out then the innerText is first taken for the cell and then the
//    fGetValueFromString is used to convert that string the desired value and type

SortableTable.prototype.addSortType = function (sType, fGetValueFromString, fCompareFunction, fGetRowValue) {

	this._sortTypeInfo[sType] = {
		type:				sType,
		getValueFromString:	        fGetValueFromString || SortableTable.idFunction,
		compare:			fCompareFunction || SortableTable.basicCompare,
		getRowValue:		        fGetRowValue
	};
};

// this removes the sort type from all instances of SortableTable
SortableTable.prototype.removeSortType = function (sType) {
	delete this._sortTypeInfo[sType];
};

SortableTable.basicCompare = function compare(n1, n2) {
	if (n1.value < n2.value)
		return -1;
	if (n2.value < n1.value)
		return 1;
	return 0;
};

SortableTable.idFunction = function (x) {
	return x;
};

SortableTable.toUpperCase = function (s) {
	return s.toUpperCase();
};

SortableTable.toDate = function (s) {
	var parts = s.split("-");
	var d = new Date(0);
	d.setFullYear(parts[0], parts[1] - 1, parts[2]);
	return d.valueOf();
};

SortableTable.toDecimal = function (s) {

	s = s.replace('SP','');
	s = s.replace('evens','2.00');
	s = s.strip();

	if (s.indexOf(".") > -1) {
		return s;
	} else if (s.indexOf("-") > -1) {
		var parts = s.split("-");
		var decimal_odds = (parseFloat(parts[0]) / parseFloat(parts[1])) + 1;
		return decimal_odds;
	} else if (s.indexOf("/") > -1) {
		var parts = s.split("/");
		var decimal_odds = (parseFloat(parts[0]) / parseFloat(parts[1])) + 1;
		return decimal_odds;
	}
}

SortableTable.toNumber = function (s) {

	var bracket_index = s.indexOf("(");

	if (bracket_index < 0) {
		return s;
	} else {
		s = s.stripTags();
		s = s.substring(0,bracket_index);
		s = s.strip();
		return (s + 0.00);
	}
}

// add sort types
SortableTable.prototype.addSortType("Number", Number);
SortableTable.prototype.addSortType("CaseInsensitiveString", SortableTable.toUpperCase);
SortableTable.prototype.addSortType("Date", SortableTable.toDate);
SortableTable.prototype.addSortType("String");
SortableTable.prototype.addSortType("Racecard", SortableTable.toNumber, SortableTable.oddsCompare);
SortableTable.prototype.addSortType("GreyhoundDog", SortableTable.toNumber, SortableTable.basicCompare, SortableTable.getGHRunnerNum);
SortableTable.prototype.addSortType("Odds", SortableTable.toDecimal, SortableTable.oddsCompare, SortableTable.getOdds);
// None is a special case


/* Writing crunched file swfobject.js */
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();

/* Writing crunched file tmpl.js */
/*
 * Fast[1], Powerful[2] Javascript Template Player.
 *
 * [1] Templates are compiled to native javascript when stored.
 * [2] Has control structures + allows arbitrary javascript.
 */

// ensure CVS revision number survives minification

/*
 * tmpl_store - Store (and compile) a template.
 *
 * Params:
 *   tmpl_name = Name to use when referring to the template.
 *   template  = A string which may contain template directives (see below).
 *               Anything outside a template directive is copied to the output.
 *
 * Template Directives:
 *
 *   <%IF boolExpr%> body <%ELSE IF boolExpr%> body <%ELSE%> body <%END%>
 *     The javascript expression boolExpr in each IF and ELSE IF clause will
 *     be evaluated in turn until one is true; if so the following body will
 *     be played. Otherwise, the body after the ELSE clause will be played.
 *     There can be zero or more ELSE IF clauses and at most one ELSE clause.
 *
 *   <%LOOP varName endExpr%> body <%END%>
 *     body will be played with the local variable given by varName set in
 *     sequence to 0 up to one less than the result of the javascript
 *     expression endExpr. endExpr is evaluated on each iteration.
 *
 *   <%BREAK%>
 *     Only valid within a LOOP body - ends iteration.
 *
 *   <%CONTINUE%>
 *     Only valid within a LOOP body - skip to next iteration.
 *
 *   <%COMMENT ignored%>
 *     Self-explanatory.
 *
 *   <%JS jsStmt%>
 *     The javascript statement jsStmt will be executed and the result
 *     discarded.
 *
 *   <%jsExpr%>
 *     The result of the javascript expression jsExpr will appear in the
 *     output. The expression can of course simply be a global variable name
 *     or property of the dict object supplied when playing the template.
 * 
 *   <%XL code%>
 *     The result of tmpl_xl(code) will appear in the output.
 *     Note that the translation will occur when the template is stored if
 *     a translation for the code has already been stored with tmpl_xl_set().
 *
 * Returns:
 *   Nothing, or throws an exception if the template has errors.
 *
 * Bugs:
 *   Syntax / Error checking is terrible.
 * 
 * Example:
 *
 *   var template =
 *     '<%COMMENT Example Template%>'
 *   + '<pre>\n'
 *   + 'x + 1 = <%x + 1%>\n'
 *   + '<%IF foo%>'
 *   + 'branch1\n'
 *   + '<%ELSE%>'
 *   + 'branch2\n'
 *   + '<%END%>'
 *   + '<%LOOP i limit%>'
 *   + '<%IF i == 3%>skipping 3\n<%CONTINUE%><%END%>'
 *   + '<%IF i == 5%>breaking at 5\n<%BREAK%><%END%>'
 *   + '2i = <%i * 2%>\n'
 *   + '<%END%>'
 *   + '<%LOOP j stuff.length%>'
 *   + '<div<%IF j % 2%> style="color:green"<%END%>>'
 *   + '<%stuff[j]%>'
 *   + '</div>'
 *   + '<%END%>\n'
 *   + '<%XL FIN%>\n'
 *   + '</pre>'
 *   ;
 *   tmpl_xl_set('FIN', 'That\'s all folks');
 *   tmpl_store('test', template);
 *   var dict = {x: 123, limit: 10, foo: true, stuff: [1,2,3,4,5]};
 *   var out = tmpl_play('test', dict);
 *   print('Played:\n' + out);
 *
 */
var _tmpl = {};
function tmpl_store(tmpl_name, template) {
	// We construct a function body that will play the template.
	var bodyParts = [];
	// The played template strings will be built up in this var.
	bodyParts.push("var __ss = [];");
	// Make the properties of the object passed when the template is
	// played available in the local scope.
	bodyParts.push("with (_dict) {");
	// Parse the template, looking for <% and %> to indicate the
	// start and end of directives.
	var i = 0;
	var loop_counter = 0;
	var text = '';
	var directive = '';
	var state = 'TEXT';
	for (; i < template.length; i++) {
		var c = template.charAt(i);
		if (state == 'TEXT') {
			if (c == '<') {
				state = 'MAYBE_OPEN';
			} else {
				text += c;
			}
		} else if (state == 'MAYBE_OPEN') {
			if (c == '%') {
				state = 'DIRECTIVE';
			} else {
				text += '<' + c;
				state = 'TEXT';
			}
		} else if (state == 'DIRECTIVE') {
			if (c == '%') {
				state = 'MAYBE_CLOSE';
			} else {
				directive += c;
			}
		} else if (state == 'MAYBE_CLOSE') {
			if (c == '>') {
				// Output the text that led up to the directive.
				if (text.length > 0) {
					bodyParts.push("__ss.push('" + tmpl_esc_js(text) + "');");
				}
				// We've found a directive. See if it is a keyword.
				var m;
				if (       m = directive.match(/^IF\s+(.+)$/)) {
					var expr = m[1];
					bodyParts.push("if (" + expr + ") {");
				} else if (m = directive.match(/^ELSE\s+IF\s+(.+)$/)) {
					var expr = m[1];
					bodyParts.push("} else if (" + expr + ") {");
				} else if (m = directive.match(/^ELSE$/)) {
					bodyParts.push("} else {");
				} else if (m = directive.match(/^LOOP\s+(\w+)\s+(.+)$/)) {
					var varName = m[1];
					var endExpr = m[2];
					bodyParts.push("var __e" + loop_counter + " = " + endExpr + ";");
					var forHead = "var " + varName + " = 0; " + varName + " < __e" + loop_counter + "; " + varName + "++";
					bodyParts.push("for (" + forHead + ") {");
					loop_counter++;
				} else if (m = directive.match(/^CONTINUE$/)) {
					bodyParts.push("continue;");
				} else if (m = directive.match(/^BREAK$/)) {
					bodyParts.push("break;");
				} else if (m = directive.match(/^END$/)) {
					bodyParts.push("}");
				} else if (m = directive.match(/^COMMENT\s+/)) {
					// No-op.
				} else if (m = directive.match(/^JS\s+(.+)$/)) {
					var stmt = m[1];
					bodyParts.push(stmt + ";");
				} else if (m = directive.match(/^XL\s+(.+)$/)) {
					var code = m[1];
					xl = _tmpl_xl['c' + code];
					if (xl != undefined) {
						// store-time xlation
						if (xl.length > 0) {
							bodyParts.push("__ss.push('" + tmpl_esc_js(xl) + "');");
						}
					} else {
						// play-time xlation
						bodyParts.push("__ss.push(tmpl_xl('" + tmpl_esc_js(code) + "'));");
					}
				} else if (directive.length > 0) {
					// Treat the directive as a JS expression.
					bodyParts.push("__ss.push(" + directive + ");");
				} else {
					throw('Empty directive');
				}
				text = '';
				directive = '';
				state = 'TEXT';
			} else {
				directive += '%' + c;
				state = 'DIRECTIVE'
			}
		} else {
			throw('bad state ' + state);
		}
	}
	// Output any trailing text.
	if (text.length > 0) {
		bodyParts.push("__ss.push('" + tmpl_esc_js(text) + "');");
	}
	if (directive.length > 0) {
		throw('Unterminated directive ' + directive);
	}
	// Close the 'with' statement.
	bodyParts.push("}\n");
	bodyParts.push("return __ss.join('');");
	var body = bodyParts.join("\n");
	try {
		_tmpl['t' + tmpl_name] = new Function(['_dict'], body);
	} catch (e) {
		throw('Could not compile template: ' + e + '; body was: \n' + body);
	}
	return;
}

/*
 * tmpl_play - Play a previously stored template.
 *
 * Params:
 *   tmpl_name - The name of a template passed to tmpl_store.
 *   dict      - A javascript object whose properties will become
 *               available as local variables within the template.
 *
 *  Returns:
 *   The output from the template, or throws an exception if the template
 *   has an error.
 */
function tmpl_play(tmpl_name, dict) {
	return _tmpl['t' + tmpl_name](dict);
}

/*
 * Store one or more translations for codes.
 * Usage:
 *   tmpl_xl_set(code1, xlation1, ... codeN, xlationN)
 * Call this before storing templates for greater efficiency.
 */
var _tmpl_xl = {};
function tmpl_xl_set(vargs) {
	for (var i = 0; i < arguments.length - 1; i += 2) {
		_tmpl_xl['c' + arguments[i]] = arguments[i+1];
	}
}

/*
 * Get translation stored with tmpl_xl_set for code, or code itself if none.
 */
function tmpl_xl(code) {
	return ((xl = _tmpl_xl['c' + code]) != undefined) ? xl : code;
}

/*
 * Get translation stored with tmpl_xl_set for code, and substitute any
 * "%s" placeholders in the translations with the other arguments.
 * Returns code if no translation found.
 */
function tmpl_ml_printf(code, variable_number_of_other_args) {
	var xl = _tmpl_xl['c' + code];
	if (xl == undefined) return code;
	var i = 1; var last_posn = 0; var s = "";
	var placeholder = "%s";
	while (true) {
		var placeholder_posn = xl.indexOf(placeholder, last_posn);
		if (placeholder_posn < 0) {
			s += xl.substr(last_posn);
			break;
		}
		s += xl.substr(last_posn, placeholder_posn - last_posn);
		if (i < arguments.length) {
			s += arguments[i];
		} else {
			s += placeholder;
		}
		last_posn = placeholder_posn + placeholder.length;
		i++;
	}
	return s;
}

/*
 * Escape a string so it can safely be used as a JS string literal.
 */
function tmpl_esc_js(s) {
	var p = '';
	for (var i = 0; i < s.length; i++) {
		var c = s.charAt(i);
		switch (c) {
			case '\\':
				p += '\\\\';
				break;
			case '\'':
				p += '\\\'';
				break;
			case '"':
				p += '\\"';
				break;
			case '\n':
				p += '\\n';
				break;
			case '\r':
				p += '\\r';
				break;
			default:
				p += c;
		}
	}
	return p;
}

/*
 * Escape a string so it can safely be used in HTML.
 */ 
function tmpl_esc_html(s) {
	var p = '';
	for (var i = 0; i < s.length; i++) {
		var c = s.charAt(i);
		switch (c) {
			case '<':
				p += '&lt;';
				break;
			case '>':
				p += '&gt;';
				break;
			case '&':
				p += '&amp;';
				break;
			case '"':
				p += '&quot;';
				break;
			case '\'':
				p += '&#39;';
				break;
			default:
				p += c;
		}
	}
	return p;
}


/* Writing crunched file util.js */

// minified CVS tag version

ob.util = {};

// write a select input box
//
function write_select() {

	var sel = arguments[0];
	var i;
	var n;
	var v;
	var sel_tag;

	for(i = 1; i < arguments.length; i += 2) {
		v = arguments[i];
		n = arguments[i + 1];
		sel_tag = (sel == v) ? ' selected=""' : '';
		document.writeln(
			'<option value="' + v + '"' + sel_tag + '>' + n + '</option>'
		);
	}
}

// Preloads images
//
function MM_preloadImages() {
	var d=document;

	if (d.images) {
		if (!d.MM_p) {
			d.MM_p=new Array();
		}
		var i,j=d.MM_p.length,a=MM_preloadImages.arguments;
		for(i=0; i<a.length; i++) {
			if (a[i].indexOf("#") !=0) {
				d.MM_p[j]=new Image;
				d.MM_p[j++].src=a[i];
			}
		}
	}
}

// trim whitespace from a string
OT_util_included = true;


function OT_trim(str) {
	var sl = ""+str.length;
	var i;
	for (i = 0; i < sl; i++) {
		if (str.charAt(i) != ' ' &&
			str.charAt(i) != '\t' &&
			str.charAt(i) != '\n') {
			break;
		}
	}
	start = i;

	for (i = sl-1; i > 0; i--) {
		if (str.charAt(i) != ' ' &&
			str.charAt(i) != '\t' &&
			str.charAt(i) != '\n') {
			break;
		}
	}

	return str.substring(start, i+1);
}


// global replace , with .
function OT_replace_comma_with_dp(str)
{
	str2=str.replace(/[,]/g,".");
	return str2;
}


// split str on any of the characters in delim
// return the substrings as an array
function OT_strtok(str, d)
{
	var a = new Array();
	var i, j;
	var s = ""+str;
	var sl = s.length;
	var dl = d.length;

	if (s.charAt(0) == ".") {
		a[0] = "0";
		var sz = 1;
	} else {
		var sz = 0;
	}

	var st = 0;
	for (i = 0; i < sl; i++) {
		for (j = 0; j < dl; j++) {
			if (s.charAt(i) == d.charAt(j)) {
				if (st != i) {
					a[sz] = s.substring(st, i);
					sz = sz + 1;
					a.length = sz;
				}
				st = i+1;
}
		}
	}
	if (st != i) {
		a[sz] = s.substring(st, i);
	}
	return a;
}

BROKEN_NAN = false;

if (!isNaN(parseInt('a'))) {
	BROKEN_NAN = true;
}



function pad(str, len, ch) {
	var i;
	for (i = len - str.length; i > 0; i--) {
	str += ch;
	}
	return str;
}


function OT_round(str, dp)
{

	var len = 0;
	var a = OT_strtok(str, ".");
var i, n;

	if (a.length == 0) {
		return pad("0.", dp+2, "0");
	} else if (a.length == 1) {
		len=Number(a[0].length)+Number(dp)+1;
		return pad(a[0]+".", len, "0");
	} else {
		if (a[1].length <= dp) {
			len=Number(a[0].length)+Number(dp)+1;
			return pad(a[0]+"."+a[1], len, "0");
		} else {
			if (Number(a[1].substring(Number(dp), Number(dp)+1)) >= 5) {
				var rem = 1;
			} else {
				var rem = 0;
			}

			var tail ="";
			for (i = dp-1; i >= 0; i--) {
				n = Number(a[1].substring(i, i+1))+Number(rem);
				if (n >= 10) {
					rem = 1;
					n = Number(n)-10;
					tail = ""+n+tail;
				} else {
					return a[0]+"."+a[1].substring(0, i)+n+tail;
				}
			}
		}

		if (rem > 0) {
			a[0]=Number(a[0])+Number(rem);
		}
		return a[0]+"."+tail;
	}
}



// functions to build up and retrieve a list of errors

var otErrStr = "";
var otNErrs = 0;

function OT_ErrReset() {
	otErrStr = "";
	otNErrs = 0;
}

function OT_ErrAdd(str) {
	otErrStr += str;
	otNErrs++;
	return otNErrs;
}

function OT_ErrStr() {
	return otErrStr;
}

function OT_ErrCount() {
	return otNErrs;
}


//////////////////////////////////////////////
// Print money in appropriate currency format
// Use Pound sign for GBP and just pass
// currency code if no amount is supplied
//////////////////////////////////////////////
function print_ccy (amt, ccy) {

	var str = "";

	amt = OT_round(amt,2);

	// If amt is negative remove minus so that it can be put before currency symbol
	if (Number(amt) < 0) {
	str = '-';
	amt = Number(amt) * -1;
}

	str += print_ccy_symbol(ccy);

	// tag on amount - still to add comma separation of 1000s etc
	if (amt != "") {
	str += amt;
	}

	return str;
}

function print_ccy_symbol (ccy) {

	if (ccy == "GBP" || ccy == "") {
		str = "&pound;";
	} else if (ccy == "IEP") {
		str = "IR&pound; "
	} else if (ccy == "USD") {
		str = "US$ "
	} else if (ccy == "AUS") {
		str = "AUS$ "
	} else if (ccy == "EUR") {
		str = "&euro;"
	} else {
		str=ccy;
	}
	return str;
}

function chip_ccy_convert(funds, direction) {

	var converted_funds = 0.0;

	// if going from dollars, need to invert the exchange rate,
	// BUT we want to keep the value known in the util.exch_rate object
	var exch_rate = util.exch_rate;
	if (direction == "from_usd") {
		exch_rate = 1 / exch_rate;
	}

	if (!isNaN(parseFloat(funds))) {
		converted_funds = parseFloat(funds) * exch_rate;
	}

	converted_funds = Math.round(converted_funds * 100) / 100;

	return converted_funds;
}

/*
 * Given new JS data, this function checks in the hashtables for data that
 * is now no longer present but was previously and removes the HTML along with
 * clearing out the hashtables down to a specified level.
 *
 * handler:    the handler object as set in the files using this function.
 * level_from: the starting level.
 * level_to:   the level to which the function will drill down to during clearing.
 * check_data: the latest data we are checking the existing hashes against. This
 *             should be data relating to the "check_level".
 */
var level_hier      = {};
level_hier["CLASS"] = 0;
level_hier["TYPE"]  = 1;
level_hier["EVENT"] = 2;
level_hier["EVMKT"] = 3;
level_hier["EVOC"]  = 4;

var hier_level = {};
hier_level[0]  = "CLASS";
hier_level[1]  = "TYPE";
hier_level[2]  = "EVENT";
hier_level[3]  = "EVMKT";
hier_level[4]  = "EVOC";

var level_data_id = {};
level_data_id[0] = "";
level_data_id[1] = "";
level_data_id[2] = "";
level_data_id[3] = "";
level_data_id[4] = "";

function push_hash_prune_drilldown(
	handler,
	level_from,
	level_to,
	check_level,
	check_data
) {

	// Calculate the maximum level of recursion.
	var max_recursion_level = level_hier[level_to] - level_hier[level_from];

	// Initialise the recursion drilldown.
	push_hash_prune_drilldown_recurse(
		handler,
		0,
		max_recursion_level,
		level_hier[level_from],
		level_hier[check_level],
		check_data,
		0
	);

	return;
}

// current_level and check_level are in the format of an index for hier_level.
// e.g for CLASS as the current level, current_level = 0.
function push_hash_prune_drilldown_recurse (
	handler,
	recursion_level,
	max_recursion_level,
	current_level,
	check_level,
	check_data,
	parent_id
) {

	// Get the hash information for this level.
	if (recursion_level == 0) {
		var id_list = handler.getHash(hier_level[current_level]);
	} else {
		var id_list = handler.getHash(hier_level[current_level - 1])[parent_id].child_hash;
	}

	var info_hash = handler.getHash(hier_level[current_level]);
	var found     = false;
	var i         = 0;
	var scitem_id = "";
	var data_id   = "";

	for (data_id in id_list) {

		found = false;

		if (check_level == current_level) {
			for (i = 0; i < check_data.length; i++) {
				// :(
				switch(hier_level[current_level]) {
					case "CLASS":
						if (check_data[i].ev_class_id == data_id) {
							found = true;
						}
						break;
					case "TYPE":
						if (check_data[i].ev_type_id == data_id) {
							found = true;
						}
						break;
					case "EVENT":
						if (check_data[i].ev_id == data_id) {
							found = true;
						}
						break;
					case "EVMKT":
						if (check_data[i].ev_mkt_id == data_id) {
							found = true;
						}
						break;
					case "EVOC":
						if (check_data[i].ev_oc_id == data_id) {
							found = true;
						}
						break;
					default:
						// Nothing.
				}
			}
		}

		// If this is not found, we must continue.
		if (!found) {

			// Remove the html at the highest level.
			if (check_level == current_level) {
				// Remove the html.
				scitem_id = handler.getIdPrefix(hier_level[check_level]) + data_id;
				if (scone_item_exists(scitem_id)) {
					scone_remove_item(scitem_id);
				}
			}

			if (info_hash[data_id]) {

				// Limit the level to which we recurse.
				if (recursion_level < max_recursion_level) {

					push_hash_prune_drilldown_recurse(
						handler,
						recursion_level + 1,
						max_recursion_level,
						current_level + 1,
						check_level,
						check_data,
						data_id
					);
				}

				// Delete the data from its hash if applicable. Only levels higher or
				// equal to that of check_level.
				if (current_level >= check_level) {
					delete info_hash[data_id];
				}
			}
		}
	}

	return;
}

// Format a price.
function get_price_str (handler, lp_num, lp_den, lp_avail, mkt_sort) {

	var handler_config = handler.getConfig();

	if (typeof lp_avail == "undefined") {
		lp_avail = "Y";
	}

	if (typeof mkt_sort == "undefined") {
		mkt_sort = "--";
	}

	var price_str_type = handler_config.price_str_type;

	if ( mkt_sort == "AH" && handler_config.price_str_type_ah != "") {
		price_str_type = handler_config.price_str_type_ah;
	}

	if ( mkt_sort == "HL" && handler_config.price_str_type_hl != "") {
		price_str_type = handler_config.price_str_type_hl;
	}

	if (lp_avail == "N") {
		return "SP";
	}

	if (lp_num == "" && lp_den == "") {
		return "-";
	}

	var price_str;

	if (price_str_type == "DECIMAL") {

		var dps = (lp_den > 100) ? 3 : 2;
		var dp = 1.0 + (lp_num / lp_den);
		var scaled_dp = "" + Math.round(dp * Math.pow(10,dps) - 0.5);
		var int_part  = scaled_dp.substr(0, scaled_dp.length - dps);
		var frac_part = scaled_dp.substr(scaled_dp.length - dps);
		if (int_part  == "") int_part  = "";
		if (frac_part == "") frac_part = "";
		var price_str = int_part + "." + frac_part;
	} else {

		if (lp_den == "") {
			lp_den = 1;
		}

		if (lp_num == lp_den) {
			price_str = "evens";
		} else {
			price_str = lp_num + handler_config.price_str_sep + lp_den;
		}
	}

	return price_str;
}

// A generic object to provide default class/type/event etc comparison functions.
function push_hash_cmp_objects() {
	return;
}

/*
** Although these are all similar and can combined into a single generic function,
** I'm deliberately not doing so, so that they can be customised per instance used,
** should the logic need to change slightly. An example of this would be the
** comparison of events in lb_cal_live.js where we must order first by start time,
** as opposed to disporder.
*/
push_hash_cmp_objects.prototype.cmpClasses = function (cmpMode, classA, classB) {

	var d = classA.disporder - classB.disporder;

	if (d) {
		return d;
	}

	return classA.ev_class_id - classB.ev_class_id;
}

push_hash_cmp_objects.prototype.cmpTypes = function (cmpMode, typeA, typeB) {

	var d = typeA.disporder - typeB.disporder;

	if (d) {
		return d;
	}

	return typeA.ev_type_id - typeB.ev_type_id;
}

push_hash_cmp_objects.prototype.cmpEvents = function (cmpMode, evA, evB) {

	var d = evA.disporder - evB.disporder;

	if (d) {
		return d;
	}

	return evA.ev_id - evB.ev_id;
}

push_hash_cmp_objects.prototype.cmpEvMkts = function (cmpMode, mktA, mktB) {

	var d = mktA.disporder - mktB.disporder;

	if (d) {
		return d;
	}

	return mktA.ev_mkt_id - mktB.ev_mkt_id;
}

push_hash_cmp_objects.prototype.cmpSelcns = function (cmpMode, selcnA, selcnB) {

	var d = selcnA.disporder - selcnB.disporder;

	if (d) {
		return d;
	}

	if (selcnA.lp_num && !selcnB.lp_num) {
		return -1;
	} else if (!selcnA.lp_num && selcnB.lp_num) {
		return +1;
	} else if (selcnA.lp_num && selcnB.lp_num) {
		o = (selcnA.lp_num * selcnB.lp_den) - (selcnA.lp_den * selcnB.lp_num);

		if (o) {
			return o;
		}
	}

	return selcnA.ev_oc_id - selcnB.ev_oc_id;
}

/*
** Called when the price of a selection may have changed; will bring
** change to the attention of the user.
*/
function push_highlight_price_change(
	handler,
	ev_oc_id,
	lp_num,
	lp_den,
	old_lp_num,
	old_lp_den
) {

	if (isNaN(lp_num) || isNaN(old_lp_num)) {
		return;
	}

	var d = lp_num * old_lp_den - lp_den * old_lp_num;

	if (d == 0) {
		return;
	}

	var price_id = handler.getIdPrefix("SELCN_HL") + ev_oc_id;

	push_highlight(handler, price_id, handler.getMiscInfo("PRICE_CLASS_NAME"), d);

	return;
}

/*
 * Called when the level for a selection may have changed; will bring
 * change to the attention of the user.
 */
function push_highlight_level_change(
	handler,
	ev_oc_id,
	old_hcap_str,
	new_hcap_str
) {

	if (old_hcap_str == new_hcap_str) {
		return;
	}

	var old_hcap = _bir_extract_hcap(old_hcap_str);
	var new_hcap = _bir_extract_hcap(new_hcap_str);

	if (old_hcap == new_hcap) {
		return;
	}

	var level_container  = handler.getIdPrefix("LEVEL_CONTAINER");
	var level_id         = level_container + ev_oc_id;
	var level_class_name = handler.getMiscInfo("LEVEL_CLASS_NAME");

	push_highlight(handler, level_id, level_class_name, new_hcap - old_hcap);
}

// Extract handicap value from a string (by removing parentheses).
function _bir_extract_hcap(hcap_str) {
	return hcap_str.replace(/[ ()]/g,'');
}

/*
** Highlight a change to an element by giving it base_class + "red"
** if dir is negative, or base_class + "blue" if positive, or unhighlight
** it if dir is zero. The highlight is removed after a time interval.
*/
function push_highlight(
	handler,
	id,
	base_class,
	dir
) {

	var el = document.getElementById(id);

	if (!el) {
		return;
	}

	var highlight_class = "";
	var handler_config  = handler.getConfig();

	if (dir < 0) {
		highlight_class = base_class + handler_config.hl_class_decrease;
	} else if (dir > 0) {
		highlight_class = base_class + handler_config.hl_class_increase;
	} else {
		highlight_class = base_class + handler_config.hl_class_same;
	}

	var classes = el.className.split(" ");
	var found   = false;

	for (var i = 0; i < classes.length; i++) {
		if (classes[i] == base_class + handler_config.hl_class_same     ||
		    classes[i] == base_class + handler_config.hl_class_increase ||
		    classes[i] == base_class + handler_config.hl_class_decrease
		) {
			classes[i] = highlight_class;
			found = true;
			break;
		}
	}

	if (!found) {
		classes.push(highlight_class);
	}

	el.className = classes.join(" ");

	var timeout_info = handler.getHash("HL_TIMERS");

	if (timeout_info[id] != null) {
		window.clearTimeout(timeout_info[id]);
		delete timeout_info[id];
	}

	var self = this;

	if (dir != 0) {
		timeout_info[id] = window.setTimeout(function(){self.push_highlight(handler, id, base_class, 0)}, handler_config.highlight_duration);
	}

	return;
}

function push_schedule_unhighlight_new_item(handler, type, id) {

	var handler_config = handler.getConfig();
	var self = this;

	window.setTimeout(function(){self.push_unhighlight_new_item(handler, type, id)}, handler_config.highlight_duration);
}

function push_unhighlight_new_item(handler, type, id) {

	var label = document.getElementById(handler.getIdPrefix("NEW_ITEM") + type + "_" + id);

	if (label) {
		label.style.display = "none";
	}
}

function push_get_ev_counts(handler, type, id) {

	var count = handler.getHash("EV_COUNT")[type+id];

	if(!count) {
		return 0;
	} else {
		return count;
	}
}

/*
** Add a bet selection to the slip.
*/
function bir_add_bet(handler, ev_oc_id, origin) {

	var selcn = handler.getHashId("EVOC", ev_oc_id);
	var evmkt = handler.getHashId("EVMKT", selcn.ev_mkt_id);

	BS_set_leg("selections",  ev_oc_id);
	BS_set_leg("price_type",  "L");
	BS_set_leg("lp_num",      selcn.lp_num);
	BS_set_leg("lp_den",      selcn.lp_den);
	BS_set_leg("hcap_value",  evmkt.raw_hcap);
	BS_set_leg("bir_index",   evmkt.bir_index);
	BS_set_leg("market_tags", "");

	if (origin != "") {
		BS_set_leg("bet_origin", origin);
	}

	BS_go_bet();

	return;
}

/*
 * Called whenever we receive any published message from the Push Server.
 */
function bir_got_msg(handler, msg) {

	var data = {};

	switch(msg.subject_level) {

		case "sPRICE":

			eval("data = " +  msg.data + ";");
			data.ev_oc_id = msg.subject_id;
			handler.gotPushData("PRICE", data);
			break;

		case "sSELCN":

			eval("data = " +  msg.data + ";");
			data.ev_oc_id = msg.subject_id;
			handler.gotPushData("SELCN", data);
			break;

		case "sMHCAP":

			eval("data = " +  msg.data + ";");
			data.ev_mkt_id = msg.subject_id;
			handler.gotPushData("MHCAP", data);
			break;

		case "sEVMKT":

			eval("data = " +  msg.data + ";");
			data.ev_mkt_id = msg.subject_id;
			handler.gotPushData("EVMKT", data);
			break;

		case "sEVENT":

			eval("data = " +  msg.data + ";");
			data.ev_id = msg.subject_id;
			handler.gotPushData("EVENT", data);
			break;
		case "sBRSCR":
			eval("data = " +  msg.data + ";");
			data.ev_id = msg.subject_id;
			handler.gotPushData("BRSCR", data);
			break;

		default:
			// presumably this msg wasn't intended for us
	}

	return;
}

function bir_update_elem (elem_id, elem_value, append) {

	var elem = document.getElementById(elem_id);

	if (!elem) {
		return;
	}

	// Replace or append?
	if (append == 1) {
		elem.innerHTML = elem.innerHTML + " " + elem_value;
	} else {
		elem.innerHTML = elem_value;
	}
}

// Used for ascending numeric array sorting.
function sortNumAsc(a, b) {
	return a - b;
}

// Display the selected tab, and hide the others.
function selectBirCalTab(tab_name, is_news) {

	var live_elem     = document.getElementById("liveNow");
	var live_elem_tab = document.getElementById("liveNowTab");
	var upc_elem      = document.getElementById("upcoming");
	var upc_elem_tab  = document.getElementById("upcomingTab");
	var fav_elem      = document.getElementById("myFavourite");
	var fav_elem_tab  = document.getElementById("myFavouriteTab");
	var filter_elem   = document.getElementById("birCalFilter");

	if (live_elem && live_elem_tab && upc_elem && upc_elem_tab && fav_elem && fav_elem_tab && filter_elem) {

		switch(tab_name) {
			case "LIVE":
				// Show the live tab; hide the others.
				if (live_elem) {
					live_elem.style.display = "";
					live_elem_tab.className = "active";
					upc_elem.style.display  = "none";
					upc_elem_tab.className  = "";
					fav_elem.style.display  = "none";
					fav_elem_tab.className  = "";

					if ($j("#"+_lb_cal_live_class_area_id).children().length === 0) {
						lb_cal_rebuild_tab(lb_cal_live_obj);
					}

					if (filter_elem.style.display == "none") {
						filter_elem.style.display = "";
					}
				}
				break;
			case "UPC":
				// Show the upcoming tab; hide the others.
				if (upc_elem) {
					upc_elem.style.display  = "";
					upc_elem_tab.className  = "active";
					live_elem.style.display = "none";
					live_elem_tab.className = "";
					fav_elem.style.display  = "none";
					fav_elem_tab.className  = "";

					if ($j("#"+_lb_cal_upc_class_area_id).children().length === 0) {
						lb_cal_rebuild_tab(lb_cal_upc_obj);
					}

					if (filter_elem.style.display == "none") {
						filter_elem.style.display = "";
					}
				}
				break;
			case "FAV":
				// Show the favourites tab; hide the others.
				if (fav_elem) {
					fav_elem.style.display    = "";
					fav_elem_tab.className    = "active";
					upc_elem.style.display    = "none";
					upc_elem_tab.className    = "";
					live_elem.style.display   = "none";
					live_elem_tab.className   = "";
					filter_elem.style.display = "none";
				}
				break;
			default:
				// Do nothing.
		}
	} else if (live_elem && live_elem_tab && upc_elem && upc_elem_tab &&  is_news == 1 && filter_elem) {


		switch(tab_name) {
			case "LIVE":

				// Show the live tab; hide the others.
				if (live_elem) {
					live_elem.style.display = "";
					live_elem_tab.className = "active";
					upc_elem.style.display  = "none";
					upc_elem_tab.className  = "";

					if ($j("#"+_lb_cal_live_class_area_id).children().length === 0) {
						lb_cal_rebuild_tab(lb_cal_live_obj);
					}

					if (filter_elem.style.display == "none") {
						filter_elem.style.display = "";
					}
				}
				break;
			case "UPC":

				// Show the upcoming tab; hide the others.
				if (upc_elem) {

					upc_elem.style.display  = "";
					upc_elem_tab.className  = "active";
					live_elem.style.display = "none";
					live_elem_tab.className = "";

					if ($j("#"+_lb_cal_upc_class_area_id).children().length === 0) {
						lb_cal_rebuild_tab(lb_cal_upc_obj);
					}

					if (filter_elem.style.display == "none") {

						filter_elem.style.display = "";
					}
				}

				break;
			default:
				// Do nothing.
		}
	}
}



// Make an AJAX request, with the ability to provide clientdata that gets
// sent on the callback
function util_make_ajax_get_request(id, url, clientdata, callback) {

	if (document.PollingAjaxHelper.checkSemaphore()) {
		// Attempt this again in 300ms.
		document.PollingAjaxHelper.setTimeout(
			id,
			function(){util_make_ajax_get_request(id, url, clientdata, callback)},
			300
		);

		return;
	}

	document.PollingAjaxHelper.aquireSemaphore();
	var req = null;
	if (window.XMLHttpRequest) {
		req = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		req = new ActiveXObject('Microsoft.XMLHTTP');
	}
	if (req) {
		req.onreadystatechange = function() {
			if (req.readyState != 4) return;
			var reqStatus;
			try {
				reqStatus = req.status;
			} catch (e) {
				reqStatus = '';
			}
			if (reqStatus != 200) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,false,'HTTP');
			} else {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,true,req.responseText);
			}
		}
		try {
			req.open('GET', url, true);
			req.send(null);
		} catch (e) {
			document.PollingAjaxHelper.releaseSemaphore();
			callback(url,clientdata,false,'UNSUPPORTED');
		}
	} else {
		document.PollingAjaxHelper.releaseSemaphore();
		callback(url,clientdata,false,'UNSUPPORTED');
	}
}



// Parses an AJAX response and splits the the data in to HTML / JavaScript
// elements. It will set the HTML and execute the JavaScript
function util_got_ajax_content(url,clientdata, ok, response) {
	var holder_el = document.getElementById(clientdata.id);
	if (ok) {

		// blank response means no new data
		if (response == "") {
			return;
		}

		var parts = _util_parse_script_tags(response);
		if (holder_el) {
			holder_el.innerHTML = parts[0];
		}
		if (parts[1].length) {
			try {
				_util_global_eval(parts[1]);
			} catch (e) {
				ok = false;
			}
		}
	}
}



// Private function used to parse a string, splitting it into HTML and
// JavaScript sections.
function _util_parse_script_tags(str) {
	var html = '';
	var js   = '';
	var i = 0;
	var state = 'HTML';
	var script_re =
	  new RegExp('<(/?)' + 'scr'+'ipt' + '([^>]*)>', 'gi');
	while ((mtch = script_re.exec(str)) != null) {
		mS = mtch.index;
		if (state == 'HTML') {
			html += str.substring(i, mS);
		} else {
			js += str.substring(i, mS) + ';\n';
		}
		var closer = mtch[1];
		var attrs  = mtch[2];
		if (closer == '/') {
			state = 'HTML';
		} else {
			if ( attrs.charAt(attrs.length - 1) != '/' &&
			     attrs.indexOf('src=') == -1 ) {
				state = 'JS';
			}
		}
		i = script_re.lastIndex;
	}
	if (state == 'HTML') {
		html += str.substring(i);
	} else {
		js += str.substring(i);
	}
	return [ html, js ];
}



// Private function used to eval JavaScript text.
var _util_global_eval = function (src) {
	if (window.execScript) {
		window.execScript(src);
		return;
	}
	var fn = function() {
		window.eval.call(window,src);
	};
	fn();
};



// Add a selection to the betslip. Supports HR bets and designed to work with
// PUSH handler objects. The bet_origin arg is an optional string used
// to record the page the bet was placed from
function util_do_bet(handler, ev_oc_id, ev_id, price_type, bet_origin) {

	var selcn = handler.selcn_hash[ev_oc_id];
	var evmkt = handler.evmkt_hash[selcn.ev_mkt_id];

	var lp_num = '';
	var lp_den = '';

	if (price_type != 'S') {
		if (evmkt.gp_avail == 'Y') {
			price_type = 'G';
		}
		lp_num = selcn.lp_num;
		lp_den = selcn.lp_den;
	}

	var ew_fac_num = '';
	var ew_fac_den = '';
	var ew_places = '';

	if (evmkt.ew_avail == 'Y') {
		ew_fac_num = evmkt.ew_fac_num;
		ew_fac_den = evmkt.ew_fac_den;
		ew_places = evmkt.ew_places;
	}

	BS_set_leg('selections',  ev_oc_id);

	BS_set_leg('price_type',  price_type);
	BS_set_leg('lp_num',      lp_num);
	BS_set_leg('lp_den',      lp_den);
	BS_set_leg('market_tags', evmkt.mkt_tags);
	BS_set_leg('ew_fac_num',  ew_fac_num);
	BS_set_leg('ew_fac_den',  ew_fac_den);
	BS_set_leg('ew_places',   ew_places);

	if (evmkt.spc_avail != undefined && evmkt.spc_avail == 'Y') {
		var spc_choice = spc.get_selected_choice_id();
		if (spc_choice != -1) {
			BS_set_leg('link_list', 'SOC-' + spc_choice);
		}
	}

	if ((typeof bet_origin != 'undefined') && (bet_origin != undefined) && (bet_origin != "")) {
		BS_set_leg('bet_origin', bet_origin);
	}

	BS_go_bet();
}



// Standard utility to normalise random numbers from Math.rand
function get_random_number(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}



// Parse a price string, which can be decimal, fractional or "evens"
// Returns the decimal price as a number
ob.util.parseCurrentPrice = function (price) {
	var decimal_re = /(\d+)\.(\d+)/;
	var fraction_re = /(\d+)\s*\/\s*(\d+)/;

	if(price.toLowerCase() === "evens") {
		return 2.0;
	} else if(decimal_re.match(price)) {
		// Price is just a floating point number.
		return parseFloat(price);
	} else if(fraction_re.match(price)) {
		// Price is a fraction.
		var parts = fraction_re.exec(price);

		var lp_num = parseInt(parts[1]);
		var lp_den = parseInt(parts[2]);

		return (lp_num / lp_den) + 1;
	}
}


/* Writing crunched file polyfill.js */
/*
 * Copyright (c) 2015 OpenBet Technologies Ltd. All rights reserved.
 *
 * Contains numerous polyfills to add new functionality to old browsers.
 * https://remysharp.com/2010/10/08/what-is-a-polyfill
 */



// Polyfill for Array.indexOf.  For Internet Explorer 8.
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		"use strict";
		if (this == null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;
		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n != n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n != 0 && n != Infinity && n != -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}



// Polyfill for Array.map.  For Internet Explorer 8.
if (!Array.prototype.map) {

	Array.prototype.map = function(callback, thisArg) {

		var T, A, k;

		if (this == null) {
			throw new TypeError(' this is null or not defined');
		}

		// 1. Let O be the result of calling ToObject passing the |this|
		//    value as the argument.
		var O = Object(this);

		// 2. Let lenValue be the result of calling the Get internal
		//    method of O with the argument "length".
		// 3. Let len be ToUint32(lenValue).
		var len = O.length >>> 0;

		// 4. If IsCallable(callback) is false, throw a TypeError exception.
		// See: http://es5.github.com/#x9.11
		if (typeof callback !== 'function') {
			throw new TypeError(callback + ' is not a function');
		}

		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
		if (arguments.length > 1) {
			T = thisArg;
		}

		// 6. Let A be a new array created as if by the expression new Array(len)
		//    where Array is the standard built-in constructor with that name and
		//    len is the value of len.
		A = new Array(len);

		// 7. Let k be 0
		k = 0;

		// 8. Repeat, while k < len
		while (k < len) {

			var kValue, mappedValue;

			// a. Let Pk be ToString(k).
			//   This is implicit for LHS operands of the in operator
			// b. Let kPresent be the result of calling the HasProperty internal
			//    method of O with argument Pk.
			//   This step can be combined with c
			// c. If kPresent is true, then
			if (k in O) {

				// i. Let kValue be the result of calling the Get internal
				//    method of O with argument Pk.
				kValue = O[k];

				// ii. Let mappedValue be the result of calling the Call internal
				//     method of callback with T as the this value and argument
				//     list containing kValue, k, and O.
				mappedValue = callback.call(T, kValue, k, O);

				// iii. Call the DefineOwnProperty internal method of A with arguments
				// Pk, Property Descriptor
				// { Value: mappedValue,
				//   Writable: true,
				//   Enumerable: true,
				//   Configurable: true },
				// and false.

				// In browsers that support Object.defineProperty, use the following:
				// Object.defineProperty(A, k, {
				//   value: mappedValue,
				//   writable: true,
				//   enumerable: true,
				//   configurable: true
				// });

				// For best browser support, use the following:
				A[k] = mappedValue;
			}
			// d. Increase k by 1.
			k++;
		}

		// 9. return A
		return A;
	};
}



// Polyfill for Array.filter.  For Internet Explorer 8.
if (!Array.prototype.filter) {
	Array.prototype.filter = function(fun/*, thisArg*/) {
	'use strict';

	if (this === void 0 || this === null) {
		throw new TypeError();
	}

	var t = Object(this);
	var len = t.length >>> 0;
	if (typeof fun !== 'function') {
		throw new TypeError();
	}

	var res = [];
	var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	for (var i = 0; i < len; i++) {
		if (i in t) {
			var val = t[i];

			// NOTE: Technically this should Object.defineProperty at
			//       the next index, as push can be affected by
			//       properties on Object.prototype and Array.prototype.
			//       But that method's new, and collisions should be
			//       rare, so use the more-compatible alternative.
			if (fun.call(thisArg, val, i, t)) {
				res.push(val);
			}
		}
	}

	return res;
	};
}



if (!Array.prototype.intersect) {
	Array.prototype.intersect = function(other) {
		'use strict';

		if (this === void 0 || this === null) {
			throw new TypeError();
		}

		var t = Object(this);
		var len = t.length >>> 0;
		if (typeof other !== 'object' || !other.indexOf) {
			throw new TypeError();
		}

		return t.filter(function(n) {
			return (other.indexOf(n) !== -1);
		});
	};
}



// Polyfill Math.sign for older browsers
Math.sign = Math.sign || function(x) {
	x = +x; // convert to a number
	if (x === 0 || isNaN(x)) {
		return x;
	}
	return x > 0 ? 1 : -1;
};



// Fix for IE, adds getComputedStyle method for the object window and
// getPropertyValue method for the object, which returns getComputedStyle
if (!window.getComputedStyle) {
	window.getComputedStyle = function(el, pseudo) {
		this.el = el;

		this.getPropertyValue = function(prop) {
			var re = /(\-([a-z]){1})/g;
			if (prop == 'float'){
				prop = 'styleFloat';
			}
			if (re.test(prop)) {
				prop = prop.replace(re, function () {
					return arguments[2].toUpperCase();
				});
			}

			return el.currentStyle[prop] ? el.currentStyle[prop] : null;
		}
		return this;
	};
}



// Similar to the above but for string.trim which doesn't exist in early versions
// of IE
if(!String.prototype.trim) {
	String.prototype.trim = function () {
		return this.replace(/^\s+|\s+$/g,'');
	};
}

/* Writing crunched file global.js */
/*
 * Copyright (c) 2006 Orbis Technology Ltd. All rights reserved.
 *
 * This file contains statically loaded javascript, used throughout the site.
 */



// Decode any \uXXXX sequences in a string into characters represented
// by Unicode codepoints with hex XXXX.
function unicode_unescape (str) {

	if (str == null) {
		return;
	}
	var rslt = '';
	// Look for sequences of the form \uXXXX.
	var re = /\\u([0-9A-Fa-f]{4})/g;
	var mtch;
	var prev_mtch = 0;
	while ((mtch = re.exec(str)) != null) {
		rslt += str.substring(prev_mtch, mtch.index);
		var hex_codepoint = mtch[1];
		rslt += String.fromCharCode(parseInt(hex_codepoint,16));
		prev_mtch = re.lastIndex;
	}
	rslt += str.substring(prev_mtch);
	return rslt;
}



// open a window
//
function open_window(url, name, width, height, resizable, scrollbars) {

	var w = window.screen.width;
	var h = window.screen.height;

	if(width > w) {
		width = w / 2;
	}
	if(height > h) {
		height = h / 2;
	}

	var new_window = window.open(url, name,
		"resizable=" + resizable +
		",scrollbars=" + scrollbars +
		",width=" + width +
		",height=" + height +
		",status=yes");
	new_window.focus();
	new_window.opener = window;
}



// get a cookie
//
function get_cookie(name) {
	var c = document.cookie;
	if (c.length == 0) return '';

	// Search for this cookie name
	// valid cookie syntax is defined here by the regexp
	var reg_exp = "(^|[\\s;])" + name + "=";

	// Check for duplicate cookies for specific subset of cookies
	switch (name) {
		case "PPBETLEG":
		case "PPBETLEGFORMAT":
		case "PPBETMULTI":
		case "PPBETRECEIPT":
		case "CUM_STK":
			// We need to check how many copies of a cookie exist
			var reg_exp2 = new RegExp(reg_exp,"g");
			var matches = c.match(reg_exp2);
			if (matches != null && matches.length > 1) {
				var date = new Date(1);
				set_cookie(name,"",date,"/",cookie_domain);
				c = document.cookie;
			}
	}

	var start = c.search(reg_exp);
	if (start == -1) return '';

	if (start == 0) {
		start += name.length + 1;
	} else {
		start += name.length + 2;
	}
	var end = c.indexOf(';',start);
	if (end == -1) end = c.length;
	return c.substring(start,end);
}

// set a cookie
//
function set_cookie(name, value, expires, path, domain, secure) {

	if (!domain) {
		domain = cookie_domain;
	}

	var curCookie = name + '=' + value +
		((expires) ? '; expires=' + expires.toGMTString() : '') +
		((path) ? '; path=' + path : '') +
		((domain) ? '; domain=' + domain : '') +
		((secure) ? '; secure' : '');

	document.cookie = curCookie;
}



// get value from the query string
//
function get_arg( name ) {

	var regexS  = "[\\?&]" + name + "=([^&#]*)";
	var regex   = new RegExp( regexS );
	var tmpURL  = window.location.href;
	var results = regex.exec( tmpURL );

	if( results == null ) {
		return "";
	} else {
		return results[1];
	}

}



// Better version of the above that returns all args and takes care of encoded
// arguments and values too. Returns an object of all URL arguments.
function getQueryParams(qs) {

	var qs = document.location.search.split("+").join(" ");

	var params = {}, tokens,
		re = /[?&]?([^=]+)=([^&]*)/g;

	while (tokens = re.exec(qs)) {
		params[decodeURIComponent(tokens[1])]
			= decodeURIComponent(tokens[2]);
	}

	return params;
}



// get a customer preference
function get_pref(name) {

	var c = get_cookie(prefs_cookie_name);
	// Is this a persistent cookie?
	for (var i = 0; i < prefs_persistent_cookie_params.length; i++) {
		if (prefs_persistent_cookie_params[i] == name) {
			c = get_cookie('P_' + prefs_cookie_name);
		}
	}

	var r = new RegExp('^(?:.*\\|)?' + name + '=([^|]*)');
	var m = c.match(r);
	return (m ? m.pop() : null)
}

// set a customer preference
function set_pref(name, value) {

	var c_name = prefs_cookie_name;

	if (prefs_persistent_cookie_params.indexOf(name) != -1) {
		var c_name = 'P_' + prefs_cookie_name;
		var c_expiry = new Date();
		//expires in a year, that is 31536000 seconds
		c_expiry.setTime(c_expiry.getTime()+31536000);
	} else {
		var c_expiry = '';
	}

	var c_data = get_cookie(c_name);

	c_data = remove_key(c_data, name);
	if (value && value != '') {
		c_data = append_key(c_data, name, value);
	}

	if (name != 'update') {
		if (appears_logged_in()) {
			if (c_name == prefs_cookie_name) {
				c_data = set_key(c_data, 'update', 1);
			} else {
				//persistent cookie, set update field of the non persistent cookie to 1
				set_cookie(prefs_cookie_name,set_key(get_cookie(prefs_cookie_name),'update',1),c_expiry,'/');
			}
		}
	}

	set_cookie(c_name,c_data,c_expiry,'/');
}

// check if a user appears to have logged in
function appears_logged_in() {

	var session_id = get_cookie(login_cookie_name);

	if(session_id != null && session_id != "") {
		return true;
	}

	return false;
}

// Adds a key value pair to a string
// Replaces the old one if it already exists
// Not in-place
// returns the modified string
function set_key(str, name, value) {
	var new_str = remove_key(str, name);
	new_str = append_key(new_str, name, value);
	return new_str;
}

// appends a key value pair to a str
// does not check for duplicates keys
// returns the modified string
function append_key(str, name, value) {
	var pair = name + '=' + value;
	return (str.length == 0 ? pair : str + '|' + pair);
}

// removes a key value pair from a pipe separated string of pairs
// returns the modified string
function remove_key(str, name) {
	var r = new RegExp('^(.*\\|)?' + name + '=[^|]*(.*)$');
	var new_str = str;

	var m = new_str.match(r);
	while (m) {
		var h = m[1];
		var t = m[2];
		if (h == null || h.length == 0) {
			new_str = t.substring(1);
		} else if (t.length == 0) {
			new_str = h.substring(0, h.length-1);
		} else {
			new_str = h + t.substring(1);
		}
		m = new_str.match(r);
	}

	return new_str;
}

// get user-agent
//
var BrowserDetect = function() {

	// Copied from quirksmode.org as freely available code:
	// http://www.quirksmode.org/js/detect.html
	// Will probably need to be updated now and then
	var _detect = {
		init: function () {
			this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
			this.version = this.searchVersion(navigator.userAgent)
				|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.OS = this.searchString(this.dataOS) || "an unknown OS";
		},
		searchString: function (data) {
			for (var i=0;i<data.length;i++) {
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				this.versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString) {
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		},
		searchVersion: function (dataString) {
			//fix for IE9 compatible mode
			if (this.browser=="IE" && dataString.indexOf("Trident/5.0") != -1) {
				return parseFloat(9);
			}
			var index = dataString.indexOf(this.versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
		},
		dataBrowser: [
			{
				string: navigator.userAgent,
				subString: "Edge",
				versionSearch: "Edge",
				identity: "Edge"
			},
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{
				string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera",
				versionSearch: "Version"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "FF",
				versionSearch: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{ // for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "IE",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "rv:11.0",
				identity: "IE",
				versionSearch: "rv"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{ // for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		],
		dataOS : [
			{
				string: navigator.platform,
				subString: "Win",
				identity: "Windows"
			},
			{
				string: navigator.platform,
				subString: "Mac",
				identity: "Mac"
			},
			{
				string: navigator.userAgent,
				subString: "iPhone",
				identity: "iPhone/iPod"
			},
			{
				string: navigator.platform,
				subString: "Linux",
				identity: "Linux"
			}
		]
	}

	_detect.init();

	return {
		browser: _detect.browser,
		version: _detect.version,
		OS:      _detect.OS
	}

}();


// fraction to decimal conversion
//
function frac_to_dec(num, den) {

	var p = num + "/" + den;

	if(p == "13/8") {
		return 2.62;
	}
	if(p == "15/8") {
		return 2.87;
	}
	if(p == "11/8") {
		return 2.37;
	}
	if(p == "8/13") {
		return 1.61;
	}
	if(p == "2/7") {
		return 1.28;
	}
	if(p == "1/8") {
		return 1.12;
	}

	// Support Fix 40830
	// Here the fraction decimal convertion synchronized with that
	// of shared_tcl's util.tcl (get_price_str) procedure.

	if (den > 100) {
		return ((parseFloat(num) / parseFloat(den)) + 1.00).toFixed(3);
	} else {
		return ((parseFloat(num) / parseFloat(den)) + 1.00).toFixed(2);
	}

}


// fraction string (e.g 10/1) to decimal conversion
//
function frac_str_to_dec(str) {

	var split_str = str.split("/");
	var num = split_str[0];
	var den = split_str[1];

	return frac_to_dec(num, den);
}


// Format the price based on the customer price type preference
//
function format_price(lp_num,lp_den) {

	if (lp_num == lp_den) {
		return xl_evens
	}

	var price_type = get_pref('PRICE_TYPE');

	if (price_type == 'DECIMAL') {
		return frac_to_dec(lp_num,lp_den);
	}
	return lp_num + odds_sep + lp_den;
}


// Highest common factor (aka gcd)
//
function hcf(a,b) {

	if (b == 0) {
		return a;
	}

	return hcf(b, a%b);

}

// Lowest common multiple
//
function lcm(a,b) {

	return (a*b / hcf(a,b));

}


// Convert a form's content into a request parameter string which can be
// used with an XMLHttpRequest e.g. Given a form like:
//
// <form name="betSlipForm">
//   <input type="hidden" name="action" value="GoBetSlip">
//   <input type="text" name="username" value="misterx">
// </form>
//
// getFormContent("betSlipForm") should return:
//
//   'action=GoBetSlip&username=misterx'
//
// We treat checkboxes as a special case.  We only add the checkbox element's
// name/value if the checkbox is checked.
function getFormContent(form) {
	var f = document.forms[form];
	var n = f.elements.length;
	var content = '';
	var name, value, fi;

	for (var i=0; i<n; i++) {
		fi = f.elements[i];
		name = fi.name;
		value = fi.value;
		if (name == '') continue;
		if (fi.type == 'checkbox' && !fi.checked) continue;
		content = content + name + '=' + value + '&';
	}
	return content;
}



function ieDropDownFix () {
	var uls=document.getElementsByTagName("ul");
	var ul,li,lis,num;
	var i=uls.length-1

	if (i == -1) return;
	do {
		if(uls[i].className=="dd-mkt"||uls[i].className=="dd-tv"||uls[i].className=="i") {
			li=uls[i].getElementsByTagName("li");
			li[0].onmouseover = function() {
				this.className+=" sfhover";
				this.style.zIndex="99"
			}
			li[0].onmouseout=function() {
				this.className = this.className.replace(new RegExp(" sfhover\\b"),"");
			}
			ul=li[0].getElementsByTagName("ul");
			if (!ul.length) continue;
			lis=ul[0].getElementsByTagName("li");
			if(lis.length>10) ul[0].className+=" scroll";
		}
	} while(i--);
}

//Get Flash Player version
function getFlashVersion(){
	// ie
	try {
		try {
			var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
				try { axo.AllowScriptAccess = 'always'; }
			catch(e) { return '6,0,0'; }
		} catch(e) {}
		return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	// other browsers
	} catch(e) {
		try {
			if(navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin){
				return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
			}
		} catch(e) {}
	}
		return '0,0,0';
	}

// Superbet No Flash
function check_superbet_no_flash(reg_cnt, unreg_cnt) {
	var superbetSwf = document.getElementById('superbetSwf');
	if(getCookie('OB_Status')!= null)
	{
		superbetSwf.innerHTML = reg_cnt;
	}
	else
	{
		superbetSwf.innerHTML = unreg_cnt;
	}
}

// Highlight
function hltRow(ref) {

	var tds = ref.parentNode.getElementsByTagName("td");
	var i = tds.length;

	do {
		if (tds[i-1].style.backgroundColor == "")
			tds[i-1].style.backgroundColor = "#efefef";
		else
			tds[i-1].style.backgroundColor = "";
	} while (--i)
}

function hltAttach() {

	var main = document.getElementById('main');
	var tables = main.getElementsByTagName('table');
	var highlight = function () {hltRow(this)}
	var i = tables.length;

	if (i > 0) {

		do {
			if (tables[i-1].className.indexOf('hvr') > -1) {

				var tds = tables[i-1].getElementsByTagName('td');
				j = tds.length;

				do {
					tds[j-1].onmouseover = highlight;
					tds[j-1].onmouseout  = highlight;
				} while (--j)
			}
		} while (--i)
	}
}


/*
 All js below has been removed from left_nav.html on the app
*/

function validateNavCriteria() {
	var criteria = document.navSearch.sCriteria.value
	if (criteria ==left_nav_dummy || criteria=='') {
		alert(left_nav_enter);
	} else {
		return true;
	}
	return false;
}

function validateNavCriteriaButton() {
	if (validateNavCriteria()) document.navSearch.submit();
}

function viewAllSettings() {

	var cookie_val=get_cookie(cookie_name);

	if (appears_logged_in()) {
		html = '<a href='+url+'>'+output+'</a>';
	} else {
		html = '<a class="tipper">'+output+'<span class="tip">'+ttip+'</span></a>';
	}

	if (document.getElementById('view_all_settings_span') != null) {
		document.getElementById('view_all_settings_span').innerHTML = html;
	}
}


/*
 All js below has been removed from pp_html on the app
*/

var isIE=document.all;
var isMoz=document.getElementById;
var isNS4=document.layers;
var px=document.layers? "" : "px";

function getCookie(name)
{
	var dc = document.cookie;
	var prefix = name + "=";
	var begin = dc.indexOf("; " + prefix);
	if (begin == -1) {
		begin = dc.indexOf(prefix);
		if (begin != 0) return null;
	} else {
		begin += 2;
	}
	var end = document.cookie.indexOf(";", begin);
	if (end == -1) {
		end = dc.length;
	}
	return unescape(dc.substring(begin + prefix.length, end));
}

function deleteCookie(name, path, domain)
{
	if (getCookie(name))
	{
		document.cookie = name + "=" +
			((path) ? "; path=" + path : "") +
			((domain) ? "; domain=" + domain : "") +
			"; expires=Thu, 01-Jan-70 00:00:01 GMT";
	}
}

function drop_poker_download(){
	if (!getCookie('PP_disp_pok')) return;
	deleteCookie('PP_disp_pok','/','');
	if (!isMoz&&!isIE&&!isNS4) return;
	div_handel=(isMoz)?document.getElementById("dropin").style : isIE? document.all.dropin : document.dropin;
	div_handel.top=get_page_offset()-250+px;
	div_handel.visibility=(isMoz||isIE)? "visible" : "show"
	dropstart=setInterval("increment_position()",50);
}

function increment_position(){
	if (parseInt(div_handel.top)<50+get_page_offset()) {
		div_handel.top=parseInt(div_handel.top)+40+px;
	} else {
		clearInterval(dropstart)
	}
}

function close_poker_box(){
	div_handel.visibility="hidden";
}

function get_page_offset(){
	if (isIE){

		return (document.compatMode && document.compatMode!="BackCompat")? document.documentElement.scrollTop : document.body.scrollTop;
	} else {
		return window.pageYOffset;
	}
}

function poker_popup_fs() {
	if (document.getElementById("chk_pok_no_shw").checked) {
		window.frames['popup_blocker'].document.forms[0].submit();
	}
}

/*
The below js has been removed from pp_login.html
*/

// reuturn div from collection by classname
function get_element_by_class_name(elems,class_name) {
	var total = elems.length;
	for(var i = 0;i < total;i++) {
		if(elems[i].className == class_name) {
			return elems[i];
		}
	}
	return false;
}

// Get 'Open An Account' hyperlink element. Different path depening upon vertical. Alternative sould be to get OB to add ID to hyperlink
function get_open_account_element() {
	if (document.getElementById('top-bar_openaccount')) {
		return document.getElementById('top-bar_openaccount');
	} else {
		var channel_nav = get_element_by_class_name(document.getElementsByTagName('div'),'channel_nav');
		if(false === channel_nav) {return false;}

		var divs = channel_div.getElementsByTagName('div');
		if(divs.length > 0) {
			return get_element_by_class_name(divs[0].getElementsByTagName('a'),'btn_blue');
		}
	}
	return false;
}

// Check if the user 'appears' to be logged in
//
function check_login_details(first_time) {

	var cust_login_body  = document.getElementById('cust_login_body');
	var guest_login_body = document.getElementById('guest_login_body');
	var open_account     = get_open_account_element();
	var my_bets_num_bets = document.getElementById('my_bets_num_bets_div');
	var cust_username    = document.getElementById('cust_username');
	var loginUID         = document.getElementById('loginUID');
	var prev_req         = document.getElementById('prev_req');

	if (appears_logged_in()) {

		if (first_time) {
			// store the value of the pref in a global js var
			hide_balance_toggle = get_pref('HIDE_BALANCE');
		} else {
			// dont let an ajax request overwrite the value of the pref
			if (hide_balance_toggle != get_pref('HIDE_BALANCE')) {
				set_pref('HIDE_BALANCE', hide_balance_toggle);
			}
		}

		if(open_account && (open_account.nodeType === 1) ) {
			open_account.style.display = 'none';
		}
		cust_login_body.style.display = '';
		guest_login_body.style.display = 'none';

		// Update both login and my account messages buttons
		updateMessageButtons();

		var my_bets_num = unicode_unescape(get_pref('MY_BETS_NUM_BETS'));
		// a value of '-' indicates that my bets counting is turned off
		if (my_bets_num_bets != null && my_bets_num != '-' ) {
			my_bets_num_bets.innerHTML = '(' + my_bets_num + ')';
		}

		if (cust_username) {
			cust_username.innerHTML = unicode_unescape(get_pref('USERNAME'));
		}

		// Update the customer balance
		displayBalance();

		if (first_time) {

			var pt_cas_bal = get_pref('balance_pt_cas');
			if (cas_bal_upd_asap == 1 && (!pt_cas_bal || pt_cas_bal == "")) {
				// call immediately
				UpdateCasBalanceAjax();
			}

			var pt_live_cas_bal = get_pref('balance_pt_live_cas');
			if (cas_bal_upd_asap == 1 && (!pt_live_cas_bal || pt_live_cas_bal == "")) {
				// call immediately
				UpdateLiveCasBalanceAjax();
			}

			var pt_dt_poker_bal = get_pref('balance_pt_dt_poker');
			if (cas_bal_upd_asap == 1 && (!pt_dt_poker_bal || pt_dt_poker_bal == "")) {
				// call immediately
				UpdateDtPokerBalanceAjax();
			}

			// just schedule a call
			UpdateBalanceSchedule();

			//Schedule a call for cashout cookie update
			UpdateCashoutSchedule();

		}
	} else {

		var just_logged_out = cust_login_body.style.display == '' && guest_login_body.style.display == 'none' ? true : false;

		if(open_account && (open_account.nodeType === 1) ) {
			open_account.style.display = '';
		}
		cust_login_body.style.display = 'none';
		guest_login_body.style.display = '';

		// Update the Login_Uid
		loginUID.value = get_cookie(loginuid_cookie_name);

		if (first_time) {
			// On first load, we need to copy the prev_req from the cookie to
			// form so that the user is brought back to the same page after
			// logging in. On subsequent calls (which happen every half a second or so)
			// we will not copy the prev_req anymore. This is necessary to avoid requests
			// made in popups putting their location in the cookie.
			prev_req.value = get_cookie(pre_req_cookie_name);
		}

		if (just_logged_out) {
			window.location.reload(true);
		}
	}
}

// wrapper on UpdateBalanceAjax for use by Paddy Power web dev
function UpdateCasBalanceAjax() {
	UpdateBalanceAjax(1,0,0);
}

function UpdateLiveCasBalanceAjax() {
	UpdateBalanceAjax(0,1,0);
}

function UpdateDtPokerBalanceAjax() {
	UpdateBalanceAjax(0,0,1);
}

function UpdateAllBalanceAjax() {
	UpdateBalanceAjax(0,0,0);
}

//Balance update ajax call
function UpdateBalanceAjax(casino_bal_only, live_casino_bal_only, desktop_poker_bal_only) {

	// If on a playtech microsite send the request to custcom thirdparty as we will need to make a request
	// to playtech in order to retrieve the external balance
	if (tp_source_args.search("ptinstantcasino=1|ptdownloadcasino=1|ptlivecasino=1|ptdownloadcasino=1|ptdesktoppoker=1") == 1) {
		if (appears_logged_in() && document.location.protocol == 'https:' ) {
			var url = scgi_thirdparty_url;
		} else {
			var url = cgi_thirdparty_url;
		}
	} else {
		if (appears_logged_in() && document.location.protocol == 'https:' ) {
			var url = tld_ajax_secure;
		} else {
			var url = tld_ajax;
		}
	}

	var url = url + "?action=update_balance_ajax"+tp_source_args;

	// flag the update as casino only
	if (casino_bal_only) {
		url = url + "&casino_bal_only=1"
	} else if (live_casino_bal_only) {
		url = url + "&live_casino_bal_only=1"
	} else if (desktop_poker_bal_only) {
		url = url + "&desktop_poker_bal_only=1"
	}

	// mark as casino bal in clident data such that
	// the call back is aware
	var clientdata = {};
	clientdata.casino_bal_only        = casino_bal_only;
	clientdata.live_casino_bal_only   = live_casino_bal_only;
	clientdata.desktop_poker_bal_only = desktop_poker_bal_only;

	make_ajax_get_request("UpdateBalanceAjax", url, clientdata, UpdateBalanceCallback );
}

//callback used for UpdateBalanceAjax
function UpdateBalanceCallback( url, clientdata, ok, response ) {
	// dont reschedule the call if the callback is
	// from a casino only balance update

	if ( ok == true && response == 1 && clientdata.casino_bal_only != 1 && clientdata.live_casino_bal_only != 1 && clientdata.desktop_poker_bal_only != 1 ) {
		UpdateBalanceSchedule();
	}
}

//schedule a call to UpdateBalanceAjax
function UpdateBalanceSchedule() {
	var expiry_string = get_pref( 'balance_expiry' );
	var counter       = expiry_string.split( ',' )[1];
	counter           = parseInt(counter);

	document.PollingAjaxHelper.setTimeout(
		"UpdateBalanceSchedule",
		UpdateAllBalanceAjax,
		counter * 1000
	);
}



//Cashout update ajax call
function UpdateCashoutAjax() {

	// If the third party instance of custcom is ever ressurected then this should be changed
	// to use tld_thirdparty_secure and tld_thirdparty in the case that cas_bal_upd_asap == 1
	if (appears_logged_in() && document.location.protocol == 'https:' ) {
		var url = tld_ajax_secure;
	} else {
		var url = tld_ajax;
	}

	var url = url + "?action=update_cashout_cookie"+tp_source_args;

	var clientdata = {};

	make_ajax_get_request("UpdateCashoutAjax", url, clientdata, UpdateCashoutCallback );
}


//schedule a call to UpdateCashoutAjax
function UpdateCashoutSchedule() {
	var expiry_string = get_pref( 'cashout_expiry' );
	// No need to check for cashouts if the preference
	// is not set yet(eg before registration)
	if (expiry_string === null) {
		return;
	}
	var counter       = expiry_string.split( ',' )[1];
	counter           = parseInt(counter);

	document.PollingAjaxHelper.setTimeout(
		"UpdateCashoutSchedule",
		UpdateCashoutAjax,
		counter * 1000
	);
}

//callback used for UpdateBalanceAjax
function UpdateCashoutCallback( url, clientdata, ok, response ) {
	// dont reschedule the call if the callback is
	// from a casino only balance update

	if ( ok == true) {
		UpdateCashoutSchedule();
	}
}

// log a customer out
function do_customer_logout (fromLivebetting, url) {

	// is inline betslip visible or not?
	var bs = document.getElementById('bsScroller');
	if (bs) {
		if(bs.style.display != 'none') {
			// do nothing
		} else {
			var betslip_window = window.open('',betslipheader.popup_name,'width=300,scrollbars=1,resizable=1');
			betslip_window.close();
		}
	} else {
		// close the remote betslip if it's open
		var betslip_window = window.open('',betslipheader.popup_name,'width=300,scrollbars=1,resizable=1');
		betslip_window.close();
	}
	if(fromLivebetting == 1) {
		window.parent.location = url;
	} else {
		window.parent.location = parent.tld + "?action=logout&page_mode=" + parent.logout_pagemode;
	}
}

// open up the betslip if it's detached
function go_betslip () {
	BS_pop_out();
}

function updateMessageButtons() {
	var num_messages    = document.getElementById('num_messages_div');
	var unread_messages = document.getElementById('unread_messages_image');
	var loginMsgAnchor  = document.getElementById('loginMsgA');
	var myAcctMsgAnchor = document.getElementById('myAcctMsgA');

	var n_msgs_str = get_pref('NUMMESSAGES');
	got_msg = got_msg.replace("%s", n_msgs_str);

	// Convert cookie to a positive number or -1
	var n_msgs_int = -1;
	if ( !isNaN( parseInt( n_msgs_str ) ) ) {
		n_msgs_int = parseInt( n_msgs_str );
	}

	// This set the Message (n) in login iframe
	if (num_messages != null) {
		if (n_msgs_int > 99) {
			n_msgs_str = '99';
		}
		num_messages.innerHTML = unicode_unescape(n_msgs_str);
	}

	// Show little envelope image
	if (unread_messages != null) {
		if (n_msgs_int > 0) {
			unread_messages.style.display = '';
		} else {
			unread_messages.style.display = 'None';
		}
	}

	// Set login iframe button title
	if ( loginMsgAnchor != null ) {
		if (n_msgs_int > 0) {
			loginMsgAnchor.title = got_msg;
		} else {
			loginMsgAnchor.title = no_msg;
		}
	}

	// Set My Account button title
	if ( myAcctMsgAnchor != null ) {
		if (n_msgs_int > 0) {
			myAcctMsgAnchor.title = got_msg;
		} else {
			myAcctMsgAnchor.title = no_msg;
		}
	}
}

function displayBalance() {

	if(document.getElementById('login_cust_bal')) {
		// Balance display is switched off - to retrieve their balance
		// customers will do an AJAX call
		return
	}

	var ccy_code = '';
	if (get_pref('ccy_code') == 'EUR') {
		ccy_code = '&euro;';
	}
	if (get_pref('ccy_code') == 'GBP') {
		ccy_code = '&pound;';
	}

	// display customer balance if HIDE_BALANCE pref is ON
	if (get_pref('HIDE_BALANCE') == '1') {
		document.getElementById('cust_bal').innerHTML     = '';
		document.getElementById('show_bal').style.display = 'none';
		document.getElementById('hide_bal').style.display = 'block';
	} else {
		document.getElementById('cust_bal').innerHTML = ccy_code + get_pref('balance');
		document.getElementById('show_bal').style.display = 'block';
		document.getElementById('hide_bal').style.display = 'none';
	}
	// always display freebet balance if positive
	var fb_bal = get_pref('fb_balance');
	var fb_bal_sport = get_pref('fb_balance_sports');

	if (fb_bal > 0) {

		var fb_bal_el = document.getElementById('fb_bal');
		var show_fb_bal = document.getElementById('show_fb_bal');
		if (fb_bal_el) {
			// If it's not financials page, dispaly the entire balance
			if(!is_fin_fb_bal) {
				fb_bal_el.innerHTML = ccy_code + fb_bal;
				if (show_fb_bal) {
					show_fb_bal.style.display = 'block';
				}
			// If it's financials page, display only the sportsbook balance
			} else if(fb_bal_sport > 0) {
				fb_bal_el.innerHTML = ccy_code + fb_bal_sport;
				if (show_fb_bal) {
					show_fb_bal.style.display = 'block';
				}
			// If it's financials page and sports bookbalance is zero, set the display to none
			} else {
				if (show_fb_bal) {
					show_fb_bal.style.display = 'none';
				}
			}
		}


	} else {
		if(!is_fin_fb_bal) {
			var show_fb_bal = document.getElementById('show_fb_bal');
			if (show_fb_bal) {
				show_fb_bal.style.display = 'none';
			}
		}
	}

	var fb_bal_gp = get_pref('fb_balance_gp');

	if (fb_bal_sport > 0) {

		var freebet_sport = document.getElementById('freebet_sport');
		if (freebet_sport) {
			freebet_sport.style.display = 'block';
		}

		var fb_bal_sport_el = document.getElementById('fb_bal_sport');
		if (fb_bal_sport_el) {
			fb_bal_sport_el.innerHTML = fb_bal_sport;
			fb_bal_sport_el.style.display = 'block';
		}
	}

	if (fb_bal_gp > 0) {

		var freebet_game = document.getElementById('freebet_game');
		if (freebet_game) {
			freebet_game.style.display = 'block';
		}

		var fb_bal_gp_el = document.getElementById('fb_bal_gp');
		if (fb_bal_gp_el) {
			fb_bal_gp_el.innerHTML = fb_bal_gp;
			fb_bal_gp_el.style.display = 'block';
		}
	}

	// always display bonus balance if positive
	var hf_bal = get_pref('hf_balance');
	if (hf_bal > 0) {

		var hf_bal_el = document.getElementById('hf_bal');
		if (hf_bal_el) {
			hf_bal_el.innerHTML = ccy_code + hf_bal;
		}

		var show_hf_bal = document.getElementById('show_hf_bal');
		if (show_hf_bal) {
			show_hf_bal.style.display = 'block';
		}

	} else {

		var show_hf_bal = document.getElementById('show_hf_bal');
		if (show_hf_bal) {
			show_hf_bal.style.display = 'none';;
		}

	}

	var hf_bal_sport = get_pref('hf_balance_sports');
	var hf_bal_gp = get_pref('hf_balance_gp');

	if (hf_bal_sport > 0) {

		var hf_sport = document.getElementById('hf_sport');
		if (hf_sport) {
			hf_sport.style.display = 'block';
		}

		var hf_bal_sport_el = document.getElementById('hf_bal_sport');
		if (hf_bal_sport_el) {
			hf_bal_sport_el.innerHTML = hf_bal_sport;
			hf_bal_sport_el.style.display = 'block';
		}
	}

	if (hf_bal_gp > 0) {

		var hf_game = document.getElementById('hf_game');
		if (hf_game) {
			hf_game.style.display = 'block';
		}

		var hf_bal_gp_el = document.getElementById('hf_bal_gp');
		if (hf_bal_gp_el) {
			hf_bal_gp_el.innerHTML = hf_bal_gp;
			hf_bal_gp_el.style.display = 'block';
		}
	}

	var casino_mode = "";
	var pt_cas_bal_el = document.getElementById('ptcascust_bal');
	var pt_show_cas_bal_el = document.getElementById('show_ptcasbal');
	var pt_cas_fspin = 0;
	var pt_cas_bal = get_pref('balance_pt_cas');
	var pt_cas_bal_total = 0;

	if (pt_cas_bal && pt_cas_bal_el && pt_cas_bal != "") {
		casino_mode = "instant";
		pt_cas_bal = pt_cas_bal.split(":");
		for (var i = 0; i < pt_cas_bal.length; i+=3) {
			if (pt_cas_bal[i] == "bonus_balance" || pt_cas_bal[i] == "bonus_pending_winnings" || pt_cas_bal[i] == "ringfenced_real_balance") {
				pt_cas_bal_total += parseFloat(pt_cas_bal[i+2]);
			}
			// Check if customer has FreeSpin bonuses
			// and show or hide the icon accordingly
			if (pt_cas_bal[i] == "free_spin_balance_by_context") {
				pt_cas_fspin += parseFloat(pt_cas_bal[i+2]);

				var pt_show_cas_fs = document.getElementById('casino_fspin');
				if (pt_cas_fspin > 0 ) {
					pt_show_cas_fs.style.display = 'block';
				} else {
					pt_show_cas_fs.style.display = 'none';
				}
			}
		}

		pt_cas_bal_total = parseFloat(pt_cas_bal_total);
		pt_cas_bal_total = formatCurrency(pt_cas_bal_total,0);

		pt_cas_bal_el.innerHTML = ccy_code + pt_cas_bal_total;
	} else {

		var pt_cas_bal_el = document.getElementById('pt_live_cascust_bal');

		if (pt_cas_bal_el) {
			casino_mode = "live";

			var pt_show_cas_bal_el = document.getElementById('show_pt_live_casbal');

			var pt_lcas_bal = get_pref('balance_pt_live_cas');
			var pt_lcas_bal_total = 0;

			if (pt_lcas_bal) {

				pt_lcas_bal = pt_lcas_bal.split(":");

				for (var i = 0; i < pt_lcas_bal.length; i+=3) {
					if (pt_lcas_bal[i] == "bonus_balance" || pt_lcas_bal[i] == "bonus_pending_winnings" || pt_lcas_bal[i] == "ringfenced_real_balance") {
						pt_lcas_bal_total += parseFloat(pt_lcas_bal[i+2]);
					}
				}
			}

			pt_lcas_bal_total = parseFloat(pt_lcas_bal_total);
			pt_lcas_bal_total = formatCurrency(pt_lcas_bal_total,0);

			pt_cas_bal_el.innerHTML = ccy_code + pt_lcas_bal_total;
		}
	}

	if (pt_cas_bal_el) {
		if (pt_cas_bal_total != 0  || casino_mode == "live") {
			pt_show_cas_bal_el.style.display = 'block';
		} else {
			// check wheather customer has a freespin bonus
			if (casino_mode == "instant" && pt_cas_fspin != 0 ) {
				pt_show_cas_bal_el.style.display = 'block';
			} else {
				pt_show_cas_bal_el.style.display = 'none';
			}
		}
	}

	// display desktop poker balance
	var pt_pok_bal_el = document.getElementById('pt_pokcust_bal');
	var pt_show_pok_bal_el = document.getElementById('show_pt_pokbal');

	var pt_pok_bal = get_pref('balance_pt_dt_poker');
	var pt_pok_bal_total = 0;

	if (pt_pok_bal_el && pt_show_pok_bal_el && pt_pok_bal != "") {
		pt_pok_bal_total = parseFloat(pt_pok_bal);
		pt_pok_bal_total = formatCurrency(pt_pok_bal_total,0);

		pt_pok_bal_el.innerHTML = "&#36;" + pt_pok_bal_total;
	}

	if (pt_pok_bal_el) {
		pt_show_pok_bal_el.style.display = 'block';
	}
}

// toggle between show/hide customer balance
function toggleBalanceDisplay(){

	var pt_cas_bal_el      = document.getElementById('ptcascust_bal');
	var pt_live_cas_bal_el = document.getElementById('pt_live_cascust_bal');
	var pt_pok_bal_el      = document.getElementById('pt_pokcust_bal');

	if (get_pref('HIDE_BALANCE') == '1'){
		set_pref('HIDE_BALANCE', '0');

		hide_balance_toggle = '0';

		if (pt_cas_bal_el) {
			UpdateBalanceAjax(1,0,0);
		}
		if (pt_live_cas_bal_el) {
			UpdateBalanceAjax(0,1,0);
		}
		if (pt_pok_bal_el) {
			UpdateBalanceAjax(0,0,1);
		}
	} else {
		set_pref('HIDE_BALANCE', '1');

		hide_balance_toggle = '1';
	}

	//display balance
	displayBalance();
}


// Function to open a winner circle iRace virtual event
function open_wc_window () {

	var pp_wc_win = {};

	if (appears_logged_in()) {
		pp_wc_win = window.open(wc_video_url + "?ticket=" + get_cookie("PP_Login"),"PPWCWin","resizable=yes,scrollbars=no,status=yes,width=835,height=670");
	} else {
		pp_wc_win = window.open(wc_guest_video_url,"PPWCWin","resizable=yes,scrollbars=no,status=yes,width=580,height=670");
	}

	pp_wc_win.focus();
}


// Used by lottery pages
function genLink(link, type) {
	var url = '';
	var actionUrl = parent.tld;
	var staticUrl = document.domain;

	if (type == "action") {
		url = actionUrl + "?" + link;
	} else {
		url = staticUrl + '/' + actionUrl + '?' + link;
	}

	parent.location.href = url;

}

//Moved these here from racing.js as we will be using them all over the site now

function open_rp_window (ev_id) {
	var rp_url = video_cgi_url + "?action=go_racing_video_player&ev_id="+ev_id+"&hrplayer=1";
	var pp_rp_win = window.open(rp_url,"PPRPWin","resizable=no,scrollbars=no,status=yes,width=810,height=620");
	pp_rp_win.focus();
}

function open_etote_window () {
	var etote_url = video_cgi_url + "?action=etote_watch_live_racing";
	var pp_etote_win = window.open(etote_url,"PPETOTEWin","resizable=no,scrollbars=no,status=yes,width=600,height=500");
	pp_etote_win.focus();
}

// Scripts relating to the leftnav
function toggle_othersports() {

	if (document.getElementById("othersports_submenu").style.display == "none") {
		// Expand the Other Sports menu.
		document.getElementById("othersports_header").className = "expand";
		document.getElementById("othersports_submenu").style.display = "";
	}
	else {
		// Collapse the Other Sports menu.
		document.getElementById("othersports_submenu").style.display = "none";
		document.getElementById("othersports_header").className = "last";
	}

}

function collapse_leftnav_item(url) {

	if (document.getElementById("selected_submenu").style.display != "none") {
		// Collapse submenu
		document.getElementById("selected_submenu").style.display = "none";
		var elements = $j('.on');
		for(var i=2; i<elements.length; i++){
			elements[i].style.backgroundPosition = '0px 0px';
		}

	}
	else {
		window.document.location = url;
	}

}

// Register a page load function
function addOnloadEvent(f) {
	if (typeof f == 'function') {
		if(typeof window.addEventListener != 'undefined') {
			window.addEventListener('load', f, false);
		} else if(typeof document.addEventListener != 'undefined') {
			document.addEventListener('load', f, false);
		} else if(typeof window.attachEvent != 'undefined') {
			window.attachEvent('onload', f);
		} else {
			throw("browser does not support adding onload function.");
		}
	}
}

/* ---- Push Server Functionality (BEGIN) ---- */

/* ---- PUBLIC ---- */

/*
 * The push client API object.
 * Can only be used AFTER the onready handlers have fired.
 * See push/webclient/src/ps_client.js for API details.
*/
var ps_connect_push  = null;

/*
 * Register a callback function to be called once the page & push API are ready.
 * This CAN be called after they are ready (in which case the callback will be
 * invoked immediately).
 * The callback function will typically register a listener and subscribe
 * to channels.
*/
function ps_connect_add_onready(fn) {
	_ps_connect_required();
	if (!_ps_connect_started) {
		_ps_connect_onready_fns.push(fn);
	} else {
		fn();
	}
}

/*
 * Wrapper for ps_client_register.
 * Can be called before or after page & push are ready.
 */
function ps_connect_register(key, handler, channels, last_msg_id) {
	var fn = function () {
		ps_connect_push.ps_client_register
		  (key, handler, channels, last_msg_id);
	}
	ps_connect_add_onready(fn);
}

/*
 * Wrapper for ps_client_deregister.
 * Can be called before or after page & push are ready.
 */
function ps_connect_deregister(key) {
	var fn = function () {
		ps_connect_push.ps_client_deregister(key);
	}
	ps_connect_add_onready(fn);
}

/*
 * Wrapper for ps_client_unsubscribe.
*/

function ps_connect_unsubscribe_channels(channels) {
	var fn = function () {
		ps_connect_push.ps_client_unsubscribe(channels);
	}
	ps_connect_add_onready(fn);
}

/*
 * Wrapper for ps_client_get_last_msg_id.
 * Since it doesn't make sense to call this before a push connection has begun,
 * it will return null in that case.
*/

function ps_connect_get_last_msg_id(channel) {
	if (!_ps_connect_started) {
		return null;
	} else {
		return ps_connect_push.ps_client_get_last_msg_id(channel);
	}
}

/*
 * Left pad id with zeroes to a width of n (or 10 if not supplied).
 * Sufficiently commonly needed when preparing channel lists that
 * it's worth having here.
*/
function ps_connect_lpad_id(id, n) {
	var id = "" + id;
	if (!n) {
		n = 10;
	}
	while (id.length < n) id = "0" + id;
	return id;
}

/* ---- PRIVATE ---- */

// Element Id of the iframe holding the push iframe (typically in pp_bot.html)
var _ps_connect_iframe_id = "push_iframe";

// Array of onready functions.
var _ps_connect_onready_fns = [];

// Has anyone asked for push functionality yet?
var _ps_connect_is_required = false;

// Is the page loaded, the push API ready and the client started?
var _ps_connect_loaded   = false;
var _ps_connect_ready    = false;
var _ps_connect_started  = false;

// Someone needs a push.
function _ps_connect_required() {
	if (_ps_connect_is_required) {
		return;
	} else {
		_ps_connect_source_iframe();
		_ps_connect_is_required = true;
	}
}

// We don't source the iframe until push is needed.
function _ps_connect_source_iframe() {
	var d = document;
	var f = d.frames ? d.frames[_ps_connect_iframe_id] : d.getElementById(_ps_connect_iframe_id);
	if (!f) {
		window.setTimeout("_ps_connect_source_iframe()", 250);
	} else {
		var src = push_www_url + "/push_api.html" + "?v=" + push_version;
		if (f.location) {
			f.location.href = src;
		} else {
			f.src = src;
		}
	}
}

// Called once the page has loaded and the push API is ready.
function _ps_connect_start() {

	if (_ps_connect_started) return;

	// Set the authentication token if found.
	if (window.push_auth_token && push_auth_token.length) {
		ps_connect_push.ps_client_set_auth_token (push_auth_token);
	}

	// Add the servers defined by js_global.html
	for (var i = 0; i < push_servers.length; i += 3) {
		var server = push_servers[i + 0];
		var port   = parseInt(push_servers[i + 1]);
		var method = push_servers[i + 2];

		// When connecting over AJAX, change port depending on protocol to obey COR
		// We only do this when port is set to 80 or 443, in case a special setup is used
		if (method === "AJAX") {
			if (port === 80 && document.location.protocol === 'https:') {
				port = 443;
			} else if (port === 443 && document.location.protocol === 'http:') {
				port = 80;
			}
		}

		// Add the server
		ps_connect_push.ps_client_add_server(server, port, method);
	}

	// Call the onready handlers.
	for (var i = 0; i < _ps_connect_onready_fns.length; i++) {
		_ps_connect_onready_fns[i]();
	}

	ps_connect_push.ps_client_start();
	_ps_connect_started = true;

	return;
}

// Called when the page loads.
function _ps_connect_onload() {
	_ps_connect_loaded = true;
	if (_ps_connect_loaded && _ps_connect_ready) {
		_ps_connect_start();
	}
}

addOnloadEvent(_ps_connect_onload);

// Called by the push iframe once it's ready.
function push_ready() {

	// Record where the push iframe is.
	var d = document;
	var f = d.frames ? d.frames[_ps_connect_iframe_id] : d.getElementById(_ps_connect_iframe_id);
	ps_connect_push = f.contentWindow || f;

	/* Provided the page is also ready, start now. */
	_ps_connect_ready = true;
	if (_ps_connect_loaded && _ps_connect_ready) {
		_ps_connect_start();
	}

	return;
}

/*
 * Called on push iframe unload in an attempt to clean up anything
 * that might leak (in IE) or throw spurious errors (in FF).
*/
function push_shutdown() {
}

/* ---- Push Server Functionality (END) ---- */


function lcasino_keepalive() {
	if (appears_logged_in()) {
		if (document.location.protocol == 'http:') {
			var url = tld + '?action=do_evolution_session_check';
		}
		else {
			var url = tld_secure + '?action=do_evolution_session_check';
		}

		// No extra data and callback function is needed.
		make_ajax_get_request("lcasino_keepalive", url, {}, function(){});
	}
}

function showTab(tab){
	// Switch Tab
	var lis = document.getElementsByTagName("li");
	for(var i=0;i<lis.length;i++){
		if(lis[i].className == "on"){
			lis[i].className = "off";
		}
	}
	document.getElementById(tab + "-li").className= "on";

	//hide all divs
	document.getElementById("skills").style.display = "none";
	if (document.getElementById("yourRaces")) {
		document.getElementById("yourRaces").style.display = "none";
	}
	document.getElementById("faqs").style.display = "none";

	//display the new div
	document.getElementById(tab).style.display = "block";

	// In case of yourRace tab we should call sb_video_player::H_go_my_race_tab_ajax
	// to bind tab's info
	if (tab == "yourRaces" && $j("#yourRaces").children().length == 0) {
		if (document.location.protocol == 'http:') {
			url = video_cgi_url + '?action=go_player_my_race_tab';
		} else {
			url = video_scgi_url + '?action=go_player_my_race_tab';
		}

		make_ajax_get_request("showTab", url, {}, got_ajax_yourRaceTab_data);
	}
}


function got_ajax_yourRaceTab_data (url,clientdata, ok, response) {
	if (ok) {
		if (response == '') {
			return;
		}
		var yourRaceDiv = document.getElementById('yourRaces');
		yourRaceDiv.innerHTML = response;
	}
}


// Checks if there has been a change in the perform cookie.
// Or if the customer has just logged in.
// If this is the case AND video was not being played
// it means that we should reload the player because the
// customer may have placed a qualifying bet or simply logged in
function checkVideoCookie () {

	var logged_in = appears_logged_in();
	var time ='';
	// Try to get the cookie and if it does not exist/ is empty abort
	try {
		time = get_cookie('Perform');
	} catch(err) {
		return;
	}

	// Check if there has been a change
	if ((time == null || time == '' || parseInt(video_curr_time) == parseInt(time))
	    && (!logged_in || logged_in == video_was_logged_in)) {
		video_was_logged_in = logged_in;
		return;
	}

	// Update login status
	video_was_logged_in = logged_in;

	// Update video cookie
	if (time != null) {
		video_curr_time = time;
	}

	// Do these inside try blocks since some of the variables may not exist
	var condition = 0;
	// Should we reload the media center/ horse racing player?
	try {
		if ( lb_playing_video != undefined
		     && lb_playing_video != 1 && logged_in ) {
			condition = 1;
		}
	} catch(err) {}

	if ( condition == 0 ) {
		try {
			if ( hr_player_playing_video != undefined
				 && hr_player_playing_video != 1 && logged_in ) {
				condition = 2;
			}
		} catch(err) {}
	}

	if ( condition == 0 ) {
		try {
			if ( lb_vp_playing_video != undefined
				 && lb_vp_playing_video != 1 && logged_in ) {
				condition = 3;
			}
		} catch(err) {}
	}

	var ev_id = -1;

	// Reload media center
	if ( condition == 1 ) {
		// Some new BIR pages use _lb_evt_ev_id
		if ( typeof _lb_evt_ev_id  == 'undefined' || _lb_evt_ev_id == null || _lb_evt_ev_id == "") {

			ev_id = lb_evt_ev_id;

		} else {
			// Are we in a horse racing BIR page?

			ev_id = _lb_evt_ev_id;

		}
		_media_center_schedule_reload(ev_id);

	} else if ( condition == 2 ) {

		// Refresh the media player
		_hr_player_schedule_reload(hr_player_ev_id);

	} else if (condition == 3) {
		// Refresh the video player
		lb_vp_reload_flash(lb_vp_ev_id);
	}

}
function _hr_player_schedule_reload (ev_id) {

	var delay = 2500;

	document.PollingAjaxHelper.setTimeout(
		"_hr_player_schedule_reload" + ev_id,
		function() {_hr_player_reload(ev_id);},
		delay
	);

}

function _hr_player_reload (ev_id) {
	hr_player_load(ev_id, 0);
}

function hr_player_load (ev_id, start_video) {

	var url = '';

	// Refresh the media player
	if (document.location.protocol == 'http:') {
		url = video_cgi_url + '?action=go_racing_video_player&ev_id=' + ev_id + '&refresh=1&hrplayer=1';
	} else {
		url = video_scgi_url + '?action=go_racing_video_player&ev_id=' + ev_id + '&refresh=1&hrplayer=1';
	}

	url = url + "&start_video=" + start_video;

	var clientdata = {
		id : 'hr_player_flash'
	};

	make_ajax_get_request("hr_player_load", url, clientdata, got_ajax_content_updater);
}

function _media_center_schedule_reload(ev_id) {
	var delay = 2500;

	document.PollingAjaxHelper.setTimeout(
		"_media_center_schedule_reload" + ev_id,
		function() {_media_center_reload(ev_id);},
		delay
	);
}

function _media_center_reload (ev_id) {

	media_center_load(ev_id,0);

}

function media_center_load (ev_id, start_video) {

	var url = '';
	var hr = 0;
	if (typeof _lb_evt_ev_id  != 'undefined' && _lb_evt_ev_id != null && _lb_evt_ev_id != "" && _lb_evt_cfg["bir_sort"] == "HR") hr = 1;

	// Refresh the media center
	if (document.location.protocol == 'http:') {
		url = video_cgi_url + '?action=go_betlive_media_center&ev_id=' + ev_id + '&popout=0&hr=' + hr;
	} else {
		url = video_scgi_url + '?action=go_betlive_media_center&ev_id=' + ev_id + '&popout=0&hr=' + hr;
	}

	url = url + "&start_video=" + start_video;

	var clientdata = {
		id : 'MP'
	};

	make_ajax_get_request("media_center_load", url, clientdata, got_ajax_content_updater);
}

function auto_check_video_cookie () {

	var check_interval = 1000;
	setInterval('checkVideoCookie()',check_interval);

}

/*
 ** Given an Informix datetime string, return the number of milliseconds
 */
function time_in_milliseconds(date_str) {

	return Date.parse(
		new Date (
			parseInt(date_str.substring(0, 4), 10),
			(parseInt(date_str.substring(5, 7), 10) - 1),
			parseInt(date_str.substring(8, 10), 10),
			parseInt(date_str.substring(11, 13), 10),
			parseInt(date_str.substring(14, 16), 10),
			parseInt(date_str.substring(17), 10)
		)
	);
}

function vsize(id,value){
	//alert("resizing #"+id+" to "+value+"px");
	if(typeof document.getElementById(id) != "undefined"){
		document.getElementById(id).style.height = value + "px";
	}
}

function bh_level(){

	var bharr = $j('div.bh');
	var str = "";
	for(var b=0;b<bharr.length;b++){
		var n = bharr[b];
		var npp = bharr[b+1];
		if(n.className.indexOf("left") > 0) {
			npp = $j(n).nextAll('div')[0]; // capture any div to the right if it is a left (widgets etc.)
		}

		if(npp && n.className.indexOf("left") > 0 && npp.className.indexOf("right") > 0) { // if there is a left, it will have a corresponding right to be matched
			var diff = $j(n).height() - $j(npp).height();

			if(diff > 0){ // lengthen the box on the right
				expander = $j("#"+npp.id+" .exp")[0];
			}else if(diff < 0){ //lengthen the box on the left
				expander = $j("#"+n.id+" .exp")[0];
			}

			if(diff != 0 && expander != undefined) {
				var mp = 0;
				expander.style.height = String($j(expander).height() + Math.abs(diff) - mp) + "px";
				expander.style.paddingTop = "0";
				expander.style.paddingBottom = "0";
			}
		}
	}
}



function bookmarkpaddy(){
	title = "Paddy Power";
	url = "http://www.paddypower.com/bet?area=bookmark";

	if ( window.sidebar ) { // Mozilla Firefox Bookmark
		window.sidebar.addPanel(title,url,"");
	} else if ( window.external ) { // IE Favorite
		window.external.AddFavorite(url,title);
	} else if ( window.opera && window.print ) { // Opera Hotlist
		return true;
	}
}


var global_eval = function (src) {
	if (window.execScript) {
		window.execScript(src);
		return;
	}
	var fn = function() {
		window.eval.call(window,src);
	};
	fn();
};

function make_ajax_get_request(id, url, clientdata, callback) {

	if (document.PollingAjaxHelper.checkSemaphore()) {
		// Attempt this again in 300ms.
		document.PollingAjaxHelper.setTimeout(
			id,
			function(){make_ajax_get_request(id, url, clientdata, callback)},
			300
		);
		return;
	}

	document.PollingAjaxHelper.aquireSemaphore();
	var req = null;
	if (window.XMLHttpRequest) {
		req = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		req = new ActiveXObject('Microsoft.XMLHTTP');
	}
	if (req) {
		req.onreadystatechange = function() {
			if (req.readyState != 4) return;
			var reqStatus;
			try {
				reqStatus = req.status;
			} catch (e) {
				reqStatus = '';
			}
			if (reqStatus != 200) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,false,'HTTP');
			} else {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,true,req.responseText);
			}
		}
		try {
			req.open('GET', url, true);
			req.send(null);
		} catch (e) {
			document.PollingAjaxHelper.releaseSemaphore();
			callback(url,clientdata,false,'UNSUPPORTED');
		}
	} else {
		document.PollingAjaxHelper.releaseSemaphore();
		callback(url,clientdata,false,'UNSUPPORTED');
	}
}

function got_ajax_content_updater (url,clientdata, ok, response) {
	var holder_el = document.getElementById(clientdata.id);
	if (ok) {

		// blank response means no new data
		if (response == "") {
			return;
		}

		var parts = parse_script_tags(response);
		if (holder_el) {
			holder_el.innerHTML = parts[0];
		}
		if (parts[1].length) {
			try {
				global_eval(parts[1]);
			} catch (e) {
				ok = false;
			}
		}
	}
}

function parse_script_tags(str) {
	var html = '';
	var js   = '';
	var i = 0;
	var state = 'HTML';
	var script_re =
	  new RegExp('<(/?)' + 'scr'+'ipt' + '([^>]*)>', 'gi');
	while ((mtch = script_re.exec(str)) != null) {
		mS = mtch.index;
		if (state == 'HTML') {
			html += str.substring(i, mS);
		} else {
			js += str.substring(i, mS) + ';\n';
		}
		var closer = mtch[1];
		var attrs  = mtch[2];
		if (closer == '/') {
			state = 'HTML';
		} else {
			if ( attrs.charAt(attrs.length - 1) != '/' &&
			     attrs.indexOf('src=') == -1 ) {
				state = 'JS';
			}
		}
		i = script_re.lastIndex;
	}
	if (state == 'HTML') {
		html += str.substring(i);
	} else {
		js += str.substring(i);
	}
	return [ html, js ];
}

// poll_betslip_display_check and _determine_betslip_display are here because
// they cannot be called from the betslip code (because the purpose is that they
// run for the inline betslip, but not the pop out betslip).
//
// Periodically called _determine_betslip_display to ensure the Attached betslip
// isn't displayed when the pop out betslip is open.
function poll_betslip_display_check () {

	setInterval(_determine_betslip_display, 1000);
}

// Function periodically called to ensure the correct betslip is displayed.
// If the pop out betslip is active, the in page betslip should be hidden.
function _determine_betslip_display () {

	// Try to get the cookie.
	var betslip_style = get_pref("BETSLIP_STYLE");

	// If the betslip is detacted, ensure the attached betslip is hidden.
	if (betslip_style == "Detached") {

		var bs   = document.getElementById('bsScroller');
		var bshl = document.getElementById('bsHeaderLeft');
		var bsOA = document.getElementById('bsOpenAnchor');

		if (bs != null) {
			bs.style.display = 'none';

			if (bshl) bshl.style.display = 'none';
		}

		if (bshl) bshl.style.display = 'block';
		if (bsOA) bsOA.style.display = 'inline';
	}
}


// Functions for handling the MKTOFFERED cookie - this allows a user to have
// their make market sorts stay expanded/unexpanded on a particular page when
// browsing around.
// The cookie is a list of pages that have their market sorts expanded.
// Anything not here will be unexpanded. The pages are identified by the proc
// that played them (first two letters) and a string representing the arguments
// used to create that particular page. This can be a static string, a coupon id
// or a hash of a large arg list.

// Adds a page to the cookie
function addExpandedMarketPageCookie (procedure_ident, arg_ident) {

	if (!checkExpandedMarketPageCookie(procedure_ident,arg_ident)) {
		var curr_cookie = get_cookie('MKTSOFFERED');
		if (curr_cookie != "") {
			curr_cookie += "|";
		}
		var new_cookie = curr_cookie + procedure_ident + arg_ident;

		// Since there are a lot of distinct pages we run the risk of hitting
		// the 4kb cookie limit - if this happens, we remove pages from the
		// start until the cookie is small enough
		while (new_cookie.length > 4096) {
			var first_pipe = new_cookie.indexOf("|");
			new_cookie = new_cookie.substring(first_pipe+1);
		}
		set_cookie('MKTSOFFERED',new_cookie,'','/');
	}
}


// The general purpose cookie is an amalgamation of many smaller cookies
// to help get around the rather limited number of cookies allowed in certain
// browsers
var general_cookie = function() {

	var _cookie_vals = {};

	var decoded = false;

	var _decode_cookie = function() {

		// Name is defined in global_js.html
		var cookie_str = get_cookie(general_cookie_name);

		cookie_str = base64_decode(cookie_str);

		try {
			eval('_cookie_vals = '+ cookie_str );
		} catch(e) {
			_cookie_vals = {};
		}

		decoded = true;
	}

	var _write_cookie = function() {

		var cookie_str = [];
		var i = 0;

		for (name in _cookie_vals) {
			// Can't rely on JSON.stringify across all browsers, and I know of
			// no better way of doing this, so...
			cookie_str[i++] = "\""+_esc_js(name)+"\": \""+_esc_js(_cookie_vals[name])+"\"";
		}

		cookie_str = "{"+cookie_str.join(",")+"}";
		cookie_str = base64_encode(cookie_str);

		set_cookie(general_cookie_name,cookie_str,'','/');

	}

	// Escape a string so it can safely be used as a JS string literal.
	// Copied from the js template code, minus the double quotes.
	var _esc_js = function (s) {
		var p = '';
		for (var i = 0; i < s.length; i++) {
			var c = s.charAt(i);
			switch (c) {
				case '\\':
					p += '\\\\';
					break;
				case '\'':
					p += '\\\'';
					break;
				case '"':
					p += '\\"';
					break;
				case '\n':
					p += '\\n';
					break;
				case '\r':
					p += '\\r';
					break;
				default:
					p += c;
			}
		}
		return p;
	}

	var getValue = function(val_name) {

		if (!decoded) {
			_decode_cookie();
		}

		if (typeof _cookie_vals[val_name] === 'undefined') {
			return "";
		} else {
			return _cookie_vals[val_name];
		}

	}

	var setValue = function(name, value) {

		if (!decoded) {
			_decode_cookie();
		}

		// Numbers are allowed, but stored as strings. Anything else is not allowed.
		if (typeof value === 'number') {
			value = value.toString();
		}

		if (typeof value === 'string') {
			_cookie_vals[name] = value;
			_write_cookie();
		} else {
			throw("Cannot add complex values to general cookie");
		}

	}

	var forceDecode = function() {
		_decode_cookie();
	}

	return {
		getValue: getValue,
		setValue: setValue,
		forceDecode: forceDecode
	}

}();


// string base64 decode
function base64_decode (data) {
	// http://kevin.vanzonneveld.net
	// +   original by: Tyler Akins (http://rumkin.com)
	// +   improved by: Thunder.m
	// +      input by: Aman Gupta
	// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +   bugfixed by: Onno Marsman
	// +   bugfixed by: Pellentesque Malesuada
	// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +      input by: Brett Zamir (http://brett-zamir.me)
	// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// mozilla has this native
	// - but breaks in 2.0.0.12!
	//if (typeof this.window['btoa'] == 'function') {
	//    return btoa(data);
	//}
	var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
		ac = 0,
		dec = "",
		tmp_arr = [];

	if (!data) {
		return data;
	}

	data += '';

	do { // unpack four hexets into three octets using index points in b64
		h1 = b64.indexOf(data.charAt(i++));
		h2 = b64.indexOf(data.charAt(i++));
		h3 = b64.indexOf(data.charAt(i++));
		h4 = b64.indexOf(data.charAt(i++));

		bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

		o1 = bits >> 16 & 0xff;
		o2 = bits >> 8 & 0xff;
		o3 = bits & 0xff;

		if (h3 == 64) {
			tmp_arr[ac++] = String.fromCharCode(o1);
		} else if (h4 == 64) {
			tmp_arr[ac++] = String.fromCharCode(o1, o2);
		} else {
			tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
		}
	} while (i < data.length);

	dec = tmp_arr.join('');

	return dec;
}



// string base64 encoding
function base64_encode (data) {
	// http://kevin.vanzonneveld.net
	// +   original by: Tyler Akins (http://rumkin.com)
	// +   improved by: Bayron Guevara
	// +   improved by: Thunder.m
	// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +   bugfixed by: Pellentesque Malesuada
	// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +   improved by: Rafa Kukawski (http://kukawski.pl)
	// mozilla has this native
	// - but breaks in 2.0.0.12!
	//if (typeof this.window['atob'] == 'function') {
	//    return atob(data);
	//}
	var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
		ac = 0,
		enc = "",
		tmp_arr = [];

	if (!data) {
		return data;
	}

	do { // pack three octets into four hexets
		o1 = data.charCodeAt(i++);
		o2 = data.charCodeAt(i++);
		o3 = data.charCodeAt(i++);

		bits = o1 << 16 | o2 << 8 | o3;

		h1 = bits >> 18 & 0x3f;
		h2 = bits >> 12 & 0x3f;
		h3 = bits >> 6 & 0x3f;
		h4 = bits & 0x3f;

		// use hexets to index into b64, and append result to encoded string
		tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
	} while (i < data.length);

	enc = tmp_arr.join('');

	var r = data.length % 3;

	return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

}



// Function to get social media message for betslip
function get_social_media_message(provider, location, type, bet_id)
{
	var url = cgi_thirdparty_url + "?action=getSocialMediaMessage&provider=" + provider + "&location=" + location + "&type=" + type + "&bet_id=" + bet_id;

	var response;

	$j.ajax({
		url:      url,
		dataType: 'text',
		type:     'GET',
		success:  function(text) {
			response = text.replace(/&euro;/g,'').replace(/&pound/g,'');
		},
		complete:  function() {
			if (response == "ERROR") {
				if (location == "BR") {
					response = social_media_error_br;
				} else {
					response = social_media_error_bw;
				}
			}
			postSocialMediaMessage(response, provider);

		}
	});
}


// Removes a page from the cookie
function removeExpandedMarketPageCookie (procedure_ident, arg_ident) {

	if (checkExpandedMarketPageCookie(procedure_ident,arg_ident)) {
		// Treating it as an array and splicing saves messing around with
		// double/extra commas.
		var curr_cookie = get_cookie('MKTSOFFERED').split("|");
		var id_string = procedure_ident + arg_ident;
		for (i = 0; i < curr_cookie.length; i++) {
			if (curr_cookie[i] == id_string) {
				curr_cookie.splice(i,1);
				break;
			}
		}
		if (curr_cookie.length > 0) {
			set_cookie('MKTSOFFERED',curr_cookie.join("|"),'','/');
		} else {
			set_cookie('MKTSOFFERED','','','/');
		}
	}
}

function formatCurrency(amount, comma_sep) {
	var i = parseFloat(amount);
	if(isNaN(i)) { i = 0.00; }
	var minus = '';
	if(i < 0) { minus = '-'; }
	i = Math.abs(i);
	i = parseInt((i + .005) * 100);
	i = i / 100;
	s = new String(i);
	if(s.indexOf('.') < 0) {
		s += '.00';
	}
	if(s.indexOf('.') == (s.length - 2)) {
		s += '0';
	}
	s = minus + s;
	// Do formatComma unless explicitly told otherwise
	if(typeof comma_sep == "undefined" || comma_sep != 0) {
		return formatComma(s);
	} else {
		return s;
	}
}

function formatComma(amount) {
	var delimiter = ","; // replace comma if desired
	var a = amount.split('.',2)
	var d = a[1];
	var i = parseInt(a[0]);
	if(isNaN(i)) { return ''; }
	var minus = '';
	if(i < 0) { minus = '-'; }
	i = Math.abs(i);
	var n = new String(i);
	var a = [];
	while(n.length > 3)
	{
		var nn = n.substr(n.length-3);
		a.unshift(nn);
		n = n.substr(0,n.length-3);
	}
	if(n.length > 0) { a.unshift(n); }
	n = a.join(delimiter);
	if(d.length < 1) { amount = n; }
	else { amount = n + '.' + d; }
	amount = minus + amount;
	return amount;
}

// Checks the existance of a page in the cookie
// Returns true/false
function checkExpandedMarketPageCookie (procedure_ident, arg_ident) {

	var cookie = get_cookie('MKTSOFFERED');
	var id_string = procedure_ident + arg_ident;
	return (cookie.indexOf(id_string)!=-1);

}

var TINY={};

function T$(i){return document.getElementById(i)}

TINY.box=function(){
	var p,m,b,fn,ic,iu,iw,ih,ia,f=0;
	return{
		show:function(c,u,w,h,a,t){
			if(!f){
				p=document.createElement('div'); p.id='tinybox';
				m=document.createElement('div'); m.id='tinymask';
				b=document.createElement('div'); b.id='tinycontent';
				document.body.appendChild(m); document.body.appendChild(p); p.appendChild(b);
				m.onclick=TINY.box.hide; window.onresize=TINY.box.resize; f=1
			}
			if(!a&&!u){
				p.style.width=w?w+'px':'auto'; p.style.height=h?h+'px':'auto';
				p.style.backgroundImage='none'; b.innerHTML=c
			}else{
				b.style.display='none'; p.style.width=p.style.height='100px'
			}
			this.mask();
			ic=c; iu=u; iw=w; ih=h; ia=a; this.alpha(m,1,80,3);
			if(t){setTimeout(function(){TINY.box.hide()},1000*t)}
		},
		fill:function(c,u,w,h,a){
			if(u){
				p.style.backgroundImage='';
				var x=window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject('Microsoft.XMLHTTP');
				x.onreadystatechange=function(){
					if(x.readyState==4&&x.status==200){TINY.box.psh(x.responseText,w,h,a)}
				};
				x.open('GET',c,1); x.send(null)
			}else{
				this.psh(c,w,h,a)
			}
		},
		psh:function(c,w,h,a){
			if(a){
				if(!w||!h){
					var x=p.style.width, y=p.style.height; b.innerHTML=c;
					p.style.width=w?w+'px':''; p.style.height=h?h+'px':'';
					b.style.display='';
					w=parseInt(b.offsetWidth); h=parseInt(b.offsetHeight);
					b.style.display='none'; p.style.width=x; p.style.height=y;
				}else{
					b.innerHTML=c
				}
				this.size(p,w,h)
			}else{
				p.style.backgroundImage='none'
			}
		},
		hide:function(){
			TINY.box.alpha(p,-1,0,3)
		},
		resize:function(){
			TINY.box.pos(); TINY.box.mask()
		},
		mask:function(){
			m.style.height=TINY.page.total(1)+'px';
			m.style.width=''; m.style.width=TINY.page.total(0)+'px'
		},
		pos:function(){
			var t=(TINY.page.height()/2)-(p.offsetHeight/2); t=t<10?10:t;
			p.style.top=(t+TINY.page.top())+'px';
			p.style.left=(TINY.page.width()/2)-(p.offsetWidth/2)+'px'
		},
		alpha:function(e,d,a){
			clearInterval(e.ai);
			if(d==1){
				e.style.opacity=0; e.style.filter='alpha(opacity=0)';
				e.style.display='block'; this.pos()
			}
			e.ai=setInterval(function(){TINY.box.ta(e,a,d)},20)
		},
		ta:function(e,a,d){
			var o=Math.round(e.style.opacity*100);
			if(o==a){
				clearInterval(e.ai);
				if(d==-1){
					e.style.display='none';
					e==p?TINY.box.alpha(m,-1,0,2):b.innerHTML=p.style.backgroundImage=''
				}else{
					e==m?this.alpha(p,1,100):TINY.box.fill(ic,iu,iw,ih,ia)
				}
			}else{
				var n=Math.ceil((o+((a-o)*.5))); n=n==1?0:n;
				e.style.opacity=n/100; e.style.filter='alpha(opacity='+n+')'
			}
		},
		size:function(e,w,h){
			e=typeof e=='object'?e:T$(e); clearInterval(e.si);
			var ow=e.offsetWidth, oh=e.offsetHeight,
			wo=ow-parseInt(e.style.width), ho=oh-parseInt(e.style.height);
			var wd=ow-wo>w?0:1, hd=(oh-ho>h)?0:1;
			e.si=setInterval(function(){TINY.box.ts(e,w,wo,wd,h,ho,hd)},20)
		},
		ts:function(e,w,wo,wd,h,ho,hd){
			var ow=e.offsetWidth-wo, oh=e.offsetHeight-ho;
			if(ow==w&&oh==h){
				clearInterval(e.si); p.style.backgroundImage='none'; b.style.display='block'
			}else{
				if(ow!=w){var n=ow+((w-ow)*.5); e.style.width=wd?Math.ceil(n)+'px':Math.floor(n)+'px'}
				if(oh!=h){var n=oh+((h-oh)*.5); e.style.height=hd?Math.ceil(n)+'px':Math.floor(n)+'px'}
				this.pos()
			}
		}
	}
}();

TINY.page=function(){
	return{
		top:function(){return document.documentElement.scrollTop||document.body.scrollTop},
		width:function(){return self.innerWidth||document.documentElement.clientWidth||document.body.clientWidth},
		height:function(){return self.innerHeight||document.documentElement.clientHeight||document.body.clientHeight},
		total:function(d){
			var b=document.body, e=document.documentElement;
			return d?Math.max(Math.max(b.scrollHeight,e.scrollHeight),Math.max(b.clientHeight,e.clientHeight)):
			Math.max(Math.max(b.scrollWidth,e.scrollWidth),Math.max(b.clientWidth,e.clientWidth))
		}
	}
}();

/**
 * postSocialMediaMessage
 *
 */
var FB_APP_ID = '290121857670893';
function postSocialMediaMessage(msg,target) {
	if(typeof(FB) === "object" && FB._apiKey === null) {
		FB.init({appId: FB_APP_ID, status: true, cookie: true, oauth: true});
	}
	title   = 'Paddy Power Online Betting';
	url     = tld; //slip?action=GoRemoteBetslip&bs_add_leg_to_slip=1&leg=stamp~|leg_sort~|price_type~L|lp_num~10|lp_den~11|hcap_value~-17.0000|prev_lp_num~|prev_lp_den~|prev_hcap_value~|ocv_id~|bir_index~|banker~|bet_origin~|market_tags~|selections~94743161|leg_num~|disporder~|leg_type~|stake~|mult_incl~|displayed_lp_num~|displayed_lp_den~|displayed_hcap~&uid=1316611980';
	image   = '';
	switch(target) {
		case 'fbl':
			// ??
			break;
		case 'FB_LIKE':
			postToFeed(msg);
			break;
		case 'FB_SHARE': // old FB share method
			url = 'http://www.facebook.com/sharer.php?u=' + url + '&t=' + msg;
			window.open(url, 'Facebook Share', 'toolbar=0,status=0,width=548,height=325');
			break;
		case 'TWITTER':
			url = 'https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fwww.paddypower.com%2Fbet&source=tweetbutton&text=' + encodeURIComponent(msg);
			window.open(url, 'twitter', 'toolbar=0,status=0,width=548,height=325');
			break;
		default:
			url = '';
			// do nothing, unknown target
	}
}

function postToFeed(msg) {
	// calling the API ...
	var obj = {
		method: 'feed',
		link: tld,
		picture: 'http://i.ppstatic.com/content/sportsbook/social/pp-thumb.png',
		name: 'Paddy Power',
		caption: '',
		description: msg
	};

	FB.ui(obj, fb_callback);
}

function fb_callback(response) {
	document.getElementById('msg').innerHTML = "Post ID: " + response['post_id'];
}

function help_url(type, kb_name, pop)
{

	if(type == "chat")
	{
		var provider = pp_live_chat;
		var w = (provider == "ng") ? 610 : 404;
		var h = (provider == "ng") ? 500 : 606;

		if(kb_name == "" || kb_name == undefined)
		{
			var uri = help_uri_prefix + "/help/live_chat.php?p=" + provider;
		}
		else
		{
			var uri = help_uri_prefix + "/help/live_chat.php?p=" + provider + "&r=" + kb_name;
		}

		window.open(uri, '_blank', 'scrollbars=yes, resizable=no, location=no, toolbar=no, menubar=no, width=' + w + ', height=' + h);
	}
	else if(type == "kb")
	{
		var provider = pp_kb_site;
		var always_pop = (pop == undefined) ? 0 : pop;

		if(kb_name == "" || kb_name == undefined)
		{
			var uri = help_uri_prefix + "/help/help_centre.php?p=" + provider;
		}
		else
		{
			var uri = help_uri_prefix + "/help/help_centre.php?p=" + provider + "&n=" + kb_name;
		}

		if(provider == "ng" && always_pop == 0)
		{
			window.location.href = uri;
		}
		else
		{
			window.open(uri, '_blank', 'scrollbars=yes, resizable=no, location=no, toolbar=no, menubar=no, width=900, height=850');
		}
	}

	return false;
}



/*******************************************************************************************************************************************************
this function is being called from the lost username/password pages
to track the current page displayed inside the iframe

name =  no_username     the page in case the user lost his username                call location: lost_login_no_uname.html
		no_password     the page in case the user lost his password                call location: lost_login_no_pword.html
		user_confirm    the page after we send an e-mail with the lost username    call location: lost_login_email_confirm.html
		pass_confirm    the page after we send an e-mail with the lost password    call location: lost_login_pword_confirm.html
*******************************************************************************************************************************************************/
function dashboardUpdatePage(name) {
	switch (name) {

	case "lost_login":
		page_postfix="_details";
		break;

	case "user_confirm":
		page_postfix = "_lostusernameconf";
		break;

	case "pass_confirm":
		page_postfix = "_lostpasswordconf";
		break;
	}
}

// Live chat global variables
var live_chat         = new Object();

live_chat.sites       = Array();
live_chat.sites["G"]  = "games";
live_chat.sites["PK"] = "poker";
live_chat.sites["BI"] = "bingo";
live_chat.sites["DC"] = "casino";
live_chat.sites["LC"] = "live";
live_chat.sites["LD"] = "dealer";
live_chat.sites["C"]  = "casino";
live_chat.sites["2M"]  = "roller";

if (global_bus_channel === undefined) {
	global_bus_channel = "SB";
}

live_chat.use_this_chat = live_chat.sites[global_bus_channel];
if (tp_source_args.search("games=1") == 1) {
	live_chat.use_this_chat = "games";
}


// shared object used by the media centre and watch and bet video players
var vp_object = function () {
	vpc = {
		container       : null,
		player          : null,
		overlay         : null,
		button          : null,
		overlayButton   : null,
		settings: {
			containerId     : 'sp-container-popout',
			playerId        : 'player',
			overlayId       : 'sp-video-overlay-popout',
			buttonId        : 'sp-videoplayer-control',
			overlayButtonId : 'sp-play-btn-popout',
			width           : 480,
			height          : 364,
			swf             : 'playerPopout_unas.swf'
		},
		init: function(options) {
			if(options) vpc.settings = options;
			vpc.container = document.getElementById(vpc.settings.containerId);
			vpc.player = document.getElementById(vpc.settings.playerId);
			vpc.overlay = document.getElementById(vpc.settings.overlayId);
			vpc.button = document.getElementById(vpc.settings.buttonId);
			vpc.overlayButton = document.getElementById(vpc.settings.overlayButtonId);
			vpc.bind();

			if(vpc.overlay.style.display == 'block')
				vpc.stop();
		},
		bind: function() {
			vpc.button.onclick = function(e) {
				if (e && e.preventDefault) {
					e.preventDefault();
				} else if (window.event && window.event.returnValue) {
					window.eventReturnValue = false;
				}
				vpc.playstop();
			}

			vpc.overlayButton.onclick = function(e) {
				if (e && e.preventDefault) {
					e.preventDefault();
				} else if (window.event && window.event.returnValue) {
					window.eventReturnValue = false;
				}

				vpc.playstop();
			}
		},
		playstop: function() {
			if(vpc.overlay.style.display == 'none'){ //stop
				vpc.stop();

			} else { //play
				vpc.play();

			}
		},
		stop: function() {
			vpc.button.innerHTML = 'play';
			vpc.overlay.style.display = 'block';
			try{
				vpc.container.removeChild(vpc.player);
			} catch(err) {}
		},
		play: function() {
			vpc.button.innerHTML = 'stop';
			vpc.overlay.style.display = 'none';
			var div = document.createElement('div');
			div.setAttribute('id', 'player');
			vpc.container.appendChild(div);
			swfobject.embedSWF(vpc.settings.swf, "player",vpc.settings.width, vpc.settings.height, "9", false, flashvars, params, attributes);
		}
	};
	return {
		init: vpc.init,
		stop: vpc.stop,
		play: vpc.play
	};
}

// Show banned action light box
function banned_action_generic_lightbox( id ) {

	$j(function() {
		$j( "#"+id ).dialog({
			autoOpen: true, // should be set to false and check if already closed
			width: 550,
			modal: true,
			position: ['center',160],
			title: 'Restricted Territory Message',
			closeText: "",
			dialogClass: 'registration_success',
			buttons: {},
			close: function() {
				"close"
			}
		});

		$j('#restricted-territory-modal #btn-close').click(function() {
			$j( "#restricted-territory-modal" ).remove();
		});
	});

}

// show hide the refresh odds button as necessary for content tab
function showHideRefreshButton (tab_id) {
	// show hide the refresh odds button as necessary
	var refresh_odds_el = document.getElementById("fb_hp_refresh");
	var tabType = content_tab_types[tab_id];
	if (refresh_odds_el) {
		if (tabType == "COUPON" || tabType == "MYMATCHES_FB" || tabType == "FEATURED_FB") {
			refresh_odds_el.style.display = 'block';
		} else {
			refresh_odds_el.style.display = 'none';
		}
	}
}


// select a tab as a favourite
function selectAsFav (tabid) {

	set_pref('CONTENT_TAB_DEF',tabid);

	var el = '';

	// Set all to unselected.
	for(var i = 0; i < content_tabs.length; i++) {
		el = document.getElementById('selectAsFav_' + content_tabs[i]);
		if (el) {
			el.className = 'fav right';
		}
	}

	// Select the one clicked.
	el = document.getElementById('selectAsFav_' + tabid);
	if (el) {
		el.className = 'fav selected right';
	}

}

// Save the user's My Matches preferences, and show the resulting page.
// Params:
//   tabId to be used to reload the correct tab
// Returns:
//   false if an error occurred, true otherwise (and the tab is reloaded).
function FbSaveMyMatchesPref(tabId) {

	var f = document.getElementById('fb_my_matches_form');
	var type_ids = [];
	for (var i = 0; i < f.elements.length; i++) {
		var el = f.elements[i];
		if (el.type == 'checkbox' && el.checked) {
			type_ids.push(el.value);
		}
	}

	if (type_ids.length < 1) {
		alert(fb_data.xl_types_too_few);
		return false;
	}
	if (type_ids.length > fb_data.my_matches_pref_limit) {
		alert(fb_data.xl_types_too_many);
		return false;
	}

	set_pref('FOOTBALL_TYPES',type_ids.join(','));

	// this will force a reload
	content_tabs_loaded[tabId] = false;
	var tabObj = document.getElementById('content_tab_' + tabId);

	// do call for the content tab here
	changeTab(tabObj,tabId);
	return true;
}


// AJAX routines for the content tab
function makeCTAjaxGetRequest(url, clientdata, callback) {
	if (document.PollingAjaxHelper.checkSemaphore()) {return;}

	document.PollingAjaxHelper.aquireSemaphore();
	var req = null;
	if (window.XMLHttpRequest) {
		req = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		req = new ActiveXObject('Microsoft.XMLHTTP');
	}
	if (req) {
		req.onreadystatechange = function() {
			if (req.readyState != 4) return;
			var reqStatus;
			try {
				reqStatus = req.status;
			} catch (e) {
				reqStatus = '';
			}
			if (reqStatus != 200) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback(url,clientdata,false,'HTTP');
			} else {
				document.PollingAjaxHelper.releaseSemaphore();
				content_tabs_loaded[clientdata.id] = true;
				callback(url,clientdata,true,req.responseText);
			}
		}
		try {
			req.open('GET', url, true);
			req.send(null);
		} catch (e) {
			document.PollingAjaxHelper.releaseSemaphore();
			callback(url,clientdata,false,'UNSUPPORTED');
		}
	} else {
		document.PollingAjaxHelper.releaseSemaphore();
		callback(url,clientdata,false,'UNSUPPORTED');
	}
}

// Content tabe AJAX helper function
function gotCTAjaxContent(url,clientdata, ok, response) {
	var holder_el = document.getElementById(clientdata.id);
	if (ok) {

		// blank response means no new data
		if (response == "") {
			return;
		}

		var parts = parseCTScriptTags(response);
		if (holder_el) {
			holder_el.innerHTML = parts[0];
		}
		if (parts[1].length) {
			try {
				contentTabGlobalEval(parts[1]);
			} catch (e) {
				ok = false;
			}
		}
	}
}

// Content tabe AJAX helper function
var contentTabGlobalEval = function (src) {
	if (window.execScript) {
		window.execScript(src);
		return;
	}
	var fn = function() {
		window.eval.call(window,src);
	};
	fn();
};

// Content tabe AJAX helper function
function parseCTScriptTags(str) {
	var html = '';
	var js   = '';
	var i = 0;
	var state = 'HTML';
	var script_re =
	  new RegExp('<(/?)' + 'scr'+'ipt' + '([^>]*)>', 'gi');
	while ((mtch = script_re.exec(str)) != null) {
		mS = mtch.index;
		if (state == 'HTML') {
			html += str.substring(i, mS);
		} else {
			js += str.substring(i, mS) + ';\n';
		}
		var closer = mtch[1];
		var attrs  = mtch[2];
		if (closer == '/') {
			state = 'HTML';
		} else {
			if ( attrs.charAt(attrs.length - 1) != '/' &&
			     attrs.indexOf('src=') == -1 ) {
				state = 'JS';
			}
		}
		i = script_re.lastIndex;
	}
	if (state == 'HTML') {
		html += str.substring(i);
	} else {
		js += str.substring(i);
	}
	return [ html, js ];
}

// Content tab helper function
function set_tab_type(tab_id, tab_type) {
	content_tab_types[tab_id] = tab_type;
}

function close_restricted_territory(url) {

	if (BrowserDetect.browser == "IE" && BrowserDetect.version == 7) {
		document.getElementById("div_hidden_iframe_ext").src = proto + '://' + url + '/hi.php?close_restricted_territory_modal=1';
	} else {

		var parent_redirect_domain = url;

		//post message
		var proto = (_get("contentproto") != "") ? _get("contentproto") : "http";
		var postMessageString  = "close_restricted_territory";
		var destination_domain = proto  + "://" + parent_redirect_domain;
		parent.postMessage(postMessageString, destination_domain);
	}
}

function resize_ip_blocking(parent_redirect_domain) {

	var proto = (_get("contentproto") != "") ? _get("contentproto") : "http";

	var url = parent_redirect_domain;
	url = proto + "://" + url;

	if (BrowserDetect.browser == "IE" && BrowserDetect.version == 7) {
		document.getElementById("div_hidden_iframe_ext").src = url + '/hi.php?resize_ip_blocking_modal=' + get_height();
	} else {
		//post message
		var postMessageString = "resize_ip_blocking|" + get_bam_height();
		var destination_domain = proto + "://" + parent_redirect_domain;
		parent.postMessage(postMessageString, destination_domain);
	}
}


function get_bam_height() {
	return document.getElementsByTagName("body")[0].clientHeight;
}

function changeTab (link, targetCnt) {

	current_tab = targetCnt;
	fb_tab_id = targetCnt;

	if (content_tab_page == "FB") {
		showHideRefreshButton(targetCnt);

		if (content_tab_types[targetCnt] == "FEATURED_FB") {
			fb_page_type = "fb_hp_feat_tab";
		} else if (content_tab_types[targetCnt] == "LIVEBETTING_FB") {
			fb_page_type = "fb_hp_live_tab";
		} else if (content_tab_types[targetCnt] == "MYMATCHES_FB") {
			fb_page_type = "fb_hp_my_tab";
		} else if (content_tab_types[targetCnt] == "OTHERMKT_FB") {
			fb_page_type = "";
		}
	}

	if (content_tabs_loaded[targetCnt]) {
		// Content already loaded.
	} else {
		if (content_tab_page == "FB") {
			document.getElementById(targetCnt).innerHTML = '<div class="notes"><p>'+ content_tab_page_loading +'</p></div>';
		}
		loadContentTab(targetCnt);
	}

	if (content_tab_page == "FB") {
		var tabArr = $j('.fb_item_wrapper');
	} else {
		var tabArr = $j('.tabsOdds');
	}

	var tabsOdds = tabArr[0];
	//Switch Content
	$j(tabsOdds).find('.tabCnt').hide();

	document.getElementById(targetCnt).style.display = 'block';

	//switch Tab
	if (content_tab_page == "FB") {
		var tabsLinkArr = $j(tabsOdds).find('.fb-market-filters');
	} else {
		var tabsLinkArr = $j(tabsOdds).find('.tabs');
	}

	var tabsLink = tabsLinkArr[0];
	$j(tabsLink).find('li').removeClass('active');

	link.parentNode.className = 'active';

	if (content_tab_page == "FB") {
		// store a cookie, with 24hrs persistence, to retain the last football tab
		var expireDate = new Date("January 01, 2036 00:00:00");
		document.cookie = "fb_home_tab"+"="+targetCnt+"; path=/; expires="+expireDate.toGMTString();

		// Make sure the right date/league button is pressed
		if (content_tab_modes[targetCnt] == 'date') {
			document.getElementById('pnav_date').className = 'pressed';
			document.getElementById('pnav_date_lbl').className = 'pressed';
			document.getElementById('pnav_type').className = '';
			document.getElementById('pnav_type_lbl').className = '';
		} else {
			document.getElementById('pnav_date').className = '';
			document.getElementById('pnav_date_lbl').className = '';
			document.getElementById('pnav_type').className = 'pressed';
			document.getElementById('pnav_type_lbl').className = 'pressed';
		}

		// Hide powernav when "Other Markets" tab is selected
		if (content_tab_types[targetCnt] == "FEATURED_FB") {
			document.getElementById("powernav").style.display = '';
		} else if (content_tab_types[targetCnt] == "LIVEBETTING_FB") {
			document.getElementById("powernav").style.display = '';
		} else if (content_tab_types[targetCnt] == "MYMATCHES_FB") {
			document.getElementById("powernav").style.display = '';
		} else if (content_tab_types[targetCnt] == "OTHERMKT_FB") {
			document.getElementById("powernav").style.display = 'none';
		}
	}
}

function loadContentTab (tabid) {

	var url = content_tab_url + tabid;

	var clientdata = {
		id : tabid
	};
	makeCTAjaxGetRequest(url,clientdata,gotCTAjaxContent)
}

function resize_iframe(id, h){
	var target = document.getElementById(id);
	if(target){
		target.height = h;
	}
}

// Allows the execution of Javascript functions after the page has completed loading.
function MultiOnLoad() {

	this.loaded = 0;
	// list of onload functions
	this.ol = new Array();


	// push an onload function
	this.push = function(_fn) {
		//console.log("push");
		if (this.loaded) {
			//console.log("exec");
			_fn();
			return;
		}
		//console.log("queue");
		this.ol.push(_fn);
		return true;
	};


	// execute all the unload functions
	this.execute = function() {
		//console.log("exec "+this.ol.length);
		this.loaded = 1;
		for(var i = 0, len = this.ol.length; i < len; i++) {
			this.ol[i]();
		}
	};
}
document.bodyOnLoad  = new MultiOnLoad();

// very low level wrapper around setInterval and setTimeout to prevent
// the same polling ajax job being created multiple times
function PollingAjax() {

	//console.log("PollingAjax");

	this.intervals = {};
	this.timeouts = {};
	this.semaphore = false;

	// set an interval
	this.setInterval= function(id, func, time) {

		//console.log("PollingAjax.setInterval " + id);

		// dont allow the same interval twice
		// return original handle to original interval
		if (this.intervals[id]) {

			//console.log("PollingAjax.setInterval " + id + " EXISTS");

			return this.intervals[id];
		}

		var interval = setInterval(func, time);

		this.intervals[id] = interval;

		return interval;
	}

	// clear an interval
	this.clearInterval= function(id) {

		//console.log("PollingAjax.clearInterval " + id);

		if (this.intervals[id]) {
			clearInterval(this.intervals[id]);
			this.intervals[id] = null;
		}
	}

	// get an interval
	this.getInterval= function(id) {

		//console.log("PollingAjax.getInterval " + id);

		return this.intervals[id];
	}

	// set a timeout
	this.setTimeout= function(id, func, time) {

		//console.log("PollingAjax.setTimeout " + id);

		// replace an existing timeout with the new one
		if (this.timeouts[id]) {

			//console.log("PollingAjax.setTimeout " + id + " EXISTS");

			this.clearTimeout(this.timeouts[id]);
		}

		var timeout = setTimeout(func, time);

		this.timeouts[id] = timeout;

		return timeout;
	}

	// clear a timeout
	this.clearTimeout= function(id) {

		//console.log("PollingAjax.clearTimeout " + id);

		if (this.timeouts[id]) {
			clearTimeout(this.timeouts[id]);
			this.timeouts[id] = null;
		}
	}

	// get atimeout
	this.getTimeout= function(id) {

		//console.log("PollingAjax.getTimeout " + id);

		return this.timeouts[id];
	}

	// semaphores, used such that only one AJAX req is made at a time
	// on the sportsbook
	this.checkSemaphore = function() {

		//console.log("PollingAjax.checkSemaphore " + this.semaphore);

		return this.semaphore;
	}

	this.aquireSemaphore = function() {

		//console.log("PollingAjax.aquireSemaphore");

		this.semaphore = true;
	}

	this.releaseSemaphore = function() {

		//console.log("PollingAjax.releaseSemaphore");

		this.semaphore = false;
	}
}

document.PollingAjaxHelper  = new PollingAjax();

// Truncate string s to length len if needed, appending suffix to indicate
// truncation has occurred. The length of the suffix is taken into account.
function trunc_string(s, len, suffix) {
	if (s.length <= len) return s;
	var keep = len - suffix.length;
	return s.substr(0, keep >= 0 ? keep : 0) + suffix;
}

function unescapeHTML(html) {
	return $j("<div />").html(html).text();
}

// Freebet assisstant javascript
var freebet_edu= true;
freebet_edu_dock = function()
{

	_fb = {
			dock : null,
			init : function(){

					if(typeof(freebet_edu) != 'undefined') {
							dock = null;
							_fb.dock = document.getElementById("freebet_dock");
							if (_fb.dock != null) {
									_fb.displayDock();
									_fb.bind();
									BS_add_post_placement_callback(_fb.updateOverlay);
							}
					}
			},
			displayDock : function()
			{
					_fb.dock.style.display = 'block';

			},
			bind : function()
			{
					var help = document.getElementById('freebet_help_link');
					var dock_close = document.getElementById('freebet_dock_close');
					var help_close = document.getElementById('freebet_help_close');

					if (help) {
							help.onclick = function(){
									_fb.openHelp();
							}
					}

					if (dock_close) {
							dock_close.onclick = function(){
									_fb.close('dock');
							}
					}

					if (help_close) {
							help_close.onclick = function(){
									_fb.close('');
							}
					}

			},
			openHelp : function()
			{

					var h = document.getElementById("freebet_help");
					var marginbottom = _fb.dock.offsetHeight;
					h.style.marginBottom = marginbottom + "px" ;
					h.style.display = 'block';
			},
			close : function(el)
			{

					var help = document.getElementById("freebet_help");
					if(el == 'dock')
					{
							_fb.dock.style.display = 'none';
							_fb.closeOverlay();
					}
					help.style.display = 'none';
			},
			closeOverlay : function( )
			{
					general_cookie.setValue("viewed_FBA","CLOSE");
					_fb.ajaxRequestFBA( "CLOSE" );
			},
			updateOverlay : function( )
			{
					_fb.ajaxRequestFBA( "UPDATE" );
			},
			ajaxRequestFBA : function( task )
			{
					var gotAjaxResponse = function(url,clientdata, ok, response) {
							response = response.trim();
							var fba_container = document.getElementById("freebet_overlay_container");
							var parts = parse_script_tags(response);
							if (fba_container) {
									fba_container.innerHTML = parts[0];
									if (response != "") {
											_fb.init();
									}
							}
							if (parts[1].length) {
									try {
											global_eval(parts[1]);
									} catch (e) {
											ok = false;
									}
							}
					}
					if (task == "") {
							return;
					}
					if (document.location.protocol == 'http:') {
							var url = tld + '?action=go_fba_overlay_ajax';
					} else {
							var url = tld_secure + '?action=go_fba_overlay_ajax';
					}
					url += "&req_task="+task;
					make_ajax_get_request("frebet_assistant", url,"",gotAjaxResponse);
			}
	}


	return {
			init        : _fb.init,
			callOverlay : _fb.updateOverlay
	}
}

var ifreebet_edu = new freebet_edu_dock();

// This function is used to toggle the cashout overlay
// display status
function toggle_cashout_overlay() {

	$j('#cash-in-overlay').toggle();

}

// This function is used to toggle the cashout modal
// which notifes user about cashout price changes
function toggle_cashout_price_change() {

	$j('#cashout_price_change_modal').toggle();

}

// This function is used to toggle a customised cashout modal
// which notifes user about various cashout related errors
// The template is defined in cashout_custom_modal.html
function toggle_cashout_custom_modal() {

	$j("#cashout_custom_modal").toggle();

}

// This function is used to toggle a cashout confirmation modal
// which notifes user about each way term change
// The template is defined in cashout_ew_custom_modal.html
function toggle_cashout_ew_confirm_modal() {

	$j("#cashout_ew_confirm_modal").toggle();

}
//This function is used to update the clock displayed in the channel nav bar
function updateClock(){
	var date = new Date();
	var hours = checkTime(date.getHours());
	var minutes = checkTime(date.getMinutes());
	var seconds = checkTime(date.getSeconds());
	document.getElementById("top-bar-time").innerHTML = hours+":"+minutes+":"+seconds;
}

function checkTime(time){
if(time < 10){
	time = "0"+time;
}
	return time;
}



/* Writing crunched file animatedcollapse.js */
var animatedcollapse={
divholders: {}, //structure: {div.id, div.attrs, div.$divref}
divgroups: {}, //structure: {groupname.count, groupname.lastactivedivid}
lastactiveingroup: {}, //structure: {lastactivediv.id}

show:function(divids){ //public method
	if (typeof divids=="object"){
		for (var i=0; i<divids.length; i++)
			this.showhide(divids[i], "show")
	}
	else
		this.showhide(divids, "show")
},

hide:function(divids){ //public method
	if (typeof divids=="object"){
		for (var i=0; i<divids.length; i++)
			this.showhide(divids[i], "hide")
	}
	else
		this.showhide(divids, "hide")
},

toggle:function(divid){ //public method
	this.showhide(divid, "toggle")
},

addDiv:function(divid, attrstring){ //public function
	this.divholders[divid]=({id: divid, $divref: null, attrs: attrstring})
	this.divholders[divid].getAttr=function(name){ //assign getAttr() function to each divholder object
		var attr=new RegExp(name+"=([^,]+)", "i") //get name/value config pair (ie: width=400px,)
		return (attr.test(this.attrs) && parseInt(RegExp.$1)!=0)? RegExp.$1 : null //return value portion (string), or 0 (false) if none found
	}
},

showhide:function(divid, action){
	var $divref=this.divholders[divid].$divref //reference collapsible DIV
	if (this.divholders[divid] && $divref.length==1){ //if DIV exists
		var targetgroup=this.divgroups[$divref.attr('groupname')] //find out which group DIV belongs to (if any)
		if ($divref.attr('groupname') && targetgroup.count>1 && (action=="show" || action=="toggle" && $divref.css('display')=='none')){ //If current DIV belongs to a group
			if (targetgroup.lastactivedivid && targetgroup.lastactivedivid!=divid) //if last active DIV is set
				this.slideengine(targetgroup.lastactivedivid, 'hide') //hide last active DIV within group first
				this.slideengine(divid, 'show')
			targetgroup.lastactivedivid=divid //remember last active DIV
		}
		else{
			this.slideengine(divid, action)
		}
	}
},

slideengine:function(divid, action){
	var $divref=this.divholders[divid].$divref
	if (this.divholders[divid] && $divref.length==1){ //if this DIV exists
		var animateSetting={height: action}
		if ($divref.attr('fade'))
			animateSetting.opacity=action
		$divref.animate(animateSetting, $divref.attr('speed')? parseInt($divref.attr('speed')) : 500)
		return false
	}
},

generatemap:function(){
	var map={}
	for (var i=0; i<arguments.length; i++){
		if (arguments[i][1]!=null){
			map[arguments[i][0]]=arguments[i][1]
		}
	}
	return map
},

init:function(){
	var ac=this
	jQuery(document).ready(function($){
		var persistopenids=ac.getCookie('acopendivids') //Get list of div ids that should be expanded due to persistence ('div1,div2,etc')
		var groupswithpersist=ac.getCookie('acgroupswithpersist') //Get list of group names that have 1 or more divs with "persist" attribute defined
		if (persistopenids!=null) //if cookie isn't null (is null if first time page loads, and cookie hasnt been set yet)
			persistopenids=(persistopenids=='nada')? [] : persistopenids.split(',') //if no divs are persisted, set to empty array, else, array of div ids
		groupswithpersist=(groupswithpersist==null || groupswithpersist=='nada')? [] : groupswithpersist.split(',') //Get list of groups with divs that are persisted
		jQuery.each(ac.divholders, function(){ //loop through each collapsible DIV object
			this.$divref=$('#'+this.id)
			if ((this.getAttr('persist') || jQuery.inArray(this.getAttr('group'), groupswithpersist)!=-1) && persistopenids!=null){
				var cssdisplay=(jQuery.inArray(this.id, persistopenids)!=-1)? 'block' : 'none'
			}
			else{
				var cssdisplay=this.getAttr('hide')? 'none' : null
			}
			this.$divref.css(ac.generatemap(['height', this.getAttr('height')], ['display', cssdisplay]))
			this.$divref.attr(ac.generatemap(['groupname', this.getAttr('group')], ['fade', this.getAttr('fade')], ['speed', this.getAttr('speed')]))
			if (this.getAttr('group')){ //if this DIV has the "group" attr defined
				var targetgroup=ac.divgroups[this.getAttr('group')] || (ac.divgroups[this.getAttr('group')]={}) //Get settings for this group, or if it no settings exist yet, create blank object to store them in
				targetgroup.count=(targetgroup.count||0)+1 //count # of DIVs within this group
				if (!targetgroup.lastactivedivid && this.$divref.css('display')!='none' || cssdisplay=="block") //if this DIV was open by default or should be open due to persistence
					targetgroup.lastactivedivid=this.id //remember this DIV as the last "active" DIV (this DIV will be expanded)
				this.$divref.css({display:'none'}) //hide any DIV that's part of said group for now
			}
		}) //end divholders.each
		jQuery.each(ac.divgroups, function(){ //loop through each group
			if (this.lastactivedivid)
				ac.divholders[this.lastactivedivid].$divref.show() //and show last "active" DIV within each group (one that should be expanded)
		})
		var $allcontrols=$('*[rel]').filter('[@rel^="collapse-"], [@rel^="expand-"], [@rel^="toggle-"]') //get all elements on page with rel="collapse-", "expand-" and "toggle-"
		var controlidentifiers=/(collapse-)|(expand-)|(toggle-)/
		$allcontrols.each(function(){
			$(this).click(function(){
				var relattr=this.getAttribute('rel')
				var divid=relattr.replace(controlidentifiers, '')
				var doaction=(relattr.indexOf("collapse-")!=-1)? "hide" : (relattr.indexOf("expand-")!=-1)? "show" : "toggle"
				return ac.showhide(divid, doaction)
			}) //end control.click
		})// end control.each
		$(window).bind('unload', function(){
			ac.uninit()
		})
	}) //end doc.ready()
},

uninit:function(){
	var opendivids='', groupswithpersist=''
	jQuery.each(this.divholders, function(){
		if (this.$divref.css('display')!='none'){
			opendivids+=this.id+',' //store ids of DIVs that are expanded when page unloads: 'div1,div2,etc'
		}
		if (this.getAttr('group') && this.getAttr('persist'))
			groupswithpersist+=this.getAttr('group')+',' //store groups with which at least one DIV has persistance enabled: 'group1,group2,etc'
	})
	opendivids=(opendivids=='')? 'nada' : opendivids.replace(/,$/, '')
	groupswithpersist=(groupswithpersist=='')? 'nada' : groupswithpersist.replace(/,$/, '')
	this.setCookie('acopendivids', opendivids)
	this.setCookie('acgroupswithpersist', groupswithpersist)
},

getCookie:function(Name){
	var re=new RegExp(Name+"=[^;]*", "i"); //construct RE to search for target name/value pair
	if (document.cookie.match(re)) //if cookie found
		return document.cookie.match(re)[0].split("=")[1] //return its value
	return null
},

setCookie:function(name, value, days){
	if (typeof days!="undefined"){ //if set persistent cookie
		var expireDate = new Date()
		expireDate.setDate(expireDate.getDate()+days)
		document.cookie = name+"="+value+"; path=/; expires="+expireDate.toGMTString()
	}
	else //else if this is a session only cookie
		document.cookie = name+"="+value+"; path=/"
}

}


/* Writing crunched file redirect_register.js */

// minified CVS tag version


function _redirect_register_get(name) {
	var regexS   = "[\\?&]"+name+"=([^&#]*)";
	var regex    = new RegExp( regexS );
	var tmpURL   = window.location.href;
	var results  = regex.exec( tmpURL );
	if( results == null ) {
		return "";
	} else {
		return results[1];
	}
}



function redirect_register ( url, parent_ ) {

	var proto = (_redirect_register_get("contentproto") != "") ? _redirect_register_get("contentproto") : "http";

	// Append reg_referrer to the registration url (if its not there already)
	if (_redirect_register_get('reg_referrer') === '' && get_cookie('REG_COOKIE') === '') {

		var regex_str = "\\?[\\w]+=";
		var regex     = new RegExp( regex_str );

		// Check the url for any existing parameters
		if ( regex.exec( url ) === null ) {
			url = url + '?reg_referrer=' + encodeURIComponent(window.location.href);
		} else {
			var sep = '&';
			if (BrowserDetect.browser === "IE" || BrowserDetect.browser === "Edge") {
				sep = '&amp;';
			}
			url += sep + 'reg_referrer=' + encodeURIComponent(window.location.href);
		}
	}

	switch (parent_) {

		case "inline":
			window.location = url;
			break;

		case "iframe":
			if (BrowserDetect.browser == "IE" && BrowserDetect.version == 7) {
				gotopage(url);
			} else {
				var action = "redirect";
				var postMessageString = action+"|"+encodeURIComponent(url);
				var destination_domain = proto + "://" + parent_redirect_domain;
				parent.postMessage(postMessageString, destination_domain);
			}
			break;

		case "popup":
			if (window.opener != null && !window.opener.closed) {
				window.opener.location = url;
			} else {
				window.open(url);
			}
			self.close();
			break;

		case "parent":			
			parent.window.location = url;
			break;

		default:
			window.location = url;
	}

	return false;
}



/* Writing crunched file model_clock.js */
<!--
// ensure CVS revision number survives minification
//
/*
 * Live Betting Clocks
 */

var clockList = {};
var clockPeriodJS = {};
var serverDate;
var clientTimeOnLoad;
var divName = new Array();
var sbetElem = new Array();
var custLang;

function initPeriodClocks(_year,_month,_day,_hour,_min,_sec,_lang, force_start) {
	if(show_bir_clocks == "Y" || force_start == true) {
		setClientTimeOnLoad();
		setServerDate(_year,_month,_day,_hour,_min,_sec);
		custLang = _lang;
	}
}

function addClockEvent(event_id, clockn_js, div) {
	if(show_bir_clocks == "Y") {
		var info = clockList[event_id];
		var is_new_ev = !info;

		if (is_new_ev) {
			clockList[event_id] = {seconds: 0, timeout: 0};
		}

		for(var x in clockn_js) {
			id = clockn_js[x].period_id;
			var period = clockPeriodJS[id];
			var is_new_period = !period;

			if(is_new_period) {
				clockPeriodJS[id] = clockn_js[x];
			}
		}

		// Don't duplicate div names everytime a clock comes in for a particular div prefix.
		for (var i = 0; i < divName.length; i++) {
			if (divName[i] == div) {
				return;
			}
		}

		divName.push(div);
	}
}



// Separate version for superbets, which need array elements updated rather than divs
function addClockEventSuperbet(event_id, clockn_js, array_elem) {
	if(show_bir_clocks == "Y") {
		var info = clockList[event_id];
		var is_new_ev = !info;

		if (is_new_ev) {
			clockList[event_id] = {seconds: 0, timeout: 0};
		}

		for(var x in clockn_js) {
			id = clockn_js[x].period_id;
			var period = clockPeriodJS[id];
			var is_new_period = !period;

			if(is_new_period) {
				clockPeriodJS[id] = clockn_js[x];
			}
		}

		sbetElem.push(array_elem);

	}
}

function updatePeriodClock(data) {
	if(show_bir_clocks == "Y") {
		var clock = clockList[data.ev_id];
		if(clock) {
			var periodInfo = clockPeriodJS[data.period_id];
			period_start = 0;
			if(typeof periodInfo != undefined && periodInfo != null) {
				if(periodInfo.period_start_time != "") {
					period_start = periodInfo.period_start_time;
				}

				clockList[data.ev_id].active = true;
				clockList[data.ev_id].period_id = data.period_id;
				clockList[data.ev_id].curr_period_start_time = data.curr_period_start_time;
				clockList[data.ev_id].period_start = period_start;
				setPeriodStartTime(data.curr_period_start_time,period_start,data.ev_id);
				displayClock(periodInfo.period_id, periodInfo.period_xl[custLang], period_start, periodInfo.break_period, periodInfo.period_clock_format, data.ev_id);
			} else {
				turnOff(data.ev_id);
			}
		}
	}
}

function setServerDate(_year,_month,_day,_hour,_min,_sec) {
	//Month takes values from 0 to 11
	serverDate = new Date(_year,_month -1 ,_day,_hour,_min,_sec);
}

function increaseServerTime(secs) {
	serverDate.setSeconds(serverDate.getSeconds() + secs);
}

function setClientTimeOnLoad() {
	clientTimeOnLoad = new Date();
}

function getServerTimeNow() {
	now = new Date();

	timeDiff = (now.getTime() - clientTimeOnLoad.getTime());

	dateDifference = serverDate.getTime() + ((timeDiff < 0) ? 0 : timeDiff);

	newDate = new Date(dateDifference);

	return newDate;
}

function setPeriodStartTime(curr_period_start_time, start, ev_id) {
	var re = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/;

	if(curr_period_start_time.match(re)) {
		myDate = curr_period_start_time.split("-").toString().split(":").toString().split(" ").toString().split(",");
		periodStartTime = new Date(myDate[0],parseInt(myDate[1],10)-1,myDate[2],myDate[3],myDate[4],myDate[5]);
		periodStartTime = parseInt((periodStartTime/1000),10);
	} else {
		periodStartTime = 0;
	}

	periodStartTime = ((periodStartTime < 0) ? 0 : periodStartTime);

	if(start == "") {
		periodseconds = 0;
	} else {
		periodminutes = start.split(":");

		periodseconds = parseInt((periodminutes[0]*60),10);
		periodseconds += parseInt((periodminutes[1]),10);
	}

	servertimenow = parseInt(getServerTimeNow()/1000);
	serverPeriodStart = (servertimenow - periodStartTime);
	if(serverPeriodStart < 0) {
		increaseSecs = -serverPeriodStart;
		increaseServerTime(increaseSecs-1);
		servertimenow = parseInt(getServerTimeNow()/1000);
		serverPeriodStart = (servertimenow - periodStartTime);
	}
	clockList[ev_id].seconds = periodseconds+serverPeriodStart;
}

function displayClock(period_id, translation, start, is_break, format, ev_id) {
	if(period_id==null || translation==null || start==null || is_break==null || format==null || clockList[ev_id].active == false)  {
		turnOff(ev_id);
		return;
	}

	totalTime = getClockTime(ev_id, format, start);

	if(typeof _lb_evt_event != 'undefined' && _lb_evt_event != null && _lb_evt_event != "" && lb_evt_ev_id == ev_id) {
		_lb_evt_event.clock = totalTime;
		_lb_evt_event.period_xl = translation;
	}

	for(x in divName) {

		var clockElm = document.getElementById(divName[x]+ev_id);
		if(clockElm != null) {
			// On team pages we don't want to show the period name.
			// Unless we are in a break period or extra time.
			if(is_break == "Y") {
				clockElm.innerHTML = translation;
			} else {
				clockElm.innerHTML = totalTime+" "+translation;
			}
		}

		var clockElmTime   = document.getElementById(divName[x]+"_time_"+ev_id);
		var clockElmPeriod = document.getElementById(divName[x]+"_period_"+ev_id);

		if(clockElmTime != null && clockElmPeriod != null) {

			// On team pages we don't want to show the period name.
			// Unless we are in a break period or extra time.
			if(is_break == "Y") {
				clockElmPeriod.innerHTML = translation;
			} else {
				clockElmTime.innerHTML   = totalTime;
				clockElmPeriod.innerHTML = translation;
			}
		}
	}

	for(x in sbetElem) {
		if (sbetElem[x].ev_id == ev_id) {
			if(is_break == "Y") {
				sbetElem[x].elapsed_time = translation;
			} else {
				sbetElem[x].elapsed_time = totalTime+" "+translation;
			}
		}
	}

	if(is_break == "Y") {
		clearTimeout(clockList[ev_id].timeout);
	} else {
		clearTimeout(clockList[ev_id].timeout);
		clockList[ev_id].timeout = setTimeout('displayClock("'+period_id+'","'+translation+'","'+start+'","'+is_break+'","'+format+'","'+ev_id+'")', 1000);
	}
}

function getClockTime(ev_id, format, start) {
	var clock = clockList[ev_id];
	totalTime = "";
	if(clock) {
		totalTime = 0;

		startSeconds = start;

		if(start != 0) {
			myList = String(startSeconds).split(":");

			if(format == "HH:MM:SS") {
				startSeconds = (parseInt(myList[0],10)*60*60)+(parseInt(myList[1],10)*60)+parseInt(myList[2],10)
			} else if(format == "MMM:SS") {
				startSeconds = (parseInt(myList[0],10)*60)+(parseInt(myList[1],10));
			}
		}
		seconds = ((clockList[ev_id].seconds < startSeconds) ? startSeconds : clockList[ev_id].seconds);

		minutes = 0;
		hours = 0;

		if(seconds >= 60) {
			minutes = Math.floor(seconds / 60);
			seconds = seconds % 60;

			if(format == "HH:MM:SS") {
				hours = minutes / 60;
				minutes = minutes % 60;
			}
		}

		if(seconds == 60) {
			seconds = 0;
			minutes += 1;
		}

		if(format == "HH:MM:SS") {
			if(minutes == 60) {
				minutes = 0;
				hours += 1;
			}
		}

		if(format == "HH:MM:SS") {
			totalTime = hours + ((minutes <= 9) ? "0"+minutes : minutes) + ":" + ((seconds <= 9) ? "0"+seconds : seconds)
		} else if (format == "MMM:SS") {
			min = minutes;

			if(minutes == 0) {
				min = "00";
			} else if(minutes > 1 && minutes < 10) {
				min = "0"+minutes;
			}

			totalTime = min + ":" + ((seconds<=9) ? "0" + seconds : seconds);
		}

		// Every 60 seconds, set the clock properly.
		if ((seconds % 60) == 0) {
			var periodInfo = clockPeriodJS[clockList[ev_id].period_id];
			period_start = 0;
			if(periodInfo.period_start_time != "") {
				period_start = periodInfo.period_start_time;
			}
			setPeriodStartTime(clockList[ev_id].curr_period_start_time,clockList[ev_id].period_start,ev_id);
		} else {
			clockList[ev_id].seconds++;
		}
	} else {
		clockList[ev_id].seconds++;
	}


	return totalTime;
}

function turnOff(ev_id) {
	for(x in divName) {
		var clockElm = document.getElementById(divName[x]+ev_id);

		if(clockElm != null) {
			clockElm.innerHTML = "";
		}
	}
	clearTimeout(clockList[ev_id].timeout);
	clockList[ev_id].active = false;

	return;
}

//-->


/* Writing crunched file cashout.js */

// Main cashout instance
// This is initialised by passing in the necessary configurations
// This object is used to track the current cashout state on the page. Any functionality
// that requires state should live here.

ob.Cashout = (function() {

	// State variables to track when ajax or cashout requests are in process
	var reload_in_progress = false;
	var cashout_in_progress = false;

	var widgetManager;
	var page;
	var cfg;

	var ajax_id = "cashout_ajax_scheduler";

	function init(page_type, init_cfg) {
		if (typeof (window.$j || window.jQuery && ($j = jQuery.noConflict())) === "undefined") { throw "Requires jQuery" }

		// In an ideal world we'd check the init_cfg object for required parameters
		// but given the nature of this JS it's really not worth the fuss.
		cfg = init_cfg;

		// Initialise templates
		for (var template_name in ob.Cashout.templates) {
			tmpl_store(template_name, ob.Cashout.templates[template_name]);
		}

		// Initialise the widget manager
		widgetManager = new ob.Cashout.WidgetManager();

		// Initialise clocks
		initPeriodClocks(
			cfg.server_time[0],
			cfg.server_time[1],
			cfg.server_time[2],
			cfg.server_time[3],
			cfg.server_time[4],
			cfg.server_time[5],
			cfg.lang
		);

		// Keep a reference to the correct page object
		page = ob.Cashout.page[page_type];

		// Create any initial widgets that are based on data loaded with the page.
		var initial_bets = page.getInitialBetData();
		for (var bet_id in initial_bets) {
			var options = page.getWidgetOptions(bet_id, initial_bets[bet_id]);
			for (var i = 0; i < options.length; i++) {
				widgetManager.createWidget(bet_id, options[i], initial_bets[bet_id]);
			}
		}

		// Make an ajax request to populate data for all the cashout bets initially
		// on the page. This same call will be used to poll for changes when necessary.
		getUpdatedCashoutValues();

		ob.Cashout.core.startAjaxPoll(ajax_id, getUpdatedCashoutValues, cfg.ajax_timeout);
	}

	function getUpdatedCashoutValues() {
		// If we are currently waiting for a cashout to finish, reschedule this
		// reload for a second from now
		if (cashout_in_progress) {
			ob.Cashout.core.scheduleAjaxPoll(ajax_id, getUpdatedCashoutValues, 1);
		}

		// If there is an ajax refresh currently taking place, then we can ignore this one
		if (reload_in_progress) {
			return;
		}

		// Get all the bet_ids from widgets that think they need an update
		var bet_ids = widgetManager.getUpdatesRequired();

		// Add in any new bet_ids coming from the page, e.g. newly placed bets.
		var new_bet_ids = page.getCashoutBets();
		for (var i=0; i < new_bet_ids.length; i++) {
			var bet_id = new_bet_ids[i];
			if (!widgetManager.hasWidget(bet_id)) {
				bet_ids.push(bet_id);
			}
		}

		if (bet_ids.length > 0) {
			// Set the state because we're about to make an ajax request
			reload_in_progress = true;

			var postdata = {bets : bet_ids.join("|")};

			// Make the AJAX request
			ob.Cashout.core.makeAjaxRequest("get_cashout", "get_cashout_amount", {}, processUpdatedCashoutValues, postdata);
		}
	}

	function processUpdatedCashoutValues(clientdata, ok, json) {
		// Update widgets if the request was successful
		if (ok && json !== null) {
			for (var bet_id in json) {
				if (widgetManager.hasWidget(bet_id)) {
					widgetManager.updateWidget(bet_id, json[bet_id]); 
				} else {
					var options = page.getWidgetOptions(bet_id, json[bet_id]);
					for (var i = 0; i < options.length; i++) {
						widgetManager.createWidget(bet_id, options[i], json[bet_id]);
					}
				}
			}
		}
		// Either way, mark the reload as finished so we can carry on with new ones
		reload_in_progress = false;
	}

	return {
		init: init,
		cashoutInProgress: function() { return cashout_in_progress },
		notifyCashout: function() { cashout_in_progress = true },
		notifyCashoutComplete: function() { cashout_in_progress = false },
		onBetPlace: function() { if (typeof page.onBetPlace === "function") { page.onBetPlace() } },
		getCfg: function(key) { return (typeof cfg[key] === "undefined" ? "" : cfg[key]) }
	}
})();

// This object contains a few utility functions used by the other objects.
// This is only for things that don't require state - anything that does should live in the main instance.
ob.Cashout.core = (function() {

	// Format a monetary amount with the html ccy symbol at the start
	function formatMoney(amount) {
		return print_ccy_symbol(get_pref("ccy_code")) + formatCurrency(amount);
	}

	// Wrapper for making ajax requests
	function makeAjaxRequest(id, action, clientdata, callback, postdata, context) {

		// Do not send do_cashout_bets or get_cashout_req_status to ajax
		if (action === "do_cashout_bets" || action === "get_cashout_req_status") {
			if (document.location.protocol === "http:") {
				var url = tld + "?action="+action;
			} else {
				var url = tld_secure + "?action="+action;
			}
		} else {
			if (document.location.protocol === "http:") {
				var url = tld_ajax + "?action="+action;
			} else {
				var url = tld_ajax_secure + "?action="+action;
			}
		}

		if (document.PollingAjaxHelper.checkSemaphore()) {
			// Attempt this again in 300ms.
			document.PollingAjaxHelper.setTimeout(
				id,
				function () { makeAjaxRequest(id, url, clientdata, callback, postdata, context) },
				300
			);
			return;
		}
		document.PollingAjaxHelper.aquireSemaphore();

		$j.ajax({
			url       :  url,
			type      : "POST",
			data      : postdata,
			dataType  : "json",
			success: function (json) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback.call(context, clientdata, true, json);
			},
			error: function (jqXHR, status, msg) {
				document.PollingAjaxHelper.releaseSemaphore();
				callback.call(context, clientdata, false, null);
			}
		})
	}

	// Begin regular ajax polling of cashout values
	function startAjaxPoll(id, ajaxFunction, timeout) {
		document.PollingAjaxHelper.setInterval(
			id,
			ajaxFunction,
			timeout * 1000
		);
	}

	// Stop regular ajax polling of cashout values
	function stopAjaxPoll(id) {
		document.PollingAjaxHelper.clearInterval(id);
	}

	// Schedule a one-off ajax poll
	// Usually used if an update is needed but has to wait for something else to finish
	function scheduleAjaxPoll(id, ajaxFunction, timeout) {
		document.PollingAjaxHelper.setTimeout(
			id,
			ajaxFunction,
			timeout * 1000
		);
	}

	// Let the user know the price of a cashout has changed
	function notifyPriceChange() {
		// Show the "price has changed" display
		$j('#cashout_price_change_modal').show();
	}

	// Let the user know the price of a cashout has changed
	function showModalMessage(header, text) {
		$j("#cashout_custom_modal_header").html(header);
		$j("#cashout_custom_modal_text").html(text);
		$j("#cashout_custom_modal").show();
	}

	// Let the user know the ew terms of a cashout has changed
	function showEWModalConfirm(text, callback_obj) {
		$j("#cashout_ew_confirm_modal_text").html(text);

		//bind click events for cashout, cancel and close buttons on the confirmation modal
		$j("#cashout_ew_confirm_modal").on("click", "#cashout_ew_confirm_button_yes", function() {
			var skip_ew_term_check = true;
			callback_obj.doCashout(skip_ew_term_check);
		});
		$j("#cashout_ew_confirm_modal").on("click", "#cashout_ew_confirm_button_no, #cashout_ew_confirm_close", function() {
			// Move slider to full cashout position
			callback_obj.elem.find("input.manual").val("");
			if (callback_obj.slider) {
				callback_obj.slider.ionRangeSlider.update({
					from: callback_obj.slider.ionRangeSlider.options.max
				});
			}
			callback_obj.updatePartialCashoutValue("");
		});
		$j("#cashout_ew_confirm_modal").show();
	}

	function isNumeric(v) {
		// Allow only numbers and one dot
		var acceptableCharacters = '.';
		for (i = 0; i < v.length; i++) {
			c = v.charAt(i);
			if (!(c >= '0' && c <= '9')) {
				if (acceptableCharacters.indexOf(c) == -1) {
					return false;
				}
				acceptableCharacters = '';
			}
		}
		return true;
	}

	function getStepValue(coutValue, stepValuesMap, minPCOValue, defaultIncr) {
		// return default value for CASHOUT_UNAVAILABLE or cashout value less than minPCOValue
		// if the stepValuesMap object is empty
		if (isNaN(coutValue) || $j.isEmptyObject(stepValuesMap) || parseFloat(coutValue) < parseFloat(minPCOValue)) {
			return defaultIncr;
		}

		// parse through the map (can be unsorted) to figure out the correct step value
		// for the cashoutValue
		// For example StepValueMap has {25:0.4, 5:0.3, 1:0.1}, then if the cashout value is 4.99, then
		// the step value must be 0.1
		// For the cashout value 1 and above the step value will be 0.1
		// For the cashout value 5 and above the step value will be 0.3
		var nearestCoutLimit = 0;

		for (var coutLimit in stepValuesMap) {
			if (parseFloat(coutValue) >= parseFloat(coutLimit) &&
				(parseFloat(nearestCoutLimit) == 0 || parseFloat(coutLimit) > parseFloat(nearestCoutLimit))) {
				nearestCoutLimit = coutLimit;
			}
		}

		return parseFloat(stepValuesMap[nearestCoutLimit]);
	}

	function calcSliderFromValue(currentSliderFrom, sliderStep, sliderMin, operation) {
		// This function is to calculate the newSliderFrom value from the
		// current value using slider step and operation
		// Operation can be either INCR or DECR
		// newSliderFrom value must always be the multiple of sliderStep

		var newSliderFrom = currentSliderFrom;
		var remainder     = 0;
		var delta         = 0;

		// Convert the currentSliderFrom and sliderStep to whole number
		// so that, the result of the modulus operator will be whole number
		currentSliderFrom = Math.ceil((currentSliderFrom * 100).toFixed(2));
		sliderStep        = Math.ceil((sliderStep * 100).toFixed(2));
		sliderMin         = Math.ceil((sliderMin * 100).toFixed(2));

		// Check if the currentSliderFrom is a multiple of sliderStep
		// If not, there will be a remainder, otherwise the remainder will be 0
		//
		// In case of Increment, if there is no remainder, the value to be incremented
		// will be sliderStep, otherwise, the difference between sliderStep and remainder
		//
		// In case of Decrement, if there is no remainder, the value to be decremented
		// will be sliderStep, otherwise, just decrement the remainder
		//
		// Convert the newSliderFrom value back to decimal format
		switch(operation) {
			case "INCR":
				remainder      = (currentSliderFrom - sliderMin) % sliderStep;
				delta          = (remainder==0 ? sliderStep : sliderStep-remainder);
				newSliderFrom  = (currentSliderFrom + delta)/100;
				break;
			case "DECR":
				remainder      = (currentSliderFrom - sliderMin) % sliderStep;
				delta          = (remainder==0 ? sliderStep : remainder);
				newSliderFrom  = (currentSliderFrom - delta)/100;
				break;
		}

		newSliderFrom = parseFloat(newSliderFrom).toFixed(2);

		return newSliderFrom;
	}

	function isEwChanged (potential_bet1, potential_bet2) {
		// We are intreseted here if there was an Each Way Terms change
		// for a ew bet so..

		// If the new potential bet is not each way
		// something definitely changed
		// It might be that the partial is no more available
		// or the market is now W only
		if (potential_bet2.leg_type != "E") {
			return true;
		}

		// Iterate the legs of the potential old bet
		for (var leg_no in potential_bet1.legs) {
			if (typeof potential_bet1.legs[leg_no] === "undefined") {
				// Leg doesnt exist any more: consider it as a change
				return true;
			}

			var old_leg = potential_bet1.legs[leg_no];
			var new_leg = potential_bet2.legs[leg_no];

			// Did EW terms changed?
			if (new_leg.ew_fac_den != old_leg.ew_fac_den ||
				new_leg.ew_fac_num != old_leg.ew_fac_num ||
				new_leg.ew_places  != old_leg.ew_places ) {
				// Something changed in ew terms
				return true;
			}
		}
		return false;
	}

	function formatTootlipInfo(str1, str2, max_length) {
		// If str1 + str2 length exceeds the limit of max_length
		// this function slices the first chars of str1 in order
		// the str1 + str2 length to be equal to the max_length
		// and also adds "..." in the beginning of str1.
		var total_length = str1.concat(str2).length;
		var slice_chars  = total_length - max_length;

		if (slice_chars > 0) {
			str1 ="..." +  str1.slice(slice_chars + 3)
		}
		return str1;
	}

	return {
		formatMoney: formatMoney,
		makeAjaxRequest: makeAjaxRequest,
		startAjaxPoll: startAjaxPoll,
		stopAjaxPoll: stopAjaxPoll,
		scheduleAjaxPoll: scheduleAjaxPoll,
		notifyPriceChange: notifyPriceChange,
		showModalMessage: showModalMessage,
		showEWModalConfirm: showEWModalConfirm,
		isNumeric: isNumeric,
		getStepValue: getStepValue,
		calcSliderFromValue: calcSliderFromValue,
		isEwChanged: isEwChanged,
		formatTootlipInfo: formatTootlipInfo
	}
})();

// This object represents a page that cashouts can appear on.
// This is where page-specific functions and handling live.
// As far as possible these should have the same signature
ob.Cashout.page = {};

ob.Cashout.page.event = (function() {

	var selns_on_page = {};

	function getInitialBetData() {
		// Do nothing - there is nothing loaded with the page initially
	}

	// Get a list of all cashout bets that we care about on this page
	function getCashoutBets() {
		var bets = [];

		// Read the COUT section of the general cookie to see what bet IDs
		// are available for this page
		if (typeof general_cookie !== "undefined") {
			var cookie_bets = general_cookie.getValue("COUT");
			if (cookie_bets !== "") {
				cookie_bets = cookie_bets.split(" ");
				for (i = 0; i < cookie_bets.length; i++) {
					var bet_data = cookie_bets[i].split("~");
					var bet_id = bet_data[0];
					var ev_oc_id = bet_data[1];
					if (ev_oc_id in selns_on_page) {
						bets.push(bet_id);
					}
				}
			}
		}

		return bets;
	}

	// Add to the list of selections that we care about on this page
	function addSelections(selection_list) {
		for (var i=0; i < selection_list.length; i++) {
			selns_on_page[selection_list[i].ev_oc_id] = {
				ev_mkt_id: selection_list[i].ev_mkt_id
			}
		}
	}

	// Opposite of addSelections - remove selections that we no longer care about
	function removeSelections(selection_list) {
		for (var i=0; i < selection_list.length; i++) {
			delete selns_on_page[selection_list[i].ev_oc_id];
		}
	}

	// Handle bet placement - a callback function for the betslip
	function onBetPlace() {
		// Do nothing - we expect the cookie to be populated if needs be
	}

	// Get the list of widget settings that cashout widgets should use.
	// This is also responsible for initialising the scone if necessary - the assumption being
	// that if we're being asked for the container ID then we're probably about to add something to it.
	// Get the settings for widgets on this page
	function getWidgetOptions(bet_id, bet_data) {
		// We may have any of the following container types:
		//   1. A main cashout widget container containing all markets at the top of the page
		//   2. Smaller containers dedicated to each market

		// Find a market ID to display the bet under
		for (var ev_oc_id in bet_data.selns) {
			if (ev_oc_id in selns_on_page) { break }
		}
		var ev_mkt_id = bet_data.selns[ev_oc_id].ev_mkt_id;

		// Generate the container IDs
		var mkt_container_id = "cashout-" + ev_mkt_id;
		var mkt_head_container_id = "cashout_subcontents_" + ev_mkt_id;

		initContainers(mkt_container_id, mkt_head_container_id, bet_data);

		var opts = [];

		// Add options for containers that turned out to exist
		if (scone_exists(mkt_container_id)) {
			opts.push({
				container: mkt_container_id,
				origin: "EVENT",
				template_name: "cashout_no_selns",
				push_enabled: true,
				show_selection_details: false,
				show_more_bets_link: false,
				partial_cashout_enabled: false,
				partial_cashout_slider_enabled: true,
				partial_cashout_link_enabled: false
			});
		}

		if (scone_exists(mkt_head_container_id)) {
			opts.push({
				container: mkt_head_container_id,
				origin: "EVENT",
				template_name: "cashout_with_selns",
				push_enabled: true,
				show_selection_details: true,
				show_more_bets_link: false,
				partial_cashout_enabled: true,
				partial_cashout_slider_enabled: true,
				partial_cashout_link_enabled: false
			});
		}

		return opts;
	}

	// Initialise scones for containers on demand
	function initContainers(mkt_container_id, mkt_head_container_id, bet_data) {

		// Find a market ID to display the bet under
		for (var ev_oc_id in bet_data.selns) {
			if (ev_oc_id in selns_on_page) { break }
		}
		var ev_mkt_id = bet_data.selns[ev_oc_id].ev_mkt_id;

		initMarketContainer(ev_mkt_id, mkt_container_id, bet_data);
		initHeadMarketContainer(ev_mkt_id, ev_oc_id, mkt_head_container_id, bet_data);
	}

	// Create the market scone if its container exists
	function initMarketContainer(ev_mkt_id, mkt_container_id, bet_data) {
		if ($j('#' + mkt_container_id).length === 0) { return; }

		var mkt_container_id = "cashout-" + ev_mkt_id;
		if (!scone_exists(mkt_container_id)) {
			scone_create(mkt_container_id, {}, sortCashoutBets, null);
		}

		// Show the market container
		$j('#' + mkt_container_id).show();
	}

	// Create the main scone at the top of the page
	function initHeadMarketContainer(ev_mkt_id, ev_oc_id, mkt_head_container_id, bet_data) {
		var cashout_container_id = "cashout_bets_container";

		// Create all-markets top section if container exists
		if ($j('#' + cashout_container_id).length === 0) { return; }

		// Create the scone for it if it hasn't been made previously
		if (!scone_exists(cashout_container_id)) {
			scone_create(cashout_container_id, {}, sortCashoutMarkets, null);
			// Add a bind to expand/collapse market headers
			$j('#' + cashout_container_id).on("click", "a.exp-coll-mkt-hdr", expCollMktHeader);
		}

		// Add the market header if one doesn't exist for this market
		var mkt_header_id = "cashout_contents_" + ev_mkt_id;
		if (!scone_item_exists(mkt_header_id)) {
			var mkt_info = {
				ev_mkt_id: bet_data.selns[ev_oc_id].ev_mkt_id,
				ev_mkt_name: bet_data.selns[ev_oc_id].ev_mkt_desc,
				ev_mkt_disporder: bet_data.selns[ev_oc_id].ev_mkt_disporder
			}
			scone_add_item(cashout_container_id, mkt_header_id, tmpl_play("cashout_event_page_market_header", mkt_info), mkt_info);

			// Create a scone under the market header to hold cashout bets for this market
			if (!scone_exists(mkt_head_container_id)) {
				scone_create(mkt_head_container_id, {}, sortCashoutBets, null);
			}
		}

		// Show the main container now that we're adding something to it
		$j('#cashout_bet_list_container:hidden').show().on("click", "a.cashout-list-arrow", expCollCashoutList);
	}

	// Sort function for markets inside the top container
	function sortCashoutMarkets(cmpMode, mktA, mktB) {
		// There should only be one selection for these
		var dispA = mktA.ev_mkt_disporder;

		if (typeof dispA == "undefined"){
			return -1;
		}

		var dispB = mktB.ev_mkt_disporder;
		var ret = Math.sign(dispA - dispB);

		// Handle the case where both markets have the same disporder. If so then sort using the mkt_id.
		if (ret == 0) {
			ret = Math.sign(mktA.ev_mkt_id - mktB.ev_mkt_id);
		}
		return ret;
	}

	// Sort function for bets inside market containers
	function sortCashoutBets(cmpMode, betA, betB) {

		if (typeof betA.bet_data === "undefined") {
			return -1;
		}

		// Just sort by bet ID
		// If there is a parent bet ID then we sort using that in all cases unless
		// comparing with the parent itself. This means that a widget with a parent will
		// always appear next to its parent.
		var betIdA = (betA.bet_data.parent_bet_id || betA.bet_id);
		var betIdB = (betB.bet_data.parent_bet_id || betB.bet_id);

		var ret = Math.sign(betIdA - betIdB);

		if (ret === 0) {
			// If these are the same then we must be comparing with the parent (or with something with
			// the same parent. We always want the widget to come as the last thing in it's ancestry so, so return -1
			ret = -1;
		}

		return ret;
	}

	function expCollMktHeader() {
		var header = $j(this).closest("div.cashout-mkt-hdr");
		var container = header.next("div.cashout-mkt-content");
		if (container.is(":visible")) {
			header.addClass("fb-closed");
			container.hide();
		} else {
			header.removeClass("fb-closed");
			container.show();
		}
	}

	function expCollCashoutList() {
		var header = $j(this).closest("div.cashout-list-hdr");
		var container = header.next("div.cashout-list-content");
		if (container.is(":visible")) {
			header.addClass("fb-closed")
				.find('.tooltip:first').text(tmpl_ml_printf('MKT_CONTAINER_OPEN'));
			container.hide();
		} else {
			header.removeClass("fb-closed")
				.find('.tooltip:first').text(tmpl_ml_printf('MKT_CONTAINER_COLLAPSE'));
			container.show();
		}
	}

	return {
		getInitialBetData: getInitialBetData,
		getCashoutBets: getCashoutBets,
		addSelections: addSelections,
		removeSelections: removeSelections,
		onBetPlace: onBetPlace,
		getWidgetOptions: getWidgetOptions
	}

})();

ob.Cashout.page.betList= (function() {

	var bets = [];
	var initial_bet_data = {};

	function getInitialBetData() {
		return initial_bet_data;
	}

	// Get a list of all cashout bets that we care about on this page
	function getCashoutBets() {
		return bets;
	}

	// Set the list of cashout bets that we care about on this page
	// This is used when loading the page initially
	function setCashoutBets(bet_data) {
		for (var bet_id in bet_data) {
			bets.push(bet_id);
		}
		initial_bet_data = bet_data;
	}

	// Handle bet placement - a callback function for the betslip
	function onBetPlace() {
		var receipt_bets = get_cookie("PPBETRECEIPT").split(",");

		// Add new bet IDs to the bet list
		for (var i=0; i < receipt_bets.length; i++) {
			bets.push(receipt_bets[i]);
		}

	}

	// Get the list of widget settings that cashout widgets should use.
	// This is also responsible for initialising the scone if necessary - the assumption being
	// that if we're being asked for the container ID then we're probably about to add something to it.
	// Get the settings for widgets on this page
	function getWidgetOptions(bet_id, bet_data) {
		// In this case we just have the one main container
		var container_id = "cashout_bets_container";

		initContainers(container_id);

		return [
			{
				container: container_id,
				origin: "CASHOUT_PAGE",
				template_name: "cashout_with_selns",
				push_enabled: true,
				show_selection_details: true,
				show_more_bets_link: true,
				partial_cashout_enabled: true,
				partial_cashout_slider_enabled: true,
				partial_cashout_link_enabled: false
			}
		]
	}

	// Initialise scones for containers on demand
	function initContainers(container_id) {
		// Creating the scone will conveniently destroy the "no cashout bets" section
		if (!scone_exists(container_id)) {
			scone_create(container_id, {}, sortCashoutList, null);

			// We also need to add a header section the first time we do this
			var header_item_id  = "ma-header";
			var info            = {};
			// Set a fake start time so that the sorting function knows to put this first above all the cashout bet items
			info.bet_start_time = "0000-00-00 00:00:00";
			var header_html   = tmpl_play("cashout_bet_list_header", info);
			scone_add_item(container_id, header_item_id, header_html, {});
		}

	}

	// Sort the cashouts list
	function sortCashoutList(cmpMode, betA, betB) {

		if (typeof betA.bet_data === "undefined") {
			return -1;
		}

		var timeA = betA.bet_data.bet_start_time;
		var timeB = betB.bet_data.bet_start_time;

		var jsTimeA = new Date(timeA.replace(/-/g,"/"));
		var jsTimeB = new Date(timeB.replace(/-/g,"/"));
		var ret = Math.sign(jsTimeA -jsTimeB);

		// Handle the case where the bets have the same start time. If so then sort by bet_id
		if (ret == 0) {
			// If there is a parent bet ID then we sort using that in all cases unless
			// comparing with the parent itself. This means that a widget with a parent will
			// always appear next to its parent.
			var betIdA = (betA.bet_data.parent_bet_id || betA.bet_id);
			var betIdB = (betB.bet_data.parent_bet_id || betB.bet_id);

			var ret = Math.sign(betIdA - betIdB);

			if (ret === 0) {
				// If these are the same then we must be comparing with the parent (or with something with
				// the same parent. We always want the widget to come as the last thing in it's ancestry so, so return -1
				ret = -1;
			}

		}

		return ret;
	}

	return {
		getInitialBetData: getInitialBetData,
		getCashoutBets: getCashoutBets,
		setCashoutBets: setCashoutBets,
		onBetPlace: onBetPlace,
		getWidgetOptions: getWidgetOptions
	}

})();

ob.Cashout.page.myBets = (function() {

	var bets = [];

	function getInitialBetData() {
		// Do nothing - there is nothing loaded with the page initially
	}

	// Get a list of all cashout bets that we care about on this page
	function getCashoutBets() {
		return bets;
	}

	// Set the list of cashout bets that we care about on this page
	function setCashoutBets(bet_list) {
		bets = bet_list;
	}

	// Handle bet placement - a callback function for the betslip
	function onBetPlace() {
		// Do nothing - bets don't automatically appear on the my bets page,
		// so cashouts shouldn't either
	}

	// Get the list of widget settings that cashout widgets should use.
	// This is also responsible for initialising the scone if necessary - the assumption being
	// that if we're being asked for the container ID then we're probably about to add something to it.
	// Get the settings for widgets on this page
	function getWidgetOptions(bet_id, bet_data) {
		// In this case we have a separate container for each bet on the page
		var container_id = "cashout_cell_" + bet_id;

		initContainers(container_id);

		return [
			{
				container: container_id,
				origin: "MY_BETS",
				template_name: "cashout_button_only",
				push_enabled: true,
				show_selection_details: false,
				show_more_bets_link: false,
				partial_cashout_enabled: true,
				partial_cashout_slider_enabled: false,
				partial_cashout_link_enabled: true
			}
		]
	}

		// Initialise scones for containers on demand
	function initContainers(container_id) {
		// These containers are standalone so all they need do is exist
		if (!scone_exists(container_id)) {
			scone_create(container_id, {}, null, null);
		}

	}

	return {
		getInitialBetData: getInitialBetData,
		getCashoutBets: getCashoutBets,
		setCashoutBets: setCashoutBets,
		onBetPlace: onBetPlace,
		getWidgetOptions: getWidgetOptions
	}
})();



/* Writing crunched file cashout_templates.js */

ob.Cashout.templates = (function () {

	var templates = {};

	// Header for the cashout list page
	var tmpl = [];
	tmpl.push('<div id="ma-header">');
	tmpl.push(' <h2><%XL CASH_OUT_SUB_HEADER%></h2>');
	tmpl.push('</div>');
	templates["cashout_bet_list_header"] = tmpl.join("\n");

	// Large cashout section (with selection details)
	var tmpl = [];
	tmpl.push('<div class="<%wrapper_class%>" id="<%id%>" <%IF hidden %>style="display: none;"<%END%>>');
	tmpl.push(' <div class="cash-out-summary">');
	tmpl.push('  <div class="col seln-expand"><div class="seln-expand-arrow <%IF cashout_detail_shown %>close icon-chevron_down<%ELSE%>expand icon-chevron_right<%END%>"></div></div>');
	tmpl.push('  <div class="col seln-expand">');
	tmpl.push('   <p><strong><%bet_type_name%></strong></p>');
	tmpl.push('   <p class="green"><%bet_desc%></p>');
	tmpl.push('  <%IF leg_type == "E" && bet_type == "SGL" %>');
	tmpl.push('   <p class="each-way-terms"><%ew_desc%></p>');
	tmpl.push('  <%END%>');
	tmpl.push('  </div>');
	tmpl.push('  <div class="col seln-expand">');
	tmpl.push('   <p style="display:none">stake<span><%stake%></span></p>');
	tmpl.push('   <p><strong><%XL CO_STAKE%></strong> - <%stake_txt%>');
	tmpl.push('    <%IF leg_type == "E" %>');
	tmpl.push('     <span class="each-way-stake">(<%num_lines%> x <%line_stake_txt%>)</span>');
	tmpl.push('    <%END%>');
	tmpl.push('   </p>');
	tmpl.push('   <p><strong><%XL CO_TO_RETURN%></strong> - <%potential_txt%></p>');
	tmpl.push('  </div>');
	tmpl.push('  <%tmpl_play("cashout_button", self)%>');
	tmpl.push('  <%IF bet_receipt !== "" %>');
	tmpl.push('   <p class="cashout-linked-receipt cash-out-success" <%IF !bet_receipt_shown %>style="display: none;"<%END%>><%XL PCO_LINKED_RECEIPT%> <%bet_receipt%></p>');
	tmpl.push('  <%END%>');
	tmpl.push('  <%tmpl_play("partial_cashout_slider", self)%>');
	tmpl.push(' </div>');
	tmpl.push(' <div class="partial-cashout-success cash-out-success" <%IF !partial_cashout_success_shown %>style="display: none;"<%END%> >');
	tmpl.push('  <p><strong><%XL PCO_SUCCESS%></strong> <%XL PCO_SUCCESS_MORE%></p>');
	tmpl.push(' </div>');
	tmpl.push(' <%tmpl_play("bet_preview", self)%>');
	tmpl.push(' <div <%IF !cashout_detail_shown %>style="display: none;"<%END%> class="cash-out-detail" id="<%id%>_selns">');
	tmpl.push('  <%LOOP i selns.length%>');
	tmpl.push('   <div class="description<%IF selns[i].is_football_event == "Y"%> football<%ELSE IF selns[i].is_horse_race_event == "Y"%> horse-racing<%END%>">');
	tmpl.push('    <div class="col">');
	tmpl.push('     <%IF selns[i].is_football_event == "Y"%>');
	tmpl.push('       <p class="team-<%selns[i].home_team_id%>"><img src="<%selns[i].home_team_img%>"><strong><%selns[i].home_team_name%></strong></p>');
	tmpl.push('       <p class="team-<%selns[i].away_team_id%>"><img src="<%selns[i].away_team_img%>"><strong><%selns[i].away_team_name%></strong></p>');
	tmpl.push('     <%ELSE IF selns[i].is_horse_race_event == "Y"%>');
	tmpl.push('       <p>');
	tmpl.push('         <img title="<%selns[i].silks_files_desc%>" src="<%selns[i].silk_img_url%>">');
	tmpl.push('         <strong><%selns[i].ev_desc%></strong>');
	tmpl.push('       </p>');
	tmpl.push('       <span class="number"><%IF selns[i].runner_num !=""%>(<%selns[i].runner_num%>)<%END%></span>');
	tmpl.push('     <%ELSE%>');
	tmpl.push('       <p><span class="icon-<%selns[i].ev_class_id%>"></span><strong><%selns[i].ev_desc%></strong></p>');
	tmpl.push('     <%END%>');
	tmpl.push('     <span><%selns[i].type_desc%></span>')
	tmpl.push('    </div>');
	tmpl.push('    <div class="col">');
	tmpl.push('     <%IF selns[i].is_football_event == "Y"%>');
	tmpl.push('      <p><strong><%selns[i].ev_score_home%></strong></p>');
	tmpl.push('      <p><strong><%selns[i].ev_score_away%></strong></p>');
	tmpl.push('      <p>');
	tmpl.push('       <%IF selns[i].period_id != -1 && show_bir_clocks == "Y"%>');
	tmpl.push('        <div class="time" id="<%id%>_<%selns[i].ev_oc_id%>_clock_<%selns[i].ev_id%>"></div>');
	tmpl.push('       <%ELSE%>');
	tmpl.push('         <%selns[i].ev_start_date_time_str%>');
	tmpl.push('        <%END%>');
	tmpl.push('      </p>');
	tmpl.push('     <%ELSE%>');
	tmpl.push('      <p><strong>');
	tmpl.push('       <%IF selns[i].ev_score_home != "" %>\n');
	tmpl.push('        <%selns[i].ev_score_home%>\n');
	tmpl.push('       <%END%>\n');
	tmpl.push('       <%IF selns[i].ev_score_home != "" && selns[i].ev_score_away != "" %>\n');
	tmpl.push('        - \n');
	tmpl.push('       <%END%>\n');
	tmpl.push('       <%IF selns[i].ev_score_away != "" %>\n');
	tmpl.push('        <%selns[i].ev_score_away%>\n');
	tmpl.push('       <%END%>\n');
	tmpl.push('       <%IF selns[i].ev_score_home == "" && selns[i].ev_score_away == "" %>\n');
	tmpl.push('        &nbsp; \n');
	tmpl.push('       <%END%>\n');
	tmpl.push('      </strong></p>');
	tmpl.push('      <p><%selns[i].ev_start_date_time_str%></p>');
	tmpl.push('     <%END%>');
	tmpl.push('    </div>');
	tmpl.push('    <div class="col">');
	tmpl.push('     <p class="green"><%selns[i].ev_mkt_desc%>:<%selns[i].seln_desc%></p>');
	tmpl.push('     <p class="status-text"><span class="status <%IF selns[i].result == "W" %>won<%ELSE IF selns[i].result == "V" %>void<%ELSE%>pending<%END%>"></span><%selns[i].result_desc%></p>');
	tmpl.push('    </div>');
	tmpl.push('    <div class="col">');
	tmpl.push('    <%IF show_more_bets_link %>');
	tmpl.push('     <%IF selns[i].result != "W" && selns[i].result != "V" && selns[i].result != "L" %>');
	tmpl.push('      <%IF selns[i].ev_is_bir == "Y"%>');
	tmpl.push('       <%IF selns[i].is_horse_race_event == "Y"%>')
	tmpl.push('        <a href="<%selns[i].hr_ev_url%>?action=go_betlive_event&ev_id=<%selns[i].ev_id%>">');
	tmpl.push('       <%ELSE%>');
	tmpl.push('        <a href="?action=go_betlive_event&ev_id=<%selns[i].ev_id%>">');
	tmpl.push('       <%END%>');
	tmpl.push('      <%ELSE%>');
	tmpl.push('       <%IF selns[i].is_horse_race_event == "Y"%>')
	tmpl.push('        <a href="<%selns[i].hr_ev_url%>#hr_ev_event_<%selns[i].ev_id%>">');
	tmpl.push('       <%ELSE%>');
	tmpl.push('        <a href="?action=go_event&class_sort=<%selns[i].class_sort%>&category=<%selns[i].category%>&ev_id=<%selns[i].ev_id%>">');
	tmpl.push('       <%END%>');
	tmpl.push('      <%END%>');
	tmpl.push('      More <br/>Bets</a>');
	tmpl.push('     <%END%>');
	tmpl.push('    <%END%>');
	tmpl.push('    </div>');
	tmpl.push('   </div>');
	tmpl.push('  <%END%>');
	tmpl.push(' </div>');
	tmpl.push('</div>');
	templates["cashout_with_selns"] = tmpl.join("\n");

	// Smaller cashout section, with no selection details or partial cashout availability
	var tmpl = [];
	tmpl.push('<div class="bir-cash-out-details" id="<%id%>">');
	tmpl.push(' <div class="cash-out-bet">');
	tmpl.push('  <h3><%bet_type_name%></h3>');
	tmpl.push('  <p><%bet_desc%></p>');
	tmpl.push(' </div>');
	tmpl.push(' <div class="cash-out-stake"><strong><%XL STAKE%></strong>');
	tmpl.push('  <p><%stake_txt%></p>');
	tmpl.push('  <%IF leg_type == "E" %>');
	tmpl.push('   <span>(2 x <%line_stake_txt%>)</span>');
	tmpl.push('  <%END%>');
	tmpl.push(' </div>');
	tmpl.push(' <div class="cash-out-return"><strong><%XL CO_TO_RETURN%></strong> <%potential_txt%></div>');
	tmpl.push(' <%tmpl_play("cashout_button", self)%>');
	tmpl.push('</div>');
	templates["cashout_no_selns"] = tmpl.join("\n");

	// Very small button-only template for "My Bets" page
	var tmpl = [];
	tmpl.push('<div id="<%id%>" class="col">');
	tmpl.push(' <%tmpl_play("cashout_button", self)%>');


	tmpl.push(' <div class="partial-cashout" <%IF state === "SUSPENDED" || partial_co_state == "disabled" %>style="display: none;"<%END%>>');
	tmpl.push('  <%IF partial_cashout_link_enabled %>');
	tmpl.push('  <a href="?action=go_cashout_bet_list_page"><%XL PCO_MY_BETS_LINK%></a>');
	tmpl.push('  <%ELSE%>');
	tmpl.push('  <p><strong>or</strong></p>');
	tmpl.push('  <p><strong><%XL PCO_MY_BETS%></strong></p>');
	tmpl.push('  <input class="manual" type="text" <%IF partial_co_state != "active" %>disabled<%END%> value="">');
	tmpl.push('  <button class="currency" <%IF partial_co_state !== "active"%>disabled<%END%>><%ccy_code_html%></button>');
	tmpl.push('  <p><%XL PCO_MY_BETS_TT%></p>');
	tmpl.push('  <%END%>');
	tmpl.push(' </div>');
	tmpl.push('</div>');
	templates["cashout_button_only"] = tmpl.join('\n');

	// Cashout button
	// Separated as it can be used by itself
	var tmpl = [];
	tmpl.push('<div class="col cashout-btn">');
	tmpl.push(' <%IF state == "OK" %>');
	tmpl.push('  <button class="cashout">');
	tmpl.push('   <span><%XL CO_BTN_GENERAL%> <%XL CO_FOR%> </span> <%cashout_value_txt%>');
	tmpl.push('  </button>');
	tmpl.push(' <%ELSE IF state == "SUSPENDED" %>');
	tmpl.push('  <button class="cashout suspended">');
	tmpl.push('   <span class="icon-LockSuspend"></span>')
	tmpl.push('   <span><%XL CO_BTN_GENERAL_UPPER%><br><%XL CO_BTN_UNAVAILABLE%></span>');
	tmpl.push('  </button>');
	tmpl.push(' <%ELSE IF state == "DISABLED" %>');
	tmpl.push('  <button class="cashout disabled" disabled="true">');
	tmpl.push('   <span><%state_reason%></span>');
	tmpl.push('  </button>');
	tmpl.push(' <%ELSE IF state == "LOADING" %>');
	tmpl.push('  <button class="cashout" disabled="true">');
	tmpl.push('   <span><%XL CO_BTN_CASHING%> <%XL CO_FOR%> </span> <%cashout_value_txt%>');
	tmpl.push('  </button>');
	tmpl.push(' <%ELSE IF state == "COMPLETE" %>');
	tmpl.push('  <button class="cashout success">');
	tmpl.push('   <span><%XL CO_BTN_CASHING%> <%XL CO_FOR%> </span> <%cashout_value_txt%>');
	tmpl.push('  </button>');
	tmpl.push(' <%ELSE IF state == "CONFIRMATION" %>');
	tmpl.push('  <button class="cashout confirmation" disabled="true">');
	tmpl.push('   <%XL CO_BTN_CONFIRMATION%> <span><%cashout_value_txt%></span>');
	tmpl.push('  </button>');
	tmpl.push(' <%END%>');
	tmpl.push(' <%IF has_info_tooltip %>');
	tmpl.push('  <div class="cashout-tooltip">');
	tmpl.push('   <p class="information"><span>i</span></p>');
	tmpl.push('   <span class="tooltips">');
	tmpl.push('    <span class="arrow"></span>');
	tmpl.push('    <%IF cashout_unavail_reason == "SELN_SUSP" %>');
	tmpl.push('     <strong><%XL CO_CASH_OUT_SUSPENDED%></strong><br>');
	tmpl.push('     <%IF susp_seln_additonal > 0 %>');
	tmpl.push('      <%susp_seln_ev_desc%> + <%susp_seln_additonal%> <%XL CO_MORE_SUSPENDED%>');
	tmpl.push('     <%ELSE%>');
	tmpl.push('      <%susp_seln_ev_desc%>');
	tmpl.push('      <%IF bet_type =="SGL" %>');
	tmpl.push('       <%XL CO_SUSPENDED%>');
	tmpl.push('      <%ELSE%>');
	tmpl.push('       <%XL CO_PART_SUSPENDED%>');
	tmpl.push('      <%END%>');
	tmpl.push('     <%END%>');
	tmpl.push('    <%ELSE IF cashout_unavail_reason == "HR_SELN_IN_PLAY" %>');
	tmpl.push('     <strong><%XL CO_HR_INPLAY_HEADER%></strong><br>');
	tmpl.push('     <%XL CO_HR_IN_PLAY_TT1%>');
	tmpl.push('     <%inplay_seln_ev_desc%>');
	tmpl.push('     <%XL CO_HR_IN_PLAY_TT2%>');
	tmpl.push('    <%END%>');
	tmpl.push('   </span>');
	tmpl.push('  </div>');
	tmpl.push(' <%END%>');
	tmpl.push('</div>');
	templates["cashout_button"] = tmpl.join("\n");

	// Partial cashout slider
	var tmpl = [];
	tmpl.push('<div class="slider-wrapper" <%IF partial_co_state == "disabled" %>style="display: none;"<%END%>>');
	tmpl.push(' <button class="decrease" <%IF !partial_cashout_slider_shown %>style="display: none;"<%END%>>-</button>');
	tmpl.push(' <div class="slider" <%IF !partial_cashout_slider_shown %>style="display: none;"<%END%>>');
	tmpl.push('  <div class="stake" style="display: none;">Stake<span class="arrow"></span></div>');
	tmpl.push('  <div class="stakeBar" style="display: none; "></div>');
	tmpl.push('  <p><%XL PCO_SLIDER_MOVE1%>');
	tmpl.push('   <span class="cashout-tooltip"><%XL PCO_SLIDER_TT_HEADER%>');
	tmpl.push('    <span class="tooltips">');
	tmpl.push('     <span class="arrow">');
	tmpl.push('     </span><strong><%XL PCO_SLIDER_TT_HEADER%></strong>');
	tmpl.push('     <br><%XL PCO_SLIDER_TT%>');
	tmpl.push('    </span>');
	tmpl.push('   </span><%XL PCO_SLIDER_MOVE2%>');
	tmpl.push('  </p>');
	tmpl.push(' </div>');
	tmpl.push(' <button class="increase" <%IF !partial_cashout_slider_shown %>style="display: none;"<%END%>>+</button>');
	tmpl.push(' <div class="currency-wrapper">');
	tmpl.push('  <input class="manual" type="text" <%IF partial_co_state != "active" %>disabled<%END%> value="<%partial_cashout_input_value%>" style="display: <%IF partial_cashout_input_shown %>inline<%ELSE%>none<%END%>;" >');
	tmpl.push('  <div class="cashout-tooltip">');
	tmpl.push('   <button class="currency <%IF partial_cashout_input_shown %>active<%END%>" <%IF partial_co_state !== "active"%>disabled<%END%>>');
	tmpl.push('    <%ccy_code_html%>');
	tmpl.push('   </button>');
	tmpl.push('   <span class="tooltips"><span class="arrow"></span><%XL PCO_TT_CCY_BTN%></span>');
	tmpl.push('  </div>');
	tmpl.push(' </div>');
	tmpl.push('</div>');
	templates["partial_cashout_slider"] = tmpl.join("\n");

	// Potental Bet Preview
	var tmpl = [];
	tmpl.push('<div <%IF !bet_preview_shown %>style="display: none;"<%END%> class="potential-returns bet-preview">');
	tmpl.push(' <div class="col">');
	tmpl.push('  <span class="cashout-tooltip">');
	tmpl.push('   <p class="information"><span>i</span></p>');
	tmpl.push('   <%IF leg_type == "E" %>');
	tmpl.push('    <span <%IF show_ew_terms_tt %> style="display: block;"<%END%>  class="tooltips each-way">');
	tmpl.push('     <span class="arrow"></span>');
	tmpl.push('     <p>');
	tmpl.push('      <strong><%XL PCO_BET_TYPE%></strong>');
	tmpl.push('      <a href="javascript:void(0);"');
	tmpl.push('       <%IF show_ew_terms_tt%> style="display: block;"<%ELSE%>style="display:none;"<%END%> class="close">x</a>');
	tmpl.push('     </p>');
	tmpl.push('     <p class="each-way"><%potential_ew_bet_type%></p>');
	tmpl.push('     <p class="green">');
	tmpl.push('     <%LOOP i potential_bet_seln_tooltips.length%>');
	tmpl.push('      <%potential_bet_seln_tooltips[i]%>');
	tmpl.push('      <span <%IF ew_terms_changed %> class ="each-way-terms"<%END%> >');
	tmpl.push('       <%potential_bet_ew_terms_tooltips[i]%><br>');
	tmpl.push('      </span>');
	tmpl.push('     <%END%>');
	tmpl.push('    </span>');
	tmpl.push('   <%ELSE%>');
	tmpl.push('    <span class="tooltips">');
	tmpl.push('     <span class="arrow"></span>');
	tmpl.push('     <strong><%XL PCO_BET_TYPE%></strong>');
	tmpl.push('     <strong><%potential_bet_type%></strong>');
	tmpl.push('     <%LOOP i potential_bet_seln_tooltips.length%>');
	tmpl.push('      <%potential_bet_seln_tooltips[i]%><br>');
	tmpl.push('     <%END%>');
	tmpl.push('    </span>');
	tmpl.push('   <%END%>');
	tmpl.push('  </span>');
	tmpl.push(' </div>');
	tmpl.push(' <div class="col">');
	tmpl.push('  <p><%XL PCO_PREVIEW_TEXT1%>');
	tmpl.push('   <strong><%partial_cashout_value%></strong><%XL PCO_PREVIEW_TEXT2%>');
	tmpl.push('   <strong><%potential_bet_return%></strong><%XL PCO_PREVIEW_TEXT3%>');
	tmpl.push('  </p>');
	tmpl.push(' </div>');
	tmpl.push('</div>');
	templates["bet_preview"] = tmpl.join("\n");

	// Market header for event pages
	var tmpl = [];
	tmpl.push('<div id="cashout_contents_<%ev_mkt_id%>" data-ev-mkt-id="<%ev_mkt_id%>" class="sub-hdr fl clear full-width cashout-mkt-hdr">');
	tmpl.push(' <h3>');
	tmpl.push('  <a href="javascript:void(0);" class="exp-coll-mkt-hdr">');
	tmpl.push('   <span class="sub_expand_collapse"></span>');
	tmpl.push('   <span class="sub_market_name"><%ev_mkt_name%></span>');
	tmpl.push('  </a>');
	tmpl.push(' </h3>');
	tmpl.push('</div>');
	tmpl.push('<div data-ev-mkt-id="<%ev_mkt_id%>" class="fb-sub-content cashout-mkt-content" id="cashout_subcontents_<%ev_mkt_id%>"></div>');
	templates["cashout_event_page_market_header"] = tmpl.join("\n");



	return templates;

})();


/* Writing crunched file cashout_widget.js */

// Manager for cashout widgets
// Polls via ajax and updates widgets accordingly
// This is initialised when needed by the core cashout code.
ob.Cashout.WidgetManager = function() {
	if (this === window || this === ob.Cashout) { throw "ob.Cashout.WidgetManager must be instantiated, not called!" }

	// Keep a map of bet to widget.
	// Bets can have more than one widget on the page, if they appear in multiple containers,
	// so this is keyed by bet_id then container. However, widgets for the same bet in multiple
	// places are assumed to use the same bet information, so most functions only deal with the bet_id.
	this.widget_map = {};
}

ob.Cashout.WidgetManager.prototype = (function() {

	// Returns true if any widgets exist for the given bet_id
	function hasWidget(bet_id) {
		return (typeof this.widget_map[bet_id] !== "undefined");
	}

	// Create new widgets for all the given containers for the given bet_id, using
	// the bet data supplied
	function createWidget(bet_id, widget_options, bet_data, push_msg_id) {

		var success = 0;
		// If no options are passed, just return
		if (widget_options === null) {
			return 0;
		}

		// Initialise if this is the first time we've seen this bet
		if (!this.hasWidget(bet_id)) {
			this.widget_map[bet_id] = {};
		}

		// Create a new widget only if one doesn't already exist
		var container = widget_options.container;
		if (typeof this.widget_map[bet_id][container] === "undefined") {
			try {
				this.widget_map[bet_id][container] = new ob.Cashout.Widget(this,bet_id,container,widget_options,bet_data,push_msg_id);
				success = 1;
			} catch (e) {
				console.log(e);
			}
		}

		if (success) {
			return this.widget_map[bet_id][container];
		}
		return 0;
	}

	// Update all existing widgets for a bet_id to use the new data given
	function updateWidget(bet_id, bet_data) {
		if (!this.hasWidget(bet_id)) {
			return;
		}

		// Update all the widgets for this bet
		for (var container in this.widget_map[bet_id]) {
			this.widget_map[bet_id][container].update(bet_data);
		}
	}

	// Ask the widgets which of them want an ajax refresh and return the bet_ids
	// that they associate with.
	function getUpdatesRequired() {
		var updates_required = [];
		for (var bet_id in this.widget_map) {
			for (var container in this.widget_map[bet_id]) {
				if (this.widget_map[bet_id][container].requiresUpdate() && updates_required.indexOf(bet_id) === -1) {
					updates_required.push(bet_id);
				}
			}
		}
		return updates_required;
	}

	return {
		hasWidget: hasWidget,
		createWidget: createWidget,
		updateWidget: updateWidget,
		getUpdatesRequired: getUpdatesRequired
	}
})();


// Constructor for the cashout widget
// This is a section of the page that represents a cashoutable bet, which the customers can interact with.
// There can be many of these, they should be created on demand by the WidgetManager
ob.Cashout.Widget = function(widgetManager, bet_id, container_id, opts, bet_data, msg_id) {
	if (this === window || this === ob.Cashout) { throw "ob.Cashout.Widget must be instantiated, not called!" }

	// Reference to the manager for this widget
	this.widgetManager = widgetManager;

	// Bet that this widget represents
	this.bet_id = bet_id;

	// Location on the page that this widget lives
	this.container_id = container_id;

	// Combine the two into a unique ID for the widget
	this.id = container_id + "_" + bet_id;

	// Options that are used to configure the widget
	this.opts = opts;

	// The details of the bet and selection that should be displayed
	// This should never be modified unless the base data is being changed (e.g. an ajax update)
	this.bet_data = $j.extend(true, {}, bet_data);

	// Keep track of the current state of this widget
	// This will change when the widget is suspended, etc.
	this.state = bet_data.state;

	// The counter is used to limit the number of ajax requests sent by an idle
	// page while at the same time ensuring that we don't display cached data for too long.
	// Ajax requests are only made while this is > 0
	this.update_counter = 0;

	// Each widget subscribes itself to push so it can handle events as necessary
	// This also means that we can more easily unsubscribe later on.
	// If we are given a push message ID then use that to start with, otherwise use one from the global config
	this.last_msg_id = (msg_id || ob.Cashout.getCfg("push_msg_id"));

	if (this.opts.push_enabled) {
		this.registerPushChannels();
	}

	this.display();
	this.bindEvents();
}

// Prototype for the cashout widget
// Contains functionality shared across all widget objects
ob.Cashout.Widget.prototype = (function() {

	var instance = ob.Cashout;
	var core = ob.Cashout.core;

	// Display this widget on the page
	function display() {

		if (!scone_exists(this.container_id)) {
			throw "Invalid container: " + this.container_id;
			return;
		}

		// Create a new info object that we can modify for use in the template
		var info = {};
		info.id              = this.id;
		info.bet_id          = this.bet_id;
		info.state           = this.state;

		info.leg_type            = this.bet_data.leg_type;
		info.bet_type            = this.bet_data.bet_type;
		info.bet_type_name       = this.bet_data.bet_type_name;
		info.bet_start_time      = this.bet_data.bet_start_time;
		info.bet_desc            = this.bet_data.bet_desc;
		info.stake               = this.bet_data.stake;
		info.stake_txt           = core.formatMoney(this.bet_data.stake);
		info.line_stake_txt      = core.formatMoney(this.bet_data.line_stake);
		info.num_lines           = this.bet_data.num_lines;
		info.potential_txt       = core.formatMoney(this.bet_data.potential_payout);
		info.cashout_value_txt   = core.formatMoney(this.partial_cashout_value || this.bet_data.cashout_value);
		info.ccy_code_html       = print_ccy_symbol(get_pref("ccy_code"));
		info.legs                = this.bet_data.legs
		info.show_more_bets_link = this.opts.show_more_bets_link;
		this.bet_data.potential_bet.show_ew_terms_tt = false;

		// Each Way terms
		if (this.bet_data.leg_type == "E") {

			var ew_terms =  "E/W ";
			for (var leg_no in this.bet_data.legs) {

				var leg     = this.bet_data.legs[leg_no];
				var ew_desc = leg.ew_fac_num + "/" + leg.ew_fac_den + " places " + leg.ew_places_str;
				ew_terms    = ew_terms.concat(ew_desc);
			}

			info.ew_desc = ew_terms;

			if (this.bet_data.potential_bet.ew_terms_changed) {
				// if there was a change in EW terms we need to enforce the tooltip to the customer
				this.bet_data.potential_bet.show_ew_terms_tt = true;
			}
		}

		// If there is a receipt number to display (usually as a result of a partial cashout)
		// then do so.
		info.bet_receipt = (this.bet_data.bet_receipt || "");

		// Recreate the tooltip for the cashout button
		generateSuspendedSelnTooltip.call(this, info);

		info.selns = [];
		if (this.opts.show_selection_details) {
			for (var leg_no in this.bet_data.legs) {
				var ev_oc_id = this.bet_data.legs[leg_no].ev_oc_id;
				var seln_info = {};
				seln_info.ev_oc_id               = ev_oc_id;
				seln_info.ev_id                  = this.bet_data.selns[ev_oc_id].ev_id;
				seln_info.ev_class_id            = this.bet_data.selns[ev_oc_id].ev_class_id;
				seln_info.category               = this.bet_data.selns[ev_oc_id].category;
				seln_info.class_sort             = this.bet_data.selns[ev_oc_id].class_sort;
				seln_info.type_desc              = this.bet_data.selns[ev_oc_id].type_desc;
				seln_info.ev_desc                = this.bet_data.selns[ev_oc_id].ev_desc;
				seln_info.ev_mkt_desc            = this.bet_data.selns[ev_oc_id].ev_mkt_desc;
				seln_info.seln_desc              = this.bet_data.selns[ev_oc_id].seln_desc;
				seln_info.ev_start_date_time_str = this.bet_data.selns[ev_oc_id].ev_start_date_time_str;
				seln_info.ev_score_home          = this.bet_data.selns[ev_oc_id].ev_score_home;
				seln_info.ev_score_away          = this.bet_data.selns[ev_oc_id].ev_score_away;
				seln_info.period_id              = this.bet_data.selns[ev_oc_id].period_id;
				seln_info.ev_is_bir              = this.bet_data.selns[ev_oc_id].ev_is_bir;
				seln_info.result                 = this.bet_data.selns[ev_oc_id].result;
				seln_info.result_desc            = this.bet_data.selns[ev_oc_id].result_desc;
				seln_info.is_football_event      = this.bet_data.selns[ev_oc_id].is_football_event;
				seln_info.home_team_id           = this.bet_data.selns[ev_oc_id].home_team_id;
				seln_info.home_team_img          = this.bet_data.selns[ev_oc_id].home_team_img;
				seln_info.home_team_name         = this.bet_data.selns[ev_oc_id].home_team_name;
				seln_info.away_team_id           = this.bet_data.selns[ev_oc_id].away_team_id;
				seln_info.away_team_img          = this.bet_data.selns[ev_oc_id].away_team_img;
				seln_info.away_team_name         = this.bet_data.selns[ev_oc_id].away_team_name;
				seln_info.is_horse_race_event    = this.bet_data.selns[ev_oc_id].is_horse_race_event;
				seln_info.silk_img_url           = this.bet_data.selns[ev_oc_id].silk_img_url;
				seln_info.silks_files_desc       = this.bet_data.selns[ev_oc_id].silks_files_desc;
				seln_info.runner_num             = this.bet_data.selns[ev_oc_id].runner_num;
				seln_info.hr_ev_url              = this.bet_data.selns[ev_oc_id].hr_ev_url;
				info.selns.push(seln_info);
			}
		}

		// We might be re-playing an existing cashout section, so if there is a bet
		// preview section then we need to regenerate the info for it
		setBetPreviewInfo.call(this,info);

		// Partial Cash out Widget Functionality
		// Decide whether to display partial cash out widget:
		// - disabled: not displayed
		// - inactive: displayed but inactive greyed out
		// - enabled : displayed and active
		info.partial_co_state = "disabled";
		if (this.opts.partial_cashout_enabled && this.bet_data.partial_cashout_available === "Y" && this.state !== "COMPLETE" && this.state !== "CONFIRMATION") {
			info.partial_co_state = "active";
			if (this.bet_data.partial_cashout_allowable === "N") {
				info.partial_co_state = "inactive";
			}
		}

		// If we're redrawing the widget after it has first been displayed, then we need to make sure
		// we keep the current state of things the user might have done, i.e. that we keep showing anything
		// we're currently showing, and keep hiding anything we're not.
		info.hidden                        = false;
		info.wrapper_class                 = "cash-out-wrapper";
		info.cashout_detail_shown          = false;
		info.bet_preview_shown             = false;
		info.bet_receipt_shown             = (info.bet_receipt !== "");
		info.partial_cashout_success_shown = false;
		info.partial_cashout_slider_shown  = this.opts.partial_cashout_enabled;
		info.partial_cashout_input_shown   = false;
		info.partial_cashout_input_value   = "";
		info.partial_cashout_link_enabled  = this.opts.partial_cashout_link_enabled;

		if (this.elem) {
			info.hidden                        = this.elem.is(":hidden");
			info.wrapper_class                 = this.elem.attr("class");
			info.cashout_detail_shown          = this.elem.find('#' + this.id + "_selns").is(":visible");
			info.bet_preview_shown             = this.elem.find("div.bet-preview").is(":visible");
			info.partial_cashout_success_shown = this.elem.find("div.partial-cashout-success").is(":visible");

			// Bet receipt is a little different as it doesn't initially exist
			var receipt_elem = this.elem.find("p.cashout-linked-receipt");
			if (receipt_elem.length > 0 && receipt_elem.is(":hidden")) {
				info.bet_receipt_shown = false;
			}

			if (this.opts.partial_cashout_enabled) {
				info.partial_cashout_input_shown = this.elem.find("input.manual").is(":visible");
				info.partial_cashout_input_value = this.elem.find("input.manual").val();
				info.partial_cashout_slider_shown = !info.partial_cashout_input_shown;

				// We also need to keep the current slider element. Note that playing a new copy of the old html is not
				// good enough in this case because the slider js object has references to the DOM objects that it is linked to.
				// If we play new elements into the page then it'll have the wrong references.
				// So detach it for now, we'll add in back shortly.
				var partial_cashout_slider_element = this.elem.find("div.slider input").detach();
			}
		}

		// Self-referential pointer for template inheritance
		info.self = info;

		var widget_html = tmpl_play(this.opts.template_name, info);

		if (!scone_item_exists(this.id)) {
			scone_add_item(this.container_id, this.id, widget_html, this);
		} else {
			scone_replace_item(this.id, widget_html, this, false);
		}

		// Keep an internal reference to this element, comes in handy later
		this.elem = $j('#' + this.id);

		// Re-attach the partial cashout slider if we detached it earlier
		if (typeof partial_cashout_slider_element !== "undefined") {
			this.elem.find("div.slider div.stakeBar").after(partial_cashout_slider_element);
		}

		// Initialise the partial cashout slider, if necessary
		if (this.opts.partial_cashout_enabled && this.state !== "COMPLETE" && this.state !== "CONFIRMATION") {
			initPartialCashoutSlider.call(this);
		}

		// Add a BIR clock to each selection if needs be
		if (this.opts.show_selection_details && show_bir_clocks === "Y") {
			for (var ev_oc_id in this.bet_data.selns) {
				var seln = this.bet_data.selns[ev_oc_id];
				if (typeof seln.period_id !== "undefined" && seln.period_id >= 0) {
					addClockEvent(seln.ev_id, seln.period_info, this.id + "_" + ev_oc_id + "_clock_");
				}
				updatePeriodClock(seln);
			}
		}

	}

	// Bind onEvent functions used in the widget.
	// These are actually bound to the container and filtered by the widget since scone_replace_item
	// is known to cause memory leaks when jquery events are bound directly to scone items.
	function bindEvents() {
		var t = this;
		$j('#' + this.container_id).on("click", '#' + this.id + " div.cashout-btn", function() {
				// Make the casout request
				var skip_ew_term_check = false;
				t.doCashout(skip_ew_term_check);
			});

		if (this.opts.show_selection_details) {
			$j('#' + this.container_id).on("click", '#' + this.id + " div.seln-expand", function() {
				// Toggle the selection display
				var seln_container = t.elem.find('#' + t.id + "_selns");
				var seln_indicator = t.elem.find("div.seln-expand-arrow");

				if (seln_container.is(":visible")) {
					seln_container.hide();
					seln_indicator.removeClass("close icon-chevron_down").addClass("expand icon-chevron_right");
				} else {
					seln_container.show();
					seln_indicator.removeClass("expand icon-chevron_right").addClass("close icon-chevron_down");
				}
			});
		}

		// Partial cashout functionality for the slider and buttons
		if (this.opts.partial_cashout_enabled) {
			$j('#' + this.container_id)
				.on("click", '#' + this.id + " button.currency", function() {
					// Toggle between the slider and the manual input when the currency button is clicked
					t.elem.find("button.decrease, button.increase, div.slider, input.manual").toggle();
					$j(this).toggleClass("active");
				})
				.on("click", '#' + this.id + " a.close", function() {
					t.elem.find('span.tooltips').css("display","");
					closePartialEwTooltip.call(t);
				})
				.on("click", '#' + this.id + " button.increase", function() {
					// Go up one step when the increase button is clicked
					// We also need to update the value of the manual text entry,
					// the cashout button, and potentially the colour of the bar.
					var new_slider_from = core.calcSliderFromValue(t.slider.from, t.slider.ionRangeSlider.options.step, t.slider.ionRangeSlider.options.min, "INCR");
					var new_value = Math.min(new_slider_from, t.slider.ionRangeSlider.options.max);

					// Update the slider
					t.slider.ionRangeSlider.update({
						from: new_value
					});

					// Set the manual input to be the same value, in case the user switches
					t.elem.find("input.manual").val(new_value.toFixed(2));

					// Update the widget accordingly
					updatePartialCashoutValue.call(t, new_value.toFixed(2));
				})
				.on("click", '#' + this.id + " button.decrease", function() {
					// Go down one step when the increase button is clicked
					// We also need to update the value of the manual text entry,
					// the cashout button, and potentially the colour of the bar.
					var new_slider_from = core.calcSliderFromValue(t.slider.from, t.slider.ionRangeSlider.options.step, t.slider.ionRangeSlider.options.min, "DECR");
					var new_value = Math.max(new_slider_from, t.slider.ionRangeSlider.options.min);

					// Update the slider
					t.slider.ionRangeSlider.update({
						from: new_value
					});

					// Set the manual input to be the same value, in case the user switches
					t.elem.find("input.manual").val(new_value.toFixed(2));

					// Update the widget accordingly
					updatePartialCashoutValue.call(t, new_value.toFixed(2));
				})
				.on("click", '#' + this.id + " div.stake", function() {
					// Set the bar to the previous stake when the stake indicator is clicked
					// We also need to update the value of the manual text entry,
					// the cashout button, and potentially the colour of the bar.
					var new_value = t.bet_data.stake;

					// Update the slider
					t.slider.ionRangeSlider.update({
						from: new_value
					});

					// Set the manual input to be the same value, in case the user switches
					t.elem.find("input.manual").val(new_value.toFixed(2));

					// Update the widget accordingly
					updatePartialCashoutValue.call(t, new_value.toFixed(2));
				})
				.on("keyup", '#' + this.id + " input.manual", function() {
					// Validate entry to the manual input and update the widget accordingly
					var value = $j(this).val();
					while (value.length > 0) {
						if (core.isNumeric(value)) break;
						value = value.substring(0, value.length-1);
					}
					// Update the manual input in case we removed characters
					$j(this).val(value);

					// Update the bar to reflect the new value
					if (t.slider) {

						if (value === "") {
							t.slider.ionRangeSlider.update({
								from: t.slider.ionRangeSlider.options.max
							});
						} else {
							t.slider.ionRangeSlider.update({
								from: Math.min(value, t.slider.ionRangeSlider.options.max)
							});
						}
					}

					// Update the widget
					updatePartialCashoutValue.call(t, value);
				});
		}
	}

	// Create the partial cashout slider on the widget.
	// This is called each time the widget is displayed, and will create or recreate the slider as appropriate
	function initPartialCashoutSlider() {
		if (typeof $j().ionRangeSlider === "undefined") { return; }
		if (!this.opts.partial_cashout_slider_enabled) { return; }

		var partial_cashout_active = (this.bet_data.partial_cashout_allowable === "Y" && this.bet_data.partial_cashout_available === "Y");

		var stake = parseFloat(this.bet_data.stake);
		var min_potential_stake = parseFloat(isNaN(this.bet_data.potential_bet.min_stake) ? 0 : this.bet_data.potential_bet.min_stake);
		var slider_max = parseFloat(isNaN(this.bet_data.cashout_value) ? 0 : this.bet_data.cashout_value);

		// Minimum partial cashout value available
		var min_pco_value = isNaN(parseFloat(instance.getCfg("min_pco_value"))) ? 0 : parseFloat(instance.getCfg("min_pco_value"));

		// We show the position on the bar of the previous stake, if the maximum cashout value is >= the stake plus a minimum bet amount
		// and only if the stake is greater than or equal to the min partial cashout value
		var show_original_stake = ((slider_max >= stake + min_potential_stake) && (stake >= min_pco_value));

		// We also need to consider if there is a current value to display, which can happen when the widget is redrawn.
		// But note that the slider maximum may have changed, so we need to account for the old value being out of bounds.
		var slider_value = Math.min(slider_max, this.partial_cashout_value || slider_max);

		// slider's step value must be decided based on the full cashout value and the slider_step_map_obj
		// slider_step_map_obj is created from the cfg item COUT_SLIDER_STEP
		var default_step = 0.01;
		var step_value = core.getStepValue(this.bet_data.cashout_value, instance.getCfg("slider_step"), min_pco_value, default_step);

		var t = this;
		var slider_options = {
			type: "single",
			min: min_pco_value,
			max: slider_max,
			from_min: 0,
			from: slider_value,
			hide_min_max: true,
			hide_from_to: true,
			step: step_value,
			disable: !partial_cashout_active,
			onUpdate: function(callback_obj) {
				// Make sure the bar colour is updated whenever the slider is changed by a function call rather than the user
				// Pass the from value from the callback_obj since it holds the exact current value
				var current_value = callback_obj.from;

				updatePartialCashoutSliderColour.call(t, current_value.toFixed(2));
			},
			onChange: function(callback_obj) {
				// When the bar changes, we need to update the value of the manual text entry,
				// the cashout button, and potentially the colour of the bar.
				// This is inline so that it can make use of the "t" reference to the "this" object
				// Be very careful in here not to do anything that causes the slider to be re-initialised as it will
				// forcibly drop the user's control.
				var current_value = callback_obj.from;

				// Pass the from value from the callback_obj since it holds the exact current value
				updatePartialCashoutSliderColour.call(t, current_value.toFixed(2));

				// Set the manual input to be the same value, in case the user switches
				t.elem.find("input.manual").val(current_value.toFixed(2));

				// Update the widget accordingly
				updatePartialCashoutValue.call(t, current_value.toFixed(2));
			}
		}

		if (this.slider) {
			// If the slider has already been initialised then we don't want to create a whole new one.
			// Instead, re-draw the current one. This is important as the data that drives it may have changed.
			this.slider.ionRangeSlider.update(slider_options);
		} else {
			// Otherwise create one using the ionRangeSlider jquery addon
			var anchor = this.elem.find("div.slider-wrapper div.stakeBar");
			this.slider = $j('<input type="text" value="" class="irs-hidden-input" readonly="">').insertAfter(anchor).ionRangeSlider(slider_options).data();
		}

		// Set the initial bar colour
		this.elem.find("div.slider-wrapper span.irs-bar, div.slider-wrapper span.irs-bar-edge").addClass("bg-green");

		// Show the position on the bar of the previous stake
		if (show_original_stake) {
			var stake_percentage = 100*(stake-min_pco_value)/(slider_max-min_pco_value);
			this.elem.find("div.slider-wrapper div.stake").css("left", stake_percentage-3 + "%");
			this.elem.find("div.slider-wrapper div.stakeBar").css("width", stake_percentage + "%");
			this.elem.find("div.slider-wrapper div.stakeBar, div.slider-wrapper div.stake").show();
		}

		// Set some parameters for the bar colour
		this.slider.show_original_stake = show_original_stake;
		this.slider.original_stake = stake;

		// When the slider is diabled or enabled, the same behaviour should be applied for increase
		// and decrease buttons
		if (partial_cashout_active) {
			enablePartialCashoutSlider.call(this)
		} else {
			disablePartialCashoutSlider.call(this)
		}

		// Set the initial difference between the current value and the stake
		this.slider.stake_diff_state = Math.sign(stake - this.slider.from);
	}

	// Set the slider to the correct colour
	// When your partial cashout is staking more than the original stake, there
	// is a yellow bar representing that stake, so the slider needs to be the original green.
	// When your partial cashout is staking less than the original, we need to hide
	// the static bar and instead make the slider yellow.
	function updatePartialCashoutSliderColour(from_value) {
		// Check the bar colour. We don't need to do this if the stake section is not going to be displayed.
		if (this.slider.show_original_stake) {
			var current_value = from_value;
			// The earlier check for state difference won't be applicable since whenever slider.update is called
			// it drops the class attached to the span.irs-bar and span.irs-bar-edge elements
			if (current_value < this.slider.original_stake) {
				// If the stake bar is bigger than the current slider position, we hide it and make the slider yellow instead
				this.elem.find("div.slider-wrapper div.stakeBar, div.slider-wrapper div.stake").hide();
				this.elem.find("div.slider-wrapper span.irs-bar, div.slider-wrapper span.irs-bar-edge").removeClass("bg-green").addClass("bg-yellow");
			} else {
				// Otherwise the stake bar is shown and the slider is left green
				this.elem.find("div.slider-wrapper div.stakeBar, div.slider-wrapper div.stake").show();
				this.elem.find("div.slider-wrapper span.irs-bar, div.slider-wrapper span.irs-bar-edge").removeClass("bg-yellow").addClass("bg-green");
			}
		}
	}

	// Disable the partial cashout slider - elements are greyed out and not clickable
	function disablePartialCashoutSlider() {

		// Disable slider, if it exists and is currently enabled
		if (typeof this.slider !== "undefined" && this.slider.enabled) {
			this.slider.ionRangeSlider.update({
				disable:true
			});
			this.slider.enabled = false;
		}
		// Disable plus/minus buttons and the manual input
		this.elem.find("button.increase, button.decrease, input.manual").prop("disabled", true);
		// Add a "disabled" class to the stake bar
		this.elem.find("div.slider-wrapper div.stakeBar").addClass("disabled");
	}

	// Destroy the partial cashout slider - elements are deleted and hidden
	function destroyPartialCashoutSlider() {

		// Disable everything first
		disablePartialCashoutSlider.call(this);

		// Destroy the slider, if it exists
		if (typeof this.slider !== "undefined") {
			this.slider.ionRangeSlider.destroy();
		}

		// Hide the whole partial cashout division
		this.elem.find("div.slider-wrapper").hide();

		delete this.slider;
	}

	// Enable the partial cashout slider - elements are active and clickable
	function enablePartialCashoutSlider() {

		// Enable slider, if it exists and is currently disabled
		if (typeof this.slider !== "undefined" && !this.slider.enabled) {
			this.slider.ionRangeSlider.update({
				disable:false
			});
			this.slider.enabled = true;
		}
		// Enable plus/minus buttons and the manual input
		this.elem.find("button.increase, button.decrease, input.manual").prop("disabled", false);
		// Remove the "disabled" class from the stake bar
		this.elem.find("div.slider-wrapper div.stakeBar").removeClass("disabled");
	}

	function closePartialEwTooltip() {
		// flag it as closed
		this.bet_data.potential_bet.show_ew_terms_tt  = false;
		updateBetPreview.call(this);
	}

	// Update the widget with a partial cashout offer
	function updatePartialCashoutValue(value) {
		// Minimum partial cashout value available
		var min_pco_value = isNaN(parseFloat(instance.getCfg("min_pco_value"))) ? 0 : parseFloat(instance.getCfg("min_pco_value"));

		// If the value is blank or invalid then default to using the normal cashout value of the bet
		if (value === "" || isNaN(value) || parseFloat(value) >= parseFloat(this.bet_data.cashout_value)) {
			delete this.partial_cashout_value;
		} else if (parseFloat(value) < min_pco_value) {
			this.partial_cashout_value = min_pco_value;
		} else {
			this.partial_cashout_value = value;
		}

		// If partial cashout is enabled, we might need to disable the button based on the current partial cashout value
		var disable_button = false;
		var disable_reason = "";
		if (this.opts.partial_cashout_enabled && typeof this.partial_cashout_value !== "undefined") {
			// If the current value means the new bet would be below the minimum potential bet stake
			// then disable the button

			// We multiply by 100 to get around issues with floats in JS. As all the values being processed are monetary we will
			// only ever have two decimal places. The min stake is dealt with in the same way to allow for the comparison.
			var potential_bet_stake = (Math.round(this.bet_data.cashout_value * 100) - Math.round(this.partial_cashout_value * 100));
			if (potential_bet_stake < Math.round(parseFloat(this.bet_data.potential_bet.min_stake) * 100)) {
				disable_button = true;
				disable_reason = tmpl_xl("PCO_DISABLE_NEW_STAKE_TOO_LOW");

			// If the current value is 0 then we also disable the button
			} else if (parseFloat(this.partial_cashout_value) === 0) {
				disable_button = true;
				disable_reason = tmpl_xl("PCO_DISABLE_ZERO_VALUE");
			}
		}
		// Re-play the cashout button with the new value
		if (disable_button && this.state !== "DISABLED") {
			this.setStatus("DISABLED", disable_reason );
		} else if (!disable_button && this.state === "DISABLED") {
			this.setStatus("OK");
		} else {
			updateCashoutButton.call(this);
		}

		// Re-play the bet preview section
		updateBetPreview.call(this);

	}

	// If the cashout is unavailable due to selection suspension then we need to
	// display an appropriate message. This sets that message into the provided
	// info object for use in a template
	function generateSuspendedSelnTooltip(info) {
		info.has_info_tooltip       = false;
		info.cashout_unavail_reason = "";

		if (this.bet_data.cashout_unavail_reason === 'SELN_SUSP') {

			info.has_info_tooltip       = true;
			info.cashout_unavail_reason = this.bet_data.cashout_unavail_reason;

			var cashout_unavail_reason_selns = this.bet_data.cashout_unavail_reason_selns.split(" ");
			var ev_oc_id                     = cashout_unavail_reason_selns[0];

			if (info.bet_type == 'SGL') {
				info.susp_seln_ev_desc = this.bet_data.selns[ev_oc_id].ev_desc;
			} else {
				info.susp_seln_ev_desc = this.bet_data.selns[ev_oc_id].ev_desc + ':' + this.bet_data.selns[ev_oc_id].seln_desc;
			}
			info.susp_seln_additonal  = (cashout_unavail_reason_selns.length - 1);

		} else if (this.bet_data.cashout_unavail_reason === 'HR_SELN_IN_PLAY') {

			info.has_info_tooltip       = true;
			info.cashout_unavail_reason = this.bet_data.cashout_unavail_reason;

			// Grab the selection description of the HR in play event
			var inplay_ev_oc_id      = this.bet_data.cashout_unavail_reason_selns;
			info.inplay_seln_ev_desc = this.bet_data.selns[inplay_ev_oc_id].seln_desc;
		}
	}

	// Generate the template parameters required for the bet preview
	function setBetPreviewInfo(info) {

		info.potential_bet_type = this.bet_data.potential_bet.bet_type;
		info.potential_bet_stake = (this.bet_data.cashout_value - this.partial_cashout_value).toFixed(2);
		info.partial_cashout_value = core.formatMoney(this.partial_cashout_value || this.bet_data.cashout_value);

		// Compare the potential payout with the max payout of the bet type
		var potential_bet_return = info.potential_bet_stake * this.bet_data.potential_bet.normalised_potential_payout;
		var max_payout           = parseFloat(isNaN(this.bet_data.potential_bet.max_payout) ? 0 : this.bet_data.potential_bet.max_payout);

		if (parseFloat(max_payout) > 0 && parseFloat(potential_bet_return) > parseFloat(max_payout)) {
			potential_bet_return = max_payout;
		}
		info.potential_bet_return = core.formatMoney(potential_bet_return);

		// Bind new bet's price only in case of SGL bet
		if (Object.keys(this.bet_data.potential_bet.selns).length === 1) {
			for (var ev_oc_id in this.bet_data.potential_bet.selns) {break;}
			info.potential_price  = " @ " + this.bet_data.potential_bet.selns[ev_oc_id].price_str;
		} else {
			info.potential_price = "";
		}

		info.potential_bet_seln_tooltips = [];
		info.potential_bet_ew_terms_tooltips  = [];
		info.potential_ew_bet_type = "";
		this.bet_data.potential_bet.ew_seln_str = [];

		// Iterate through legs to create the tooltip
		for (var leg_no in this.bet_data.potential_bet.legs) {

			var leg      = this.bet_data.potential_bet.legs[leg_no];
			var seln     = this.bet_data.potential_bet.selns[leg.ev_oc_id];
			var ew_desc  = "";
			var seln_str = seln.seln_desc + ' @ ' + seln.price_str;

			// if bet is each way we need to grab that info for the tooltip
			if (this.bet_data.leg_type == "E") {

				// Create a proper EW term string
				var ew_terms_desc = leg.ew_fac_num + "/" + leg.ew_fac_den + " places " + leg.ew_places_str;
				ew_desc                    = " :"+ ew_terms_desc;
				info.potential_bet_ew_terms_tooltips.push(ew_desc);

				// Format the selection description if needed
				seln_str                   = core.formatTootlipInfo(seln_str,ew_desc,49);

				// Bet type
				info.potential_ew_bet_type = "E/W " + this.bet_data.potential_bet.bet_type;
			}
			info.potential_bet_seln_tooltips.push(seln_str);
			this.bet_data.potential_bet.ew_seln_str.push(seln_str + ew_desc);
		}

		info.leg_type         = this.bet_data.leg_type
		info.show_ew_terms_tt = this.bet_data.potential_bet.show_ew_terms_tt;
		info.ew_terms_changed = this.bet_data.potential_bet.ew_terms_changed;
	}

	// Set the internal state of the widget and update the cashout button accordingly
	function setStatus(state, reason) {
		this.state = state;
		this.state_reason = reason;

		// Re-play the cashout button to reflect the new state
		updateCashoutButton.call(this);

		// We might also need to do something to the partial cashout slider
		if (this.opts.partial_cashout_enabled) {
			switch (state) {
				case "DISABLED":
				case "OK":
					enablePartialCashoutSlider.call(this);
					break;
				case "COMPLETE":
					this.elem.find("div.bet-preview").hide();
					destroyPartialCashoutSlider.call(this);
					break;
				case "SUSPENDED":
					this.elem.find("div.bet-preview").hide();
					disablePartialCashoutSlider.call(this);
					break;
				default:
					disablePartialCashoutSlider.call(this);
					break;
			}
		}
	}

	// Re-play the cashout button template with current data
	function updateCashoutButton() {
		var info = {};
		info.state = this.state;
		info.state_reason = this.state_reason;
		info.cashout_value_txt = core.formatMoney(this.partial_cashout_value || this.bet_data.cashout_value);
		info.bet_type = this.bet_data.bet_type;

		generateSuspendedSelnTooltip.call(this, info);

		this.elem.find('div.cashout-btn').replaceWith(
			tmpl_play("cashout_button", info)
		);
	}

	// Re-play the bet preview template with current data
	function updateBetPreview() {
		var info = {};
		info.ccy_code_html = print_ccy_symbol(get_pref("ccy_code"));
		info.bet_preview_shown = (typeof this.partial_cashout_value !== "undefined");

		setBetPreviewInfo.call(this,info);

		this.elem.find('div.bet-preview').replaceWith(
			tmpl_play("bet_preview", info)
		);
	}

	// Perform cashout of a bet via ajax
	function doCashout(skip_ew_term_check) {

		// We can only cashout one bet at a time, and we can only cashout this
		// bet if everything is OK with it.
		if (instance.cashoutInProgress() || this.state !== "OK") {
			return false;
		}

		// Make a note that there is a cashout attempt underway, and display such to the user
		instance.notifyCashout();
		this.setStatus("LOADING");

		// Make sure we have a valid cashout value
		if (typeof this.bet_data.cashout_value === "undefined") {
			this.setStatus("SUSPENDED");
			instance.notifyCashoutComplete();
			return false;
		}

		// If we have a partial cashout value, make sure it is valid
		if (typeof this.partial_cashout_value !== "undefined") {

			var min_potential_stake = parseFloat(isNaN(this.bet_data.potential_bet.min_stake) ? 0 : this.bet_data.potential_bet.min_stake);

			if (parseFloat(this.partial_cashout_value) === 0) {
				core.showModalMessage(cashout_error_ZERO_VALUE_HEADER, cashout_error_ZERO_VALUE);
				instance.notifyCashoutComplete();
				this.setStatus("OK");
				return false;

			} else if (parseFloat(this.partial_cashout_value) > parseFloat(this.bet_data.cashout_value)) {
				core.showModalMessage(cashout_error_MAX_VALUE_HEADER, cashout_error_MAX_VALUE);
				instance.notifyCashoutComplete();
				this.setStatus("OK");
				return false;

			} else if ((Math.round(parseFloat(this.bet_data.cashout_value) * 100) - Math.round(parseFloat(this.partial_cashout_value) * 100)) < Math.round(min_potential_stake * 100)) {
				core.showModalMessage(cashout_error_MIN_VALUE_HEADER, cashout_error_MIN_VALUE);
				instance.notifyCashoutComplete();
				this.setStatus("OK");
				return false;

			} else if (!skip_ew_term_check && this.bet_data.potential_bet.ew_terms_changed) {
				// If the eachway term is changed for the potential bet, then prompt user to get confirmation
				// Frame the message to be displayed on the confirmation modal
				var confirm_message = cashout_confirm_EW_TERM_CHANGE_CNFM + '<br/>';
				// Iterate through legs to create the each way term
				for (var i = 0; i < this.bet_data.potential_bet.ew_seln_str.length; i++) {
					confirm_message   = confirm_message +  this.bet_data.potential_bet.ew_seln_str[i] + '<br/>';
				}
				confirm_message = confirm_message + cashout_confirm_CO_FOR + ' ' + core.formatMoney(this.partial_cashout_value);

				// display the prompt to get user confirmation
				core.showEWModalConfirm(confirm_message, this);
				instance.notifyCashoutComplete();
				this.setStatus("OK");
				return false;
			}
		}

		var req_args = [];
		req_args.push(this.bet_id);
		req_args.push(this.bet_data.cashout_value);
		req_args.push(this.partial_cashout_value || "");
		req_args.push(this.bet_data.potential_bet.bet_type);
		req_args.push(this.bet_data.potential_bet.leg_type);

		// If the bet is Each Way, selections string is a csv list of ev_oc_id:ew_fac_num:ew_fac_den:ew_places
		// If it is not Each Way then it is a csv of just the ev_oc_id
		var selections = [];
		for (var leg_no in this.bet_data.potential_bet.legs) {
			var leg = this.bet_data.potential_bet.legs[leg_no];
			if (this.bet_data.potential_bet.leg_type === "E") {
				selections.push(leg.ev_oc_id + ':' +leg.ew_fac_num + ':' + leg.ew_fac_den  + ':' + leg.ew_places);
			} else {
				selections.push(leg.ev_oc_id);
			}
		}
		req_args.push(selections.join(","));

		var postdata = {
			cashouts_list : req_args.join("|"),
			page : this.opts.origin,
			bet_type : this.bet_data.bet_type
		};

		// Make the AJAX request
		core.makeAjaxRequest("do_cashout", "do_cashout_bets", {}, processCashoutResponse, postdata, this);
	}

	// Process the response from a cashout ajax request
	function processCashoutResponse(clientdata, ok, json) {

		// If the request failed, just return
		if (!ok || json === null) {
			instance.notifyCashoutComplete();
			throw "Failed request";
		}

		// If there was something wrong with the request, throw it
		if (typeof json.status === "undefined" || json.status !== "OK") {
			instance.notifyCashoutComplete();
			if (typeof json.err_msg !== "undefined") {
				throw json.err_msg;
			}
			throw "Unspecified error from server";
		}

		// Also, we expect to have a single success or failure (at the moment), if not
		// then suspend the bet and return.
		if ((json.success.length + json.failed.length) != 1 ) {
			this.setStatus("SUSPENDED");
			instance.notifyCashoutComplete();
			return false;
		}

		if (json.success.length > 0) {
			var resp = json.success[0];
			this.setStatus("COMPLETE");
			instance.notifyCashoutComplete();

			// Also set a timeout to go to the CONFIRMATION step
			var t = this;
			setTimeout(function(){ t.setStatus("CONFIRMATION") }, instance.getCfg("delay_animation") * 1000);

			// Deregister from push channels, stop getting ajax updates,
			// and hide the linked bet receipt (if there is one)
			ps_connect_deregister("cashout_widget_" + this.id);
			this.update_counter = 0;
			this.elem.find("p.cashout-linked-receipt").hide();
			this.update({
				cashout_value: resp.cashout_val
			});

			if (typeof resp.new_bet_id !== "undefined" && typeof resp.new_bet_cashout_unavail_reason === "undefined") {

				// A new bet ID means we need to create a new widget on the page linked to this one
				var new_bet_data = $j.extend(true, {}, this.bet_data, {
					bet_id: resp.new_bet_id,
					parent_bet_id: (this.bet_data.parent_bet_id || this.bet_id),
					state: "OK",
					bet_receipt: resp.new_bet_receipt,
					cashout_value: resp.new_bet_cashout_value,
					stake: resp.new_bet_stake,
					line_stake: resp.new_bet_stake_per_line,
					potential_payout: resp.potential_payout,
					partial_cashout_allowable: resp.partial_cashout_allowable,
					partial_cashout_available: resp.partial_cashout_available,
					bet_desc: resp.new_bet_desc,
					bet_type_name: resp.new_bet_type_name
				});

				// We don't want to extend the selection objects as they're keyed by ev_oc_id, so we
				// would end up keeping old seln data if the selns change. Instead, deliberately overwrite
				// the seln objects.
				new_bet_data.selns = $j.extend(true, {}, this.bet_data.potential_bet.selns, resp.selns);

				// the potential legs of the parent bet, should be copied to the legs of the new bet.
				new_bet_data.legs = this.bet_data.potential_bet.legs;

				if (resp.partial_cashout_available === "Y") {
					new_bet_data.potential_bet.selns = $j.extend(true, {}, this.bet_data.potential_bet.selns, resp.selns);
					new_bet_data.potential_bet.normalised_potential_payout = resp.normalised_potential_payout;

					// ew terms can't be changed when bet is strucked with a partial cashout
					new_bet_data.potential_bet.ew_terms_changed = false;
				}

				var new_widget = this.widgetManager.createWidget(resp.new_bet_id, this.opts, new_bet_data, this.last_msg_id);

				// If upd_partial_cashout_value is defined in the resp, then update partial_cashout_value
				// of this instance
				if (typeof resp.upd_partial_cashout_value !== "undefined") {
					this.partial_cashout_value = resp.upd_partial_cashout_value;
				}

				// Show the partial cashout success div and set a timer for hiding this widget
				this.elem.find("div.partial-cashout-success").show();
				var t = this;
				this.elem.addClass("partially-cashed-out");
				setTimeout(function(){

					if (new_widget) {
						new_widget.elem.find("p.cashout-linked-receipt").hide();
					}

					t.elem.hide().removeClass("partially-cashed-out");
				}, instance.getCfg("partial_hide_delay") * 1000);
			}

			if (typeof resp.new_bet_cashout_unavail_reason !== "undefined") {
				// Here we have a successfull partial cashout but the new bet is not available for cashout so..
				// We need to inform the customer about this.
				core.showModalMessage("cashout_error_NEW_BET_CO_UNAVAILABLE_HEADER", "cashout_error_NEW_BET_CO_UNAVAILABLE");
			}

		} else if (json.failed.length > 0) {
			// We should have only given one bet to be cashed out. This may change in future
			// but for now we only handle the first.
			var resp = json.failed[0];
			var error_short = resp.error_short;

			switch (error_short) {
				case "PRICE_CHANGE":
				case "PARTIAL_CASHOUT_ABOVE_FULL_CO" :
					// We need to notify the user that the price has changed
					if (error_short === "PARTIAL_CASHOUT_ABOVE_FULL_CO") {
						core.showModalMessage(cashout_error_MAX_VALUE_HEADER, cashout_error_MAX_VALUE);
					} else {
						core.notifyPriceChange();
					}
					instance.notifyCashoutComplete();

					this.setStatus("OK");

					// On a price change, determine whether partial cashout allowed or not
					// so that the widget can be enabled or disabled
					var partial_co_allowable = this.bet_data.partial_cashout_allowable;
					var min_pco_value = isNaN(parseFloat(instance.getCfg("min_pco_value"))) ? 0 : parseFloat(instance.getCfg("min_pco_value"));
					if (this.bet_data.partial_cashout_available === "Y") {
						if (resp.upd_cashout_val >= parseFloat(this.bet_data.potential_bet.min_stake) && resp.upd_cashout_val > min_pco_value) {
							partial_co_allowable = "Y";
						}
						else {
							partial_co_allowable = "N";
						}
					}
					this.update({
						cashout_value: resp.upd_cashout_val,
						cashout_unavail_reason: "OK",
						partial_cashout_allowable: partial_co_allowable
					});
					break;

				// The expected bet type of the new bet has changed.
				// This can happen for partial accumulator cashout when selections are voided
				case "PARTIAL_CASHOUT_BET_TYPE_CHANGE":
					// We need to notify the user that the price has changed
					core.showModalMessage(cashout_error_BET_TYPE_CHANGED_HEADER, cashout_error_BET_TYPE_CHANGED);
					instance.notifyCashoutComplete();

					// We'll be expected a push message shortly that will trigger an update, it may even have
					// arrived by now and is waiting to be dealt with. So suspend for the moment, the next ajax
					// refresh will get the correct data and un-suspend.
					this.setStatus("SUSPENDED");
					break;

				// The expected eachway term of the new bet has changed.
				// This can happen for partial eachway single cashout
				case "PARTIAL_CASHOUT_EW_TERM_CHANGE":
					// We need to notify the user that the eachway term has changed
					core.showModalMessage(cashout_error_EW_TERM_CHANGED_HEADER, cashout_error_EW_TERM_CHANGED);
					instance.notifyCashoutComplete();

					// We'll be expected a push message shortly that will trigger an update, it may even have
					// arrived by now and is waiting to be dealt with. So suspend for the moment, the next ajax
					// refresh will get the correct data and un-suspend.
					this.setStatus("SUSPENDED");
					break;

				// The expected leg type of the new bet has changed.
				// This can happen for partial eachway single cashout
				case "PARTIAL_CASHOUT_EW_TERM_UNAVAILABLE":
					// We need to notify the user that the eachway term is not available
					core.showModalMessage(cashout_error_EW_TERM_UNAVAILABLE_HEADER, cashout_error_EW_TERM_UNAVAILABLE);
					instance.notifyCashoutComplete();

					// We'll be expected a push message shortly that will trigger an update, it may even have
					// arrived by now and is waiting to be dealt with. So suspend for the moment, the next ajax
					// refresh will get the correct data and un-suspend.
					this.setStatus("SUSPENDED");
					break;

				// The new bet is more than the Maximum allowed for the selection
				case "CASHOUT_NEW_BET_TOO_HIGH":
					// Show a modal alert

					// Remove the price part of the bet_desc if any
					var bet_descr   = this.bet_data.bet_desc;
					var end_index = bet_descr.indexOf("@");
					if (end_index > 0) {
						bet_descr = bet_descr.substring(0,end_index);
					}

					var error_message = cashout_error_CO_MAXIMUM_STAKE_ERROR +' '+ bet_descr +' '+ cashout_error_CO_IS +' '+ resp.max_stake.toFixed(2);
					core.showModalMessage(cashout_error_INVALID_STAKE_HEADER, error_message);
					instance.notifyCashoutComplete();
					this.setStatus("OK");
					// Move slider to full cashout position
					this.elem.find("input.manual").val("");
					if (this.slider) {
						this.slider.ionRangeSlider.update({
							from: this.slider.ionRangeSlider.options.max
						});
					}
					updatePartialCashoutValue.call(this, "");
					break;

				case "CASHOUT_DELAY":
					// Start up an ajax poll to check for the cashout being completed
					// after the delay. The initial poll time is returned in the request.
					// We deliberately do not allow other cashouts while this is pending!
					this.cashout_delay = resp;
					this.cashout_delay.poll_start_time = new Date().getTime();
					var t = this;
					core.scheduleAjaxPoll("cashout_delay", function() { checkCashoutDelay.call(t) }, this.cashout_delay.bir_delay + 0.5);
					break;

				case "SELN_SUSP":
					// Mark the cashout as suspended and show the suspended selections if necessary
					this.setStatus("SUSPENDED");
					instance.notifyCashoutComplete();
					this.update({
						cashout_value: "CASHOUT_UNAVAILABLE",
						cashout_unavail_reason: "SELN_SUSP",
						cashout_unavail_reason_selns: resp.cashout_unavail_reason_selns
					});
					break;

				case "CASHOUT_BET_ALREADY_SETTLED":
					// Mark the cashout as suspended
					this.setStatus("SUSPENDED");
					instance.notifyCashoutComplete();
					this.update({
						cashout_value: "CASHOUT_UNAVAILABLE",
						cashout_unavail_reason: error_short,
						partial_cashout_available: "N"
					});
					break;

				case "HR_SELN_IN_PLAY":
					// One of the selections are Horse Racing and are now in-play
					// Mark the cashout as suspended
					this.setStatus("SUSPENDED");
					instance.notifyCashoutComplete();

					// Notify the customer about the error
					core.showModalMessage(cashout_error_HR_SELN_IN_PLAY_HEADER, cashout_error_HR_SELN_IN_PLAY);

					this.update({
						cashout_value: "CASHOUT_UNAVAILABLE",
						cashout_unavail_reason: error_short,
						partial_cashout_available: "N",
						cashout_unavail_reason_selns: resp.cashout_unavail_reason_selns
					});
					break;

				case "NO_BIR_EVENT":
					// No BIR-event is selected and the cashout is unavailable
					// Mark the cashout as suspended
					this.setStatus("SUSPENDED");
					instance.notifyCashoutComplete();

					this.update({
						cashout_value: "CASHOUT_UNAVAILABLE",
						cashout_unavail_reason: error_short,
						partial_cashout_available: "N",
					});
					break;


				case "PARTIAL_CASHOUT_UNAVAILABLE_UNKNOWN_REASON":
					instance.notifyCashoutComplete();

					// We'll be expected a push message shortly that will trigger an update, it may even have
					// arrived by now and is waiting to be dealt with. So suspend for the moment, the next ajax
					// refresh will get the correct data and un-suspend.
					this.setStatus("SUSPENDED");
					break;

				case "UNKNOWN_ERROR" :
				case "TIMEOUT"       :
					// We don't know what happened - do nothing
					instance.notifyCashoutComplete();
					break;

				default:
					// Mark the cashout as suspended
					this.setStatus("SUSPENDED");
					instance.notifyCashoutComplete();
					this.update({
						cashout_value: resp.upd_cashout_val,
						cashout_unavail_reason: error_short
					});
					break;
			}

		}
	}

	// Polling function to check for the current status of a cashout that has been delayed because the bet is in-running
	function checkCashoutDelay() {
		var postdata = {
			bir_req_ids : this.cashout_delay.bir_req_id,
			page : this.opts.origin,
			bet_type : this.bet_data.bet_type
		};
		core.makeAjaxRequest("cashout_delay", "get_cashout_req_status", {}, processCashoutDelayResponse, postdata, this);
	}

	// Process the response from a cashout (BIR) delay ajax request
	function processCashoutDelayResponse(clientdata, ok, json) {
		if (ok && json !== null) {
			if (json.success.length > 0 || json.failed.length > 0) {
				// Parse the cashout response as per normal
				processCashoutResponse.call(this, clientdata, ok, json);
			}
			// If there's nothing left to poll for, then we can stop
			if (json.pending.length == 0) {
				return;
			}
		}
		// If we reach this point then we need to try again for some reason.
		// But we don't want to keep trying forever, so if the time we started polling was too long ago,
		// then just give up instead.
		var now = new Date().getTime();
		if (now - this.cashout_delay.poll_start_time > instance.getCfg("max_poll_length")) {
			// We've been polling for too long. Suspend the widget and allow other cashouts once more
			this.setStatus("SUSPENDED");
			instance.notifyCashoutComplete();
			return;
		}

		// Otherwise, keep polling
		// Since this isn't the first time, we use a configurable poll time from the cashout instance instead of the bet delay value
		var t = this;
		core.scheduleAjaxPoll("cashout_delay", function() { checkCashoutDelay.call(t) }, instance.getCfg("in_running_poll"));
	}

	// Does this widget think it needs to be updated via ajax?
	function requiresUpdate() {
		return (this.update_counter > 0);
	}

	// Set some new data in this widget and force it to redisplay
	function update(new_bet_data) {
		if (this.update_counter > 0) this.update_counter--;

		// Since price changes are accepted by the customer sometimes,
		// do the below check only if the cashout state is not COMPLETE or CONFIRMATION.
		// If the cashout offer has changed, then we drop any currently-entered partial cashout value,
		// clear the manual input, and put the slider back to maximum.
		if (this.state !== "COMPLETE" && this.state !== "CONFIRMATION") {
			if (typeof new_bet_data.cashout_value !== "undefined") {
				if (this.bet_data.cashout_value != new_bet_data.cashout_value ||
						(this.bet_data.leg_type == "E" && core.isEwChanged(this.bet_data.potential_bet, new_bet_data.potential_bet))) {
					this.elem.find("input.manual").val("");
					if (this.slider) {
						this.slider.ionRangeSlider.update({
							from: this.slider.ionRangeSlider.options.max
						});
					}
					updatePartialCashoutValue.call(this, "");
				}
			}
		}

		// If the push events have changed, then we need to alter the push subscription
		var redo_push = false;
		if (typeof new_bet_data.ev_ids !== "undefined") {
			if (this.bet_data.ev_ids.length !== new_bet_data.ev_ids.length || this.bet_data.ev_ids.intersect(new_bet_data.ev_ids).length !== this.bet_data.ev_ids.length) {
				var redo_push = true;
			}
		}

		// This only relates to push messages
		// A selection might have been resulted or settled so we need to remove the old bet_data.potential_bet.selns
		// before calling extend $j.extend, cause $j.extend only merges existing data does not delete, so we can end up
		// with a settled selection
		if (typeof new_bet_data.potential_bet !== "undefined"
					&& typeof new_bet_data.potential_bet.selns !== "undefined" ) {
			try {
				delete this.bet_data.potential_bet.selns;
				delete this.bet_data.potential_bet.legs;
			} catch (e) {
				console.log(e);
			}
		}

		// Replace old data with new
		$j.extend(true, this.bet_data, new_bet_data);

		// Update the state if something has changed, e.g. the offer has become suspended
		// However if this widget has been cashed out then ignore the update. Normally the widgets unsubscribe themselves from updates
		// when they're cashed out - this is to catch a very rare edge case where the regular ajax poll fires between the start
		// of a cashout request and the processing of the response.
		if (typeof new_bet_data.state !== "undefined" && this.state !== "COMPLETE" && this.state !== "CONFIRMATION") {
			this.setStatus(new_bet_data.state);
		}

		// Now we have replaced the data we can update the push channels if we decided it was necessary
		if (redo_push) {
			this.registerPushChannels();
		}

		// Re-display the widget with new data
		this.display();
	}

	// Register for the push channels we are interested in.
	// These can change over the lifetime of a widget - for example if an event goes in-running then the selections
	// in the partial cashout potential bet can change to be the ones from the BIR event.
	function registerPushChannels() {
		if (!this.opts.push_enabled) { return; }

		var push_client_id = "cashout_widget_" + this.id;

		var push_channels = [];

		for (var i=0; i<this.bet_data.ev_ids.length; i++) {
			var padded_ev_id = ps_connect_lpad_id(this.bet_data.ev_ids[i]);
			push_channels.push("sEVENT" + padded_ev_id);
		}

		for (var ev_oc_id in this.bet_data.selns) {
			var seln = this.bet_data.selns[ev_oc_id];
			var padded_ev_mkt_id = ps_connect_lpad_id(seln.ev_mkt_id);
			push_channels.push("sEVMKT" + padded_ev_mkt_id,"SEVMKT" + padded_ev_mkt_id);
		}

		if (push_channels.length > 0) {
			var t = this;
			ps_connect_register(push_client_id, function(msg) { t.gotPushMessage.call(t,msg); }, push_channels, this.last_msg_id);
		}

	}

	// Deal with push updates.
	// Any change to the event, market, selection, or any other selection in the same market can change
	// the cashout value of a bet. Due to this, any push message relating to any event in this bet will cause
	// the cashout value to be recalculated.
	// We don't really care what the message is however, since the value can't be calculated in the front-end.
	// Since we're only subscribing to messages we care about, any push message we get must mean we need to make
	// the ajax request to recalculate.
	function gotPushMessage(msg) {
		// Keep track of the last message ID
		this.last_msg_id = msg.msg_id;

		// Set the counter to 2 so that two attempts are made to calculate the cashout value
		// This reduces the chance of displaying a value based on old cached data.
		this.update_counter = 2;
	}

	return {
		display: display,
		bindEvents: bindEvents,
		setStatus: setStatus,
		doCashout: doCashout,
		updatePartialCashoutValue: updatePartialCashoutValue,
		requiresUpdate: requiresUpdate,
		update: update,
		registerPushChannels: registerPushChannels,
		gotPushMessage: gotPushMessage
	}
})();



/* Writing crunched file first_dep_limit.js */
// Show/hide deposit limits section
function toggle_deplim(state) {

	if (deplim_on == state) {
		return;
	}
	if (state) {

		$j('#deplim_enabled').val(1);
		$j('#first_dep_lim').css('display','block');
		$j('#deplim-yes').addClass('active');
		$j('#deplim-no').removeClass('active');
		$j('#deplim_radio_day').attr('checked', 'checked');
		gen_deplim_ddown('day');
		deplim_on = true;

	} else {
		$j('#deplim_enabled').val(0);
		$j('#first_dep_lim').css('display','none');
		$j('#deplim-no').addClass('active');
		$j('#deplim-yes').removeClass('active');
		deplim_on = false;
	}

	if (typeof is_thirdparty !== 'undefined' && is_thirdparty == 1) {
		resize_self();
	}

}

// Construct the deposit limits drop down
function gen_deplim_ddown(period) {

	var period_max = 0;

	switch(period) {
		case 'day':
			period_max = deplim_day_max;
			break;
		case 'week':
			period_max = deplim_week_max;
			break;
		case 'month':
			period_max = deplim_month_max;
			break;
		default:
			return;
	}

	$j('#DepLimDivInput').val('');

	var sel_el = $j('#deplim_dropdown');
	sel_el.html('');

	// Create please select option
	var textNode = document.createTextNode(acct_first_dep_lim_SELECT);
	var option_el = document.createElement('option');
	option_el.setAttribute('value','');
	option_el.setAttribute('selected','true');
	option_el.appendChild(textNode);
	sel_el.append(option_el);

	// Populate with limit options
	for (var i=0; i < deplim_values.length && deplim_values[i]<=period_max; i++) {
		var textNode = document.createTextNode(deplim_values[i]);
		var option_el = document.createElement('option');
		option_el.setAttribute('value',deplim_values[i]);

		option_el.appendChild(textNode);
		sel_el.append(option_el);
	}

	// Last option enables customer to enter a custom limit
	var textNode = document.createTextNode(acct_first_dep_lim_OTHER_LIMIT);
	var option_el = document.createElement('option');
	option_el.setAttribute('value','-1');
	option_el.appendChild(textNode);
	sel_el.append(option_el);

	// Define if we should show the custom limit input field
	deplim_other_blank();

}

// Define if we should show the custom limit input field
function deplim_other_blank() {

	var sel_el = $j('#deplim_dropdown');

	var selected = sel_el.val();

	if (selected == -1) {
		$j('#DepLimDivInput').val('');
		$j('#DepLimDivInput').removeClass('hide');
	} else {
		$j('#DepLimDivInput').addClass('hide');
	}

}

function validateDepLimitDrpDown() {
	var sel_el = $j('#deplim_dropdown');
	var selected = sel_el.val();

	// Do the validation it the free text is not selected
	// Typing on free text will trigger it's own validation
	if (selected != -1) {
		tooltipDepLim (true);
	}
}

// Validate and display alert if needed
function tooltipDepLim (validate) {
	var err_msg = "";
	// toolptip is not available in Dep Limits
	var tooltip_msg = "";

	if (!validate) {
		return showValidText("DepLimDiv", tooltip_msg);
	}

	var result = validate_deplim();
	if (result.status) {
		return setStatus("DepLimDiv",'',tooltip_msg,'');
	} else {
		err_msg = result.err_msg;
		return setStatus("DepLimDiv",err_msg,tooltip_msg,err_msg);
	}
}

// Deposit limits section validation
// Its been called by general account validation form
function validate_deplim() {

	var err_msg           = '';
	var sel_el            = $j('#deplim_dropdown');
	var err_period_max    = '';
	var err_period_min    = '';

	if (!($j("#deplim_enabled").length > 0)) {
		// Nothing to check as we do not offer customer to set his deposit limits
		return {status : true};
	} else if ($j("#deplim_enabled").val() == 1) {



		// Ensure that a period type is checked
		var deplim_period = $j('input[name=deplim_period]:checked').val();

		if (typeof deplim_period == 'undefined' || deplim_period == "") {
			err_msg += acct_first_dep_lim_SELECT_PERIOD_TYPE+"\n";
		}

		var deplim_val = sel_el.val();

		if (deplim_val == '') {
			err_msg += acct_first_dep_lim_SELECT_LIMIT+"\n";
		} else if (deplim_val == '-1') {
			// Customer chose to enter his own limit
			var other_limit = $j('#DepLimDivInput').val();

			// Validate the value he has put
			if (other_limit == '' || !$j.isNumeric(other_limit)){
				err_msg += acct_first_dep_lim_ENTER_OTHER_AMOUNT+"\n";
			} else {

				// Check amount below max period amount.
				var period_max = '';
				var period_min = '';
				switch(deplim_period) {
					case 'day':
						period_max     = deplim_day_max_free_txt;
						period_min     = deplim_day_min_free_txt;
						err_period_max = acct_first_dep_lim_ABOVE_MAX_DAY;
						err_period_min = acct_first_dep_lim_UNDER_MIN_DAY;
						break;
					case 'week':
						period_max     = deplim_week_max_free_txt;
						period_min     = deplim_week_min_free_txt;
						err_period_max = acct_first_dep_lim_ABOVE_MAX_WEEK;
						err_period_min = acct_first_dep_lim_UNDER_MIN_WEEK;
						break;
					case 'month':
						period_max     = deplim_month_max_free_txt;
						period_min     = deplim_month_min_free_txt;
						err_period_max = acct_first_dep_lim_ABOVE_MAX_MONTH;
						err_period_min = acct_first_dep_lim_UNDER_MIN_MONTH;
						break;
					default:
						break;
				}
				if (period_max!='' && period_max < other_limit) {
					err_msg += err_period_max+"\n";
				}
				if (period_min!='' && period_min > other_limit) {
					err_msg += err_period_min+"\n";
				}
			}
		}

	} else {
		// Just for sanity reasons
		sel_el.val('');
	}

	if (err_msg != ''){
		return {status : false , err_msg : err_msg};
	}
	return {status : true};
}


